
freeRTOS_NTI_G9.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006c26  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00006c26  00006cba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006b8  008000a8  008000a8  00006d02  2**0
                  ALLOC
  3 .stab         0000b754  00000000  00000000  00006d04  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004dcf  00000000  00000000  00012458  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00017227  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00017367  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000174d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00019120  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001a00b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001adb8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001af18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001b1a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001b973  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c4 1e 	jmp	0x3d88	; 0x3d88 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 97 0f 	jmp	0x1f2e	; 0x1f2e <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e2       	ldi	r30, 0x26	; 38
      68:	fc e6       	ldi	r31, 0x6C	; 108
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3a       	cpi	r26, 0xA8	; 168
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 ea       	ldi	r26, 0xA8	; 168
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 36       	cpi	r26, 0x60	; 96
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 79 1b 	call	0x36f2	; 0x36f2 <main>
      8a:	0c 94 11 36 	jmp	0x6c22	; 0x6c22 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ca 35 	jmp	0x6b94	; 0x6b94 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a2 e9       	ldi	r26, 0x92	; 146
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e6 35 	jmp	0x6bcc	; 0x6bcc <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f2 35 	jmp	0x6be4	; 0x6be4 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f2 35 	jmp	0x6be4	; 0x6be4 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ca 35 	jmp	0x6b94	; 0x6b94 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	82 e9       	ldi	r24, 0x92	; 146
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e6 35 	jmp	0x6bcc	; 0x6bcc <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 f2 35 	jmp	0x6be4	; 0x6be4 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 f2 35 	jmp	0x6be4	; 0x6be4 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 d6 35 	jmp	0x6bac	; 0x6bac <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 f2 35 	jmp	0x6be4	; 0x6be4 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 da 35 	jmp	0x6bb4	; 0x6bb4 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 f6 35 	jmp	0x6bec	; 0x6bec <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <UART_enuInit>:
static u8 LOC_u8ReceiveBufferSize = 0;
static u8 LOC_u8ReceiveBufferIndex = 0;
static ES_t LOC_enuCompleteReceiveBuffer = ES_NOK;

ES_t UART_enuInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <UART_enuInit+0x6>
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <UART_enuInit+0x8>
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	8c 83       	std	Y+4, r24	; 0x04

	#if SPEED_MODE == NORMAL
		UCSRA &=~(1<<1);
	#elif SPEED_MODE == DOUBLE
		UCSRA |= (1<<1);
     b56:	ab e2       	ldi	r26, 0x2B	; 43
     b58:	b0 e0       	ldi	r27, 0x00	; 0
     b5a:	eb e2       	ldi	r30, 0x2B	; 43
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	80 81       	ld	r24, Z
     b60:	82 60       	ori	r24, 0x02	; 2
     b62:	8c 93       	st	X, r24
	#endif

	#if UART_MODE == TRANSCIEVER
		UCSRB |=(3<<3);
     b64:	aa e2       	ldi	r26, 0x2A	; 42
     b66:	b0 e0       	ldi	r27, 0x00	; 0
     b68:	ea e2       	ldi	r30, 0x2A	; 42
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
     b6c:	80 81       	ld	r24, Z
     b6e:	88 61       	ori	r24, 0x18	; 24
     b70:	8c 93       	st	X, r24
		UCSRB |= (1<<RXC);
     b72:	aa e2       	ldi	r26, 0x2A	; 42
     b74:	b0 e0       	ldi	r27, 0x00	; 0
     b76:	ea e2       	ldi	r30, 0x2A	; 42
     b78:	f0 e0       	ldi	r31, 0x00	; 0
     b7a:	80 81       	ld	r24, Z
     b7c:	80 68       	ori	r24, 0x80	; 128
     b7e:	8c 93       	st	X, r24
	#endif
    
    u8 Local_u8UCSRC=0;
     b80:	1b 82       	std	Y+3, r1	; 0x03

	#if DATA_LEN == EIGHT
		Local_u8UCSRC |= (3<<1);
     b82:	8b 81       	ldd	r24, Y+3	; 0x03
     b84:	86 60       	ori	r24, 0x06	; 6
     b86:	8b 83       	std	Y+3, r24	; 0x03
	#endif

	#if PARITY_STATE == NO_PARITY
		Local_u8UCSRC &= ~ (3<<4);
     b88:	8b 81       	ldd	r24, Y+3	; 0x03
     b8a:	8f 7c       	andi	r24, 0xCF	; 207
     b8c:	8b 83       	std	Y+3, r24	; 0x03
	#endif

	#if STOP_STATE == ONE_STOP_BIT
		Local_u8UCSRC &= ~(1<<3);
     b8e:	8b 81       	ldd	r24, Y+3	; 0x03
     b90:	87 7f       	andi	r24, 0xF7	; 247
     b92:	8b 83       	std	Y+3, r24	; 0x03
	#endif

	#if CLOCK_MODE == ASYCH
		Local_u8UCSRC &=~(1<<6);
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	8f 7b       	andi	r24, 0xBF	; 191
     b98:	8b 83       	std	Y+3, r24	; 0x03
	#endif
	Local_u8UCSRC |=(1<<7);
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	80 68       	ori	r24, 0x80	; 128
     b9e:	8b 83       	std	Y+3, r24	; 0x03
	UCSRC = Local_u8UCSRC;
     ba0:	e0 e4       	ldi	r30, 0x40	; 64
     ba2:	f0 e0       	ldi	r31, 0x00	; 0
     ba4:	8b 81       	ldd	r24, Y+3	; 0x03
     ba6:	80 83       	st	Z, r24

	u16 Local_u16UBRR = BAUD_CALCULATOR(BAUDRATE);
     ba8:	8f ec       	ldi	r24, 0xCF	; 207
     baa:	90 e0       	ldi	r25, 0x00	; 0
     bac:	9a 83       	std	Y+2, r25	; 0x02
     bae:	89 83       	std	Y+1, r24	; 0x01

	Local_u16UBRR &=~(1<<15);
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	9f 77       	andi	r25, 0x7F	; 127
     bb6:	9a 83       	std	Y+2, r25	; 0x02
     bb8:	89 83       	std	Y+1, r24	; 0x01

	UBRRL  = (u8)Local_u16UBRR;
     bba:	e9 e2       	ldi	r30, 0x29	; 41
     bbc:	f0 e0       	ldi	r31, 0x00	; 0
     bbe:	89 81       	ldd	r24, Y+1	; 0x01
     bc0:	80 83       	st	Z, r24
	UBRRH  = (u8)(Local_u16UBRR>>8);
     bc2:	e0 e4       	ldi	r30, 0x40	; 64
     bc4:	f0 e0       	ldi	r31, 0x00	; 0
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	9a 81       	ldd	r25, Y+2	; 0x02
     bca:	89 2f       	mov	r24, r25
     bcc:	99 27       	eor	r25, r25
     bce:	80 83       	st	Z, r24

	return Local_enuErrorState;
     bd0:	8c 81       	ldd	r24, Y+4	; 0x04
}
     bd2:	0f 90       	pop	r0
     bd4:	0f 90       	pop	r0
     bd6:	0f 90       	pop	r0
     bd8:	0f 90       	pop	r0
     bda:	cf 91       	pop	r28
     bdc:	df 91       	pop	r29
     bde:	08 95       	ret

00000be0 <UART_enuReceive_IT>:

ES_t UART_enuReceive_IT(u8 * Copy_pu8Buffer , u8 Copy_u8BufferSize)
{
     be0:	df 93       	push	r29
     be2:	cf 93       	push	r28
     be4:	00 d0       	rcall	.+0      	; 0xbe6 <UART_enuReceive_IT+0x6>
     be6:	00 d0       	rcall	.+0      	; 0xbe8 <UART_enuReceive_IT+0x8>
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	9b 83       	std	Y+3, r25	; 0x03
     bee:	8a 83       	std	Y+2, r24	; 0x02
     bf0:	6c 83       	std	Y+4, r22	; 0x04
	ES_t Local_enuErrorState = ES_NOK;
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	89 83       	std	Y+1, r24	; 0x01

	if (LOC_bWaitFlagUntilFillBuffer == FALSE)
     bf6:	80 91 ac 00 	lds	r24, 0x00AC
     bfa:	88 23       	and	r24, r24
     bfc:	99 f4       	brne	.+38     	; 0xc24 <UART_enuReceive_IT+0x44>
	{
		LOC_u8ReceiveBufferSize = Copy_u8BufferSize;
     bfe:	8c 81       	ldd	r24, Y+4	; 0x04
     c00:	80 93 af 00 	sts	0x00AF, r24
		LOC_pu8ReceiveBuffer = Copy_pu8Buffer;
     c04:	8a 81       	ldd	r24, Y+2	; 0x02
     c06:	9b 81       	ldd	r25, Y+3	; 0x03
     c08:	90 93 ae 00 	sts	0x00AE, r25
     c0c:	80 93 ad 00 	sts	0x00AD, r24
		LOC_u8ReceiveBufferIndex =0;
     c10:	10 92 b0 00 	sts	0x00B0, r1
		Local_enuErrorState = ES_WAIT;
     c14:	84 e0       	ldi	r24, 0x04	; 4
     c16:	89 83       	std	Y+1, r24	; 0x01
		LOC_bWaitFlagUntilFillBuffer = TRUE;
     c18:	81 e0       	ldi	r24, 0x01	; 1
     c1a:	80 93 ac 00 	sts	0x00AC, r24
		LOC_bOneTimeAccessReceiveConfig = FALSE;
     c1e:	10 92 ab 00 	sts	0x00AB, r1
     c22:	02 c0       	rjmp	.+4      	; 0xc28 <UART_enuReceive_IT+0x48>
	}
	else 
	{
		Local_enuErrorState = ES_WAIT;
     c24:	84 e0       	ldi	r24, 0x04	; 4
     c26:	89 83       	std	Y+1, r24	; 0x01
	}

	if (LOC_u8ReceiveBufferSize == 0)
     c28:	80 91 af 00 	lds	r24, 0x00AF
     c2c:	88 23       	and	r24, r24
     c2e:	51 f4       	brne	.+20     	; 0xc44 <UART_enuReceive_IT+0x64>
	{
		Local_enuErrorState = ES_OK;
     c30:	19 82       	std	Y+1, r1	; 0x01
		LOC_bWaitFlagUntilFillBuffer = FALSE;
     c32:	10 92 ac 00 	sts	0x00AC, r1
		UCSRB &=~(1<<RXC);
     c36:	aa e2       	ldi	r26, 0x2A	; 42
     c38:	b0 e0       	ldi	r27, 0x00	; 0
     c3a:	ea e2       	ldi	r30, 0x2A	; 42
     c3c:	f0 e0       	ldi	r31, 0x00	; 0
     c3e:	80 81       	ld	r24, Z
     c40:	8f 77       	andi	r24, 0x7F	; 127
     c42:	8c 93       	st	X, r24
	}


	if (LOC_bOneTimeAccessReceiveConfig == FALSE)
     c44:	80 91 ab 00 	lds	r24, 0x00AB
     c48:	88 23       	and	r24, r24
     c4a:	69 f4       	brne	.+26     	; 0xc66 <UART_enuReceive_IT+0x86>
	{
		LOC_bOneTimeAccessReceiveConfig = TRUE ;
     c4c:	81 e0       	ldi	r24, 0x01	; 1
     c4e:	80 93 ab 00 	sts	0x00AB, r24
		LOC_enuCompleteReceiveBuffer = ES_NOK;
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	80 93 9a 00 	sts	0x009A, r24
		UCSRB |= (1<<RXC);
     c58:	aa e2       	ldi	r26, 0x2A	; 42
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	ea e2       	ldi	r30, 0x2A	; 42
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	80 81       	ld	r24, Z
     c62:	80 68       	ori	r24, 0x80	; 128
     c64:	8c 93       	st	X, r24
	}
	return Local_enuErrorState;
     c66:	89 81       	ldd	r24, Y+1	; 0x01
}
     c68:	0f 90       	pop	r0
     c6a:	0f 90       	pop	r0
     c6c:	0f 90       	pop	r0
     c6e:	0f 90       	pop	r0
     c70:	cf 91       	pop	r28
     c72:	df 91       	pop	r29
     c74:	08 95       	ret

00000c76 <UART_enuGetReceiveITState>:

ES_t UART_enuGetReceiveITState(void)
{
     c76:	df 93       	push	r29
     c78:	cf 93       	push	r28
     c7a:	0f 92       	push	r0
     c7c:	cd b7       	in	r28, 0x3d	; 61
     c7e:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuReceiveState = ES_NOK;
     c80:	81 e0       	ldi	r24, 0x01	; 1
     c82:	89 83       	std	Y+1, r24	; 0x01
	if (LOC_enuCompleteReceiveBuffer != ES_OK)
     c84:	80 91 9a 00 	lds	r24, 0x009A
     c88:	88 23       	and	r24, r24
     c8a:	21 f0       	breq	.+8      	; 0xc94 <UART_enuGetReceiveITState+0x1e>
	{
		Local_enuReceiveState = LOC_enuCompleteReceiveBuffer;
     c8c:	80 91 9a 00 	lds	r24, 0x009A
     c90:	89 83       	std	Y+1, r24	; 0x01
     c92:	06 c0       	rjmp	.+12     	; 0xca0 <UART_enuGetReceiveITState+0x2a>
	}
	else
	{
		Local_enuReceiveState = ES_OK;
     c94:	19 82       	std	Y+1, r1	; 0x01
		LOC_bWaitFlagUntilFillBuffer = FALSE;
     c96:	10 92 ac 00 	sts	0x00AC, r1
		LOC_enuCompleteReceiveBuffer = ES_NOK;
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	80 93 9a 00 	sts	0x009A, r24
	}
	return Local_enuReceiveState;
     ca0:	89 81       	ldd	r24, Y+1	; 0x01
}
     ca2:	0f 90       	pop	r0
     ca4:	cf 91       	pop	r28
     ca6:	df 91       	pop	r29
     ca8:	08 95       	ret

00000caa <UART_enuSetRxCallBack>:

ES_t UART_enuSetRxCallBack(void(*Copy_pfunAppFun)(void))
{
     caa:	df 93       	push	r29
     cac:	cf 93       	push	r28
     cae:	00 d0       	rcall	.+0      	; 0xcb0 <UART_enuSetRxCallBack+0x6>
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62
     cb4:	9a 83       	std	Y+2, r25	; 0x02
     cb6:	89 83       	std	Y+1, r24	; 0x01
	if (Copy_pfunAppFun != NULL)
     cb8:	89 81       	ldd	r24, Y+1	; 0x01
     cba:	9a 81       	ldd	r25, Y+2	; 0x02
     cbc:	00 97       	sbiw	r24, 0x00	; 0
     cbe:	81 f0       	breq	.+32     	; 0xce0 <UART_enuSetRxCallBack+0x36>
	{
		UCSRB |= (1<<RXC);
     cc0:	aa e2       	ldi	r26, 0x2A	; 42
     cc2:	b0 e0       	ldi	r27, 0x00	; 0
     cc4:	ea e2       	ldi	r30, 0x2A	; 42
     cc6:	f0 e0       	ldi	r31, 0x00	; 0
     cc8:	80 81       	ld	r24, Z
     cca:	80 68       	ori	r24, 0x80	; 128
     ccc:	8c 93       	st	X, r24
		LOC_bIsCallBackAcessed = TRUE;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	80 93 aa 00 	sts	0x00AA, r24
		LOC_pfunISRCallBack = Copy_pfunAppFun;
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	9a 81       	ldd	r25, Y+2	; 0x02
     cd8:	90 93 a9 00 	sts	0x00A9, r25
     cdc:	80 93 a8 00 	sts	0x00A8, r24
	}
	return ES_OK;
     ce0:	80 e0       	ldi	r24, 0x00	; 0
}
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <UART_u8GetRxBufferFromISR>:
u8 UART_u8GetRxBufferFromISR(void)
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	0f 92       	push	r0
     cf2:	cd b7       	in	r28, 0x3d	; 61
     cf4:	de b7       	in	r29, 0x3e	; 62
	u8 data = 0xff;
     cf6:	8f ef       	ldi	r24, 0xFF	; 255
     cf8:	89 83       	std	Y+1, r24	; 0x01
	// if (LOC_bIsCallBackAcessed == TRUE)
	// {
		data = UDR;
     cfa:	ec e2       	ldi	r30, 0x2C	; 44
     cfc:	f0 e0       	ldi	r31, 0x00	; 0
     cfe:	80 81       	ld	r24, Z
     d00:	89 83       	std	Y+1, r24	; 0x01
	// }
	return data;
     d02:	89 81       	ldd	r24, Y+1	; 0x01
}
     d04:	0f 90       	pop	r0
     d06:	cf 91       	pop	r28
     d08:	df 91       	pop	r29
     d0a:	08 95       	ret

00000d0c <UART_enuTransmit>:

ES_t UART_enuTransmit(u8 * Copy_pu8Buffer , u8 Copy_u8Size , u8 Copy_u8Timeout)
{
     d0c:	df 93       	push	r29
     d0e:	cf 93       	push	r28
     d10:	cd b7       	in	r28, 0x3d	; 61
     d12:	de b7       	in	r29, 0x3e	; 62
     d14:	2b 97       	sbiw	r28, 0x0b	; 11
     d16:	0f b6       	in	r0, 0x3f	; 63
     d18:	f8 94       	cli
     d1a:	de bf       	out	0x3e, r29	; 62
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	cd bf       	out	0x3d, r28	; 61
     d20:	98 87       	std	Y+8, r25	; 0x08
     d22:	8f 83       	std	Y+7, r24	; 0x07
     d24:	69 87       	std	Y+9, r22	; 0x09
     d26:	4a 87       	std	Y+10, r20	; 0x0a
	ES_t Local_enuErrorState = ES_NOK;
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	8e 83       	std	Y+6, r24	; 0x06
    u32 Local_u32Timeout = Copy_u8Timeout * CLOCK_CYCLE_TO_MS;
     d2c:	8a 85       	ldd	r24, Y+10	; 0x0a
     d2e:	88 2f       	mov	r24, r24
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	a0 e0       	ldi	r26, 0x00	; 0
     d34:	b0 e0       	ldi	r27, 0x00	; 0
     d36:	28 e1       	ldi	r18, 0x18	; 24
     d38:	31 e0       	ldi	r19, 0x01	; 1
     d3a:	40 e0       	ldi	r20, 0x00	; 0
     d3c:	50 e0       	ldi	r21, 0x00	; 0
     d3e:	bc 01       	movw	r22, r24
     d40:	cd 01       	movw	r24, r26
     d42:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <__mulsi3>
     d46:	dc 01       	movw	r26, r24
     d48:	cb 01       	movw	r24, r22
     d4a:	8a 83       	std	Y+2, r24	; 0x02
     d4c:	9b 83       	std	Y+3, r25	; 0x03
     d4e:	ac 83       	std	Y+4, r26	; 0x04
     d50:	bd 83       	std	Y+5, r27	; 0x05
    u8 Local_u8Index =0;
     d52:	19 82       	std	Y+1, r1	; 0x01
     d54:	35 c0       	rjmp	.+106    	; 0xdc0 <UART_enuTransmit+0xb4>
	while ((Local_u8Index < Copy_u8Size) && (Local_u32Timeout > 3))
	{
		while (!((UCSRA>>UDRE)&1) && (Local_u32Timeout-- > 3));
     d56:	eb e2       	ldi	r30, 0x2B	; 43
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	82 95       	swap	r24
     d5e:	86 95       	lsr	r24
     d60:	87 70       	andi	r24, 0x07	; 7
     d62:	88 2f       	mov	r24, r24
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	81 70       	andi	r24, 0x01	; 1
     d68:	90 70       	andi	r25, 0x00	; 0
     d6a:	00 97       	sbiw	r24, 0x00	; 0
     d6c:	d1 f4       	brne	.+52     	; 0xda2 <UART_enuTransmit+0x96>
     d6e:	1b 86       	std	Y+11, r1	; 0x0b
     d70:	8a 81       	ldd	r24, Y+2	; 0x02
     d72:	9b 81       	ldd	r25, Y+3	; 0x03
     d74:	ac 81       	ldd	r26, Y+4	; 0x04
     d76:	bd 81       	ldd	r27, Y+5	; 0x05
     d78:	84 30       	cpi	r24, 0x04	; 4
     d7a:	91 05       	cpc	r25, r1
     d7c:	a1 05       	cpc	r26, r1
     d7e:	b1 05       	cpc	r27, r1
     d80:	10 f0       	brcs	.+4      	; 0xd86 <UART_enuTransmit+0x7a>
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	8b 87       	std	Y+11, r24	; 0x0b
     d86:	8a 81       	ldd	r24, Y+2	; 0x02
     d88:	9b 81       	ldd	r25, Y+3	; 0x03
     d8a:	ac 81       	ldd	r26, Y+4	; 0x04
     d8c:	bd 81       	ldd	r27, Y+5	; 0x05
     d8e:	01 97       	sbiw	r24, 0x01	; 1
     d90:	a1 09       	sbc	r26, r1
     d92:	b1 09       	sbc	r27, r1
     d94:	8a 83       	std	Y+2, r24	; 0x02
     d96:	9b 83       	std	Y+3, r25	; 0x03
     d98:	ac 83       	std	Y+4, r26	; 0x04
     d9a:	bd 83       	std	Y+5, r27	; 0x05
     d9c:	8b 85       	ldd	r24, Y+11	; 0x0b
     d9e:	88 23       	and	r24, r24
     da0:	d1 f6       	brne	.-76     	; 0xd56 <UART_enuTransmit+0x4a>
		UDR = Copy_pu8Buffer[Local_u8Index++];
     da2:	ac e2       	ldi	r26, 0x2C	; 44
     da4:	b0 e0       	ldi	r27, 0x00	; 0
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	28 2f       	mov	r18, r24
     daa:	30 e0       	ldi	r19, 0x00	; 0
     dac:	8f 81       	ldd	r24, Y+7	; 0x07
     dae:	98 85       	ldd	r25, Y+8	; 0x08
     db0:	fc 01       	movw	r30, r24
     db2:	e2 0f       	add	r30, r18
     db4:	f3 1f       	adc	r31, r19
     db6:	80 81       	ld	r24, Z
     db8:	8c 93       	st	X, r24
     dba:	89 81       	ldd	r24, Y+1	; 0x01
     dbc:	8f 5f       	subi	r24, 0xFF	; 255
     dbe:	89 83       	std	Y+1, r24	; 0x01
ES_t UART_enuTransmit(u8 * Copy_pu8Buffer , u8 Copy_u8Size , u8 Copy_u8Timeout)
{
	ES_t Local_enuErrorState = ES_NOK;
    u32 Local_u32Timeout = Copy_u8Timeout * CLOCK_CYCLE_TO_MS;
    u8 Local_u8Index =0;
	while ((Local_u8Index < Copy_u8Size) && (Local_u32Timeout > 3))
     dc0:	99 81       	ldd	r25, Y+1	; 0x01
     dc2:	89 85       	ldd	r24, Y+9	; 0x09
     dc4:	98 17       	cp	r25, r24
     dc6:	50 f4       	brcc	.+20     	; 0xddc <UART_enuTransmit+0xd0>
     dc8:	8a 81       	ldd	r24, Y+2	; 0x02
     dca:	9b 81       	ldd	r25, Y+3	; 0x03
     dcc:	ac 81       	ldd	r26, Y+4	; 0x04
     dce:	bd 81       	ldd	r27, Y+5	; 0x05
     dd0:	84 30       	cpi	r24, 0x04	; 4
     dd2:	91 05       	cpc	r25, r1
     dd4:	a1 05       	cpc	r26, r1
     dd6:	b1 05       	cpc	r27, r1
     dd8:	08 f0       	brcs	.+2      	; 0xddc <UART_enuTransmit+0xd0>
     dda:	bd cf       	rjmp	.-134    	; 0xd56 <UART_enuTransmit+0x4a>
	{
		while (!((UCSRA>>UDRE)&1) && (Local_u32Timeout-- > 3));
		UDR = Copy_pu8Buffer[Local_u8Index++];
	}

	return Local_enuErrorState;
     ddc:	8e 81       	ldd	r24, Y+6	; 0x06
}
     dde:	2b 96       	adiw	r28, 0x0b	; 11
     de0:	0f b6       	in	r0, 0x3f	; 63
     de2:	f8 94       	cli
     de4:	de bf       	out	0x3e, r29	; 62
     de6:	0f be       	out	0x3f, r0	; 63
     de8:	cd bf       	out	0x3d, r28	; 61
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	08 95       	ret

00000df0 <UART_enuSendChar>:

ES_t UART_enuSendChar(u8 Copy_u8Data)
{
     df0:	df 93       	push	r29
     df2:	cf 93       	push	r28
     df4:	00 d0       	rcall	.+0      	; 0xdf6 <UART_enuSendChar+0x6>
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	89 83       	std	Y+1, r24	; 0x01

	while (!((UCSRA>>UDRE)&1));
     e00:	eb e2       	ldi	r30, 0x2B	; 43
     e02:	f0 e0       	ldi	r31, 0x00	; 0
     e04:	80 81       	ld	r24, Z
     e06:	82 95       	swap	r24
     e08:	86 95       	lsr	r24
     e0a:	87 70       	andi	r24, 0x07	; 7
     e0c:	88 2f       	mov	r24, r24
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	81 70       	andi	r24, 0x01	; 1
     e12:	90 70       	andi	r25, 0x00	; 0
     e14:	00 97       	sbiw	r24, 0x00	; 0
     e16:	a1 f3       	breq	.-24     	; 0xe00 <UART_enuSendChar+0x10>
	UDR = Copy_u8Data;
     e18:	ec e2       	ldi	r30, 0x2C	; 44
     e1a:	f0 e0       	ldi	r31, 0x00	; 0
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	80 83       	st	Z, r24
	/*
	 * UDR = Copy_u8Data;
	 * while( ! ((UCSRA>>TXC) & 1 ) );
	 * UCSRA |= (1<<TXC);
	 */
	return Local_enuErrorState;
     e20:	89 81       	ldd	r24, Y+1	; 0x01
}
     e22:	0f 90       	pop	r0
     e24:	0f 90       	pop	r0
     e26:	cf 91       	pop	r28
     e28:	df 91       	pop	r29
     e2a:	08 95       	ret

00000e2c <UART_enuRecieveChar>:

ES_t UART_enuRecieveChar(u8 *Copy_pu8Data)
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	00 d0       	rcall	.+0      	; 0xe32 <UART_enuRecieveChar+0x6>
     e32:	0f 92       	push	r0
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	9b 83       	std	Y+3, r25	; 0x03
     e3a:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
     e3c:	81 e0       	ldi	r24, 0x01	; 1
     e3e:	89 83       	std	Y+1, r24	; 0x01

	while (!((UCSRA>>RXC)&1));
     e40:	eb e2       	ldi	r30, 0x2B	; 43
     e42:	f0 e0       	ldi	r31, 0x00	; 0
     e44:	80 81       	ld	r24, Z
     e46:	88 23       	and	r24, r24
     e48:	dc f7       	brge	.-10     	; 0xe40 <UART_enuRecieveChar+0x14>
	*Copy_pu8Data = UDR;
     e4a:	ec e2       	ldi	r30, 0x2C	; 44
     e4c:	f0 e0       	ldi	r31, 0x00	; 0
     e4e:	80 81       	ld	r24, Z
     e50:	ea 81       	ldd	r30, Y+2	; 0x02
     e52:	fb 81       	ldd	r31, Y+3	; 0x03
     e54:	80 83       	st	Z, r24

	return Local_enuErrorState;
     e56:	89 81       	ldd	r24, Y+1	; 0x01
}
     e58:	0f 90       	pop	r0
     e5a:	0f 90       	pop	r0
     e5c:	0f 90       	pop	r0
     e5e:	cf 91       	pop	r28
     e60:	df 91       	pop	r29
     e62:	08 95       	ret

00000e64 <UART_enuSendString>:

ES_t UART_enuSendString(const char* Copy_pcData)
{
     e64:	df 93       	push	r29
     e66:	cf 93       	push	r28
     e68:	00 d0       	rcall	.+0      	; 0xe6a <UART_enuSendString+0x6>
     e6a:	0f 92       	push	r0
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	9b 83       	std	Y+3, r25	; 0x03
     e72:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
     e74:	81 e0       	ldi	r24, 0x01	; 1
     e76:	89 83       	std	Y+1, r24	; 0x01
     e78:	17 c0       	rjmp	.+46     	; 0xea8 <UART_enuSendString+0x44>

	while (*Copy_pcData != '\0')
	{
		while (!((UCSRA>>UDRE)&1));
     e7a:	eb e2       	ldi	r30, 0x2B	; 43
     e7c:	f0 e0       	ldi	r31, 0x00	; 0
     e7e:	80 81       	ld	r24, Z
     e80:	82 95       	swap	r24
     e82:	86 95       	lsr	r24
     e84:	87 70       	andi	r24, 0x07	; 7
     e86:	88 2f       	mov	r24, r24
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	81 70       	andi	r24, 0x01	; 1
     e8c:	90 70       	andi	r25, 0x00	; 0
     e8e:	00 97       	sbiw	r24, 0x00	; 0
     e90:	a1 f3       	breq	.-24     	; 0xe7a <UART_enuSendString+0x16>
		UDR = *Copy_pcData;
     e92:	ac e2       	ldi	r26, 0x2C	; 44
     e94:	b0 e0       	ldi	r27, 0x00	; 0
     e96:	ea 81       	ldd	r30, Y+2	; 0x02
     e98:	fb 81       	ldd	r31, Y+3	; 0x03
     e9a:	80 81       	ld	r24, Z
     e9c:	8c 93       	st	X, r24
		Copy_pcData++;
     e9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ea0:	9b 81       	ldd	r25, Y+3	; 0x03
     ea2:	01 96       	adiw	r24, 0x01	; 1
     ea4:	9b 83       	std	Y+3, r25	; 0x03
     ea6:	8a 83       	std	Y+2, r24	; 0x02

ES_t UART_enuSendString(const char* Copy_pcData)
{
	ES_t Local_enuErrorState = ES_NOK;

	while (*Copy_pcData != '\0')
     ea8:	ea 81       	ldd	r30, Y+2	; 0x02
     eaa:	fb 81       	ldd	r31, Y+3	; 0x03
     eac:	80 81       	ld	r24, Z
     eae:	88 23       	and	r24, r24
     eb0:	21 f7       	brne	.-56     	; 0xe7a <UART_enuSendString+0x16>
		while (!((UCSRA>>UDRE)&1));
		UDR = *Copy_pcData;
		Copy_pcData++;
	}

	return Local_enuErrorState;
     eb2:	89 81       	ldd	r24, Y+1	; 0x01
}
     eb4:	0f 90       	pop	r0
     eb6:	0f 90       	pop	r0
     eb8:	0f 90       	pop	r0
     eba:	cf 91       	pop	r28
     ebc:	df 91       	pop	r29
     ebe:	08 95       	ret

00000ec0 <UART_enuRecieveString>:


ES_t UART_enuRecieveString(char * Copy_pcData)
{
     ec0:	df 93       	push	r29
     ec2:	cf 93       	push	r28
     ec4:	00 d0       	rcall	.+0      	; 0xec6 <UART_enuRecieveString+0x6>
     ec6:	00 d0       	rcall	.+0      	; 0xec8 <UART_enuRecieveString+0x8>
     ec8:	0f 92       	push	r0
     eca:	cd b7       	in	r28, 0x3d	; 61
     ecc:	de b7       	in	r29, 0x3e	; 62
     ece:	9d 83       	std	Y+5, r25	; 0x05
     ed0:	8c 83       	std	Y+4, r24	; 0x04
	ES_t Local_enuErrorState = ES_NOK;
     ed2:	81 e0       	ldi	r24, 0x01	; 1
     ed4:	8b 83       	std	Y+3, r24	; 0x03

	u8 Local_u8Data=0 , Local_u8Index=0;
     ed6:	1a 82       	std	Y+2, r1	; 0x02
     ed8:	19 82       	std	Y+1, r1	; 0x01

	while (1)
	{
		while (!((UCSRA>>RXC)&1));
     eda:	eb e2       	ldi	r30, 0x2B	; 43
     edc:	f0 e0       	ldi	r31, 0x00	; 0
     ede:	80 81       	ld	r24, Z
     ee0:	88 23       	and	r24, r24
     ee2:	dc f7       	brge	.-10     	; 0xeda <UART_enuRecieveString+0x1a>
		Local_u8Data = UDR;
     ee4:	ec e2       	ldi	r30, 0x2C	; 44
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	80 81       	ld	r24, Z
     eea:	8a 83       	std	Y+2, r24	; 0x02

		if (Local_u8Data == '\r' || Local_u8Data == '\n' || Local_u8Data == '\0')
     eec:	8a 81       	ldd	r24, Y+2	; 0x02
     eee:	8d 30       	cpi	r24, 0x0D	; 13
     ef0:	31 f0       	breq	.+12     	; 0xefe <UART_enuRecieveString+0x3e>
     ef2:	8a 81       	ldd	r24, Y+2	; 0x02
     ef4:	8a 30       	cpi	r24, 0x0A	; 10
     ef6:	19 f0       	breq	.+6      	; 0xefe <UART_enuRecieveString+0x3e>
     ef8:	8a 81       	ldd	r24, Y+2	; 0x02
     efa:	88 23       	and	r24, r24
     efc:	91 f4       	brne	.+36     	; 0xf22 <UART_enuRecieveString+0x62>
		{
			Copy_pcData[Local_u8Index]='\0';
     efe:	89 81       	ldd	r24, Y+1	; 0x01
     f00:	28 2f       	mov	r18, r24
     f02:	30 e0       	ldi	r19, 0x00	; 0
     f04:	8c 81       	ldd	r24, Y+4	; 0x04
     f06:	9d 81       	ldd	r25, Y+5	; 0x05
     f08:	fc 01       	movw	r30, r24
     f0a:	e2 0f       	add	r30, r18
     f0c:	f3 1f       	adc	r31, r19
     f0e:	10 82       	st	Z, r1
		Copy_pcData[Local_u8Index]=Local_u8Data;
		Local_u8Index++;
	}


	return Local_enuErrorState;
     f10:	8b 81       	ldd	r24, Y+3	; 0x03
}
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	0f 90       	pop	r0
     f1c:	cf 91       	pop	r28
     f1e:	df 91       	pop	r29
     f20:	08 95       	ret
		if (Local_u8Data == '\r' || Local_u8Data == '\n' || Local_u8Data == '\0')
		{
			Copy_pcData[Local_u8Index]='\0';
			break;
		}
		Copy_pcData[Local_u8Index]=Local_u8Data;
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	28 2f       	mov	r18, r24
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	8c 81       	ldd	r24, Y+4	; 0x04
     f2a:	9d 81       	ldd	r25, Y+5	; 0x05
     f2c:	fc 01       	movw	r30, r24
     f2e:	e2 0f       	add	r30, r18
     f30:	f3 1f       	adc	r31, r19
     f32:	8a 81       	ldd	r24, Y+2	; 0x02
     f34:	80 83       	st	Z, r24
		Local_u8Index++;
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	8f 5f       	subi	r24, 0xFF	; 255
     f3a:	89 83       	std	Y+1, r24	; 0x01
     f3c:	ce cf       	rjmp	.-100    	; 0xeda <UART_enuRecieveString+0x1a>

00000f3e <DIO_enuInit>:
#include "DIO_config.h"
#include "DIO_priv.h"


ES_t DIO_enuInit(void)
{
     f3e:	df 93       	push	r29
     f40:	cf 93       	push	r28
     f42:	0f 92       	push	r0
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
    ES_t Local_enuErrorState = ES_NOK;
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	89 83       	std	Y+1, r24	; 0x01

//10111010
//    DDRA = DIO_CONC(DIO_PA7_DIR , DIO_PA6_DIR , DIO_PA5_DIR , DIO_PA4_DIR , DIO_PA3_DIR, DIO_PA2_DIR, DIO_PA1_DIR,DIO_PA0_DIR);

    return Local_enuErrorState;
     f4c:	89 81       	ldd	r24, Y+1	; 0x01
}
     f4e:	0f 90       	pop	r0
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <DIO_enuSetPinDirection>:

ES_t DIO_enuSetPinDirection(u8 Copy_u8GroupID , u8 Copy_u8PinID , u8 Copy_u8Direction)
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	00 d0       	rcall	.+0      	; 0xf5c <DIO_enuSetPinDirection+0x6>
     f5c:	00 d0       	rcall	.+0      	; 0xf5e <DIO_enuSetPinDirection+0x8>
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <DIO_enuSetPinDirection+0xa>
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	8a 83       	std	Y+2, r24	; 0x02
     f66:	6b 83       	std	Y+3, r22	; 0x03
     f68:	4c 83       	std	Y+4, r20	; 0x04
    ES_t Local_enuErrorState = ES_NOK;
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	89 83       	std	Y+1, r24	; 0x01

    if ((Copy_u8GroupID <= DIO_GROUP_D) && (Copy_u8PinID <= DIO_PIN_7)
     f6e:	8a 81       	ldd	r24, Y+2	; 0x02
     f70:	84 30       	cpi	r24, 0x04	; 4
     f72:	08 f0       	brcs	.+2      	; 0xf76 <DIO_enuSetPinDirection+0x20>
     f74:	d0 c0       	rjmp	.+416    	; 0x1116 <DIO_enuSetPinDirection+0x1c0>
     f76:	8b 81       	ldd	r24, Y+3	; 0x03
     f78:	88 30       	cpi	r24, 0x08	; 8
     f7a:	08 f0       	brcs	.+2      	; 0xf7e <DIO_enuSetPinDirection+0x28>
     f7c:	cc c0       	rjmp	.+408    	; 0x1116 <DIO_enuSetPinDirection+0x1c0>
     f7e:	8c 81       	ldd	r24, Y+4	; 0x04
     f80:	82 30       	cpi	r24, 0x02	; 2
     f82:	08 f0       	brcs	.+2      	; 0xf86 <DIO_enuSetPinDirection+0x30>
     f84:	c8 c0       	rjmp	.+400    	; 0x1116 <DIO_enuSetPinDirection+0x1c0>
            && (Copy_u8Direction <= DIO_OUTPUT))
    {
        switch(Copy_u8GroupID)
     f86:	8a 81       	ldd	r24, Y+2	; 0x02
     f88:	28 2f       	mov	r18, r24
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	3e 83       	std	Y+6, r19	; 0x06
     f8e:	2d 83       	std	Y+5, r18	; 0x05
     f90:	6d 81       	ldd	r22, Y+5	; 0x05
     f92:	7e 81       	ldd	r23, Y+6	; 0x06
     f94:	61 30       	cpi	r22, 0x01	; 1
     f96:	71 05       	cpc	r23, r1
     f98:	09 f4       	brne	.+2      	; 0xf9c <DIO_enuSetPinDirection+0x46>
     f9a:	41 c0       	rjmp	.+130    	; 0x101e <DIO_enuSetPinDirection+0xc8>
     f9c:	8d 81       	ldd	r24, Y+5	; 0x05
     f9e:	9e 81       	ldd	r25, Y+6	; 0x06
     fa0:	82 30       	cpi	r24, 0x02	; 2
     fa2:	91 05       	cpc	r25, r1
     fa4:	34 f4       	brge	.+12     	; 0xfb2 <DIO_enuSetPinDirection+0x5c>
     fa6:	2d 81       	ldd	r18, Y+5	; 0x05
     fa8:	3e 81       	ldd	r19, Y+6	; 0x06
     faa:	21 15       	cp	r18, r1
     fac:	31 05       	cpc	r19, r1
     fae:	71 f0       	breq	.+28     	; 0xfcc <DIO_enuSetPinDirection+0x76>
     fb0:	b0 c0       	rjmp	.+352    	; 0x1112 <DIO_enuSetPinDirection+0x1bc>
     fb2:	6d 81       	ldd	r22, Y+5	; 0x05
     fb4:	7e 81       	ldd	r23, Y+6	; 0x06
     fb6:	62 30       	cpi	r22, 0x02	; 2
     fb8:	71 05       	cpc	r23, r1
     fba:	09 f4       	brne	.+2      	; 0xfbe <DIO_enuSetPinDirection+0x68>
     fbc:	59 c0       	rjmp	.+178    	; 0x1070 <DIO_enuSetPinDirection+0x11a>
     fbe:	8d 81       	ldd	r24, Y+5	; 0x05
     fc0:	9e 81       	ldd	r25, Y+6	; 0x06
     fc2:	83 30       	cpi	r24, 0x03	; 3
     fc4:	91 05       	cpc	r25, r1
     fc6:	09 f4       	brne	.+2      	; 0xfca <DIO_enuSetPinDirection+0x74>
     fc8:	7c c0       	rjmp	.+248    	; 0x10c2 <DIO_enuSetPinDirection+0x16c>
     fca:	a3 c0       	rjmp	.+326    	; 0x1112 <DIO_enuSetPinDirection+0x1bc>
        {
            case DIO_GROUP_A:
                DDRA &= ~(DIO_MASK_BIT << Copy_u8PinID);
     fcc:	aa e3       	ldi	r26, 0x3A	; 58
     fce:	b0 e0       	ldi	r27, 0x00	; 0
     fd0:	ea e3       	ldi	r30, 0x3A	; 58
     fd2:	f0 e0       	ldi	r31, 0x00	; 0
     fd4:	80 81       	ld	r24, Z
     fd6:	48 2f       	mov	r20, r24
     fd8:	8b 81       	ldd	r24, Y+3	; 0x03
     fda:	28 2f       	mov	r18, r24
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	02 c0       	rjmp	.+4      	; 0xfe8 <DIO_enuSetPinDirection+0x92>
     fe4:	88 0f       	add	r24, r24
     fe6:	99 1f       	adc	r25, r25
     fe8:	2a 95       	dec	r18
     fea:	e2 f7       	brpl	.-8      	; 0xfe4 <DIO_enuSetPinDirection+0x8e>
     fec:	80 95       	com	r24
     fee:	84 23       	and	r24, r20
     ff0:	8c 93       	st	X, r24
                DDRA |=  (Copy_u8Direction << Copy_u8PinID);
     ff2:	aa e3       	ldi	r26, 0x3A	; 58
     ff4:	b0 e0       	ldi	r27, 0x00	; 0
     ff6:	ea e3       	ldi	r30, 0x3A	; 58
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	80 81       	ld	r24, Z
     ffc:	48 2f       	mov	r20, r24
     ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    1000:	28 2f       	mov	r18, r24
    1002:	30 e0       	ldi	r19, 0x00	; 0
    1004:	8b 81       	ldd	r24, Y+3	; 0x03
    1006:	88 2f       	mov	r24, r24
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	b9 01       	movw	r22, r18
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <DIO_enuSetPinDirection+0xbc>
    100e:	66 0f       	add	r22, r22
    1010:	77 1f       	adc	r23, r23
    1012:	8a 95       	dec	r24
    1014:	e2 f7       	brpl	.-8      	; 0x100e <DIO_enuSetPinDirection+0xb8>
    1016:	cb 01       	movw	r24, r22
    1018:	84 2b       	or	r24, r20
    101a:	8c 93       	st	X, r24
    101c:	7a c0       	rjmp	.+244    	; 0x1112 <DIO_enuSetPinDirection+0x1bc>
            break;

            case DIO_GROUP_B:
                DDRB &= ~(DIO_MASK_BIT << Copy_u8PinID);
    101e:	a7 e3       	ldi	r26, 0x37	; 55
    1020:	b0 e0       	ldi	r27, 0x00	; 0
    1022:	e7 e3       	ldi	r30, 0x37	; 55
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	80 81       	ld	r24, Z
    1028:	48 2f       	mov	r20, r24
    102a:	8b 81       	ldd	r24, Y+3	; 0x03
    102c:	28 2f       	mov	r18, r24
    102e:	30 e0       	ldi	r19, 0x00	; 0
    1030:	81 e0       	ldi	r24, 0x01	; 1
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	02 c0       	rjmp	.+4      	; 0x103a <DIO_enuSetPinDirection+0xe4>
    1036:	88 0f       	add	r24, r24
    1038:	99 1f       	adc	r25, r25
    103a:	2a 95       	dec	r18
    103c:	e2 f7       	brpl	.-8      	; 0x1036 <DIO_enuSetPinDirection+0xe0>
    103e:	80 95       	com	r24
    1040:	84 23       	and	r24, r20
    1042:	8c 93       	st	X, r24
                DDRB |=  (Copy_u8Direction << Copy_u8PinID);
    1044:	a7 e3       	ldi	r26, 0x37	; 55
    1046:	b0 e0       	ldi	r27, 0x00	; 0
    1048:	e7 e3       	ldi	r30, 0x37	; 55
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	80 81       	ld	r24, Z
    104e:	48 2f       	mov	r20, r24
    1050:	8c 81       	ldd	r24, Y+4	; 0x04
    1052:	28 2f       	mov	r18, r24
    1054:	30 e0       	ldi	r19, 0x00	; 0
    1056:	8b 81       	ldd	r24, Y+3	; 0x03
    1058:	88 2f       	mov	r24, r24
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	b9 01       	movw	r22, r18
    105e:	02 c0       	rjmp	.+4      	; 0x1064 <DIO_enuSetPinDirection+0x10e>
    1060:	66 0f       	add	r22, r22
    1062:	77 1f       	adc	r23, r23
    1064:	8a 95       	dec	r24
    1066:	e2 f7       	brpl	.-8      	; 0x1060 <DIO_enuSetPinDirection+0x10a>
    1068:	cb 01       	movw	r24, r22
    106a:	84 2b       	or	r24, r20
    106c:	8c 93       	st	X, r24
    106e:	51 c0       	rjmp	.+162    	; 0x1112 <DIO_enuSetPinDirection+0x1bc>
            break;

            case DIO_GROUP_C:
                DDRC &= ~(DIO_MASK_BIT << Copy_u8PinID);
    1070:	a4 e3       	ldi	r26, 0x34	; 52
    1072:	b0 e0       	ldi	r27, 0x00	; 0
    1074:	e4 e3       	ldi	r30, 0x34	; 52
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	80 81       	ld	r24, Z
    107a:	48 2f       	mov	r20, r24
    107c:	8b 81       	ldd	r24, Y+3	; 0x03
    107e:	28 2f       	mov	r18, r24
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	90 e0       	ldi	r25, 0x00	; 0
    1086:	02 c0       	rjmp	.+4      	; 0x108c <DIO_enuSetPinDirection+0x136>
    1088:	88 0f       	add	r24, r24
    108a:	99 1f       	adc	r25, r25
    108c:	2a 95       	dec	r18
    108e:	e2 f7       	brpl	.-8      	; 0x1088 <DIO_enuSetPinDirection+0x132>
    1090:	80 95       	com	r24
    1092:	84 23       	and	r24, r20
    1094:	8c 93       	st	X, r24
                DDRC |=  (Copy_u8Direction << Copy_u8PinID);
    1096:	a4 e3       	ldi	r26, 0x34	; 52
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	e4 e3       	ldi	r30, 0x34	; 52
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	80 81       	ld	r24, Z
    10a0:	48 2f       	mov	r20, r24
    10a2:	8c 81       	ldd	r24, Y+4	; 0x04
    10a4:	28 2f       	mov	r18, r24
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	88 2f       	mov	r24, r24
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	b9 01       	movw	r22, r18
    10b0:	02 c0       	rjmp	.+4      	; 0x10b6 <DIO_enuSetPinDirection+0x160>
    10b2:	66 0f       	add	r22, r22
    10b4:	77 1f       	adc	r23, r23
    10b6:	8a 95       	dec	r24
    10b8:	e2 f7       	brpl	.-8      	; 0x10b2 <DIO_enuSetPinDirection+0x15c>
    10ba:	cb 01       	movw	r24, r22
    10bc:	84 2b       	or	r24, r20
    10be:	8c 93       	st	X, r24
    10c0:	28 c0       	rjmp	.+80     	; 0x1112 <DIO_enuSetPinDirection+0x1bc>
            break;
            
            case DIO_GROUP_D:
                DDRD &= ~(DIO_MASK_BIT << Copy_u8PinID);
    10c2:	a1 e3       	ldi	r26, 0x31	; 49
    10c4:	b0 e0       	ldi	r27, 0x00	; 0
    10c6:	e1 e3       	ldi	r30, 0x31	; 49
    10c8:	f0 e0       	ldi	r31, 0x00	; 0
    10ca:	80 81       	ld	r24, Z
    10cc:	48 2f       	mov	r20, r24
    10ce:	8b 81       	ldd	r24, Y+3	; 0x03
    10d0:	28 2f       	mov	r18, r24
    10d2:	30 e0       	ldi	r19, 0x00	; 0
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	02 c0       	rjmp	.+4      	; 0x10de <DIO_enuSetPinDirection+0x188>
    10da:	88 0f       	add	r24, r24
    10dc:	99 1f       	adc	r25, r25
    10de:	2a 95       	dec	r18
    10e0:	e2 f7       	brpl	.-8      	; 0x10da <DIO_enuSetPinDirection+0x184>
    10e2:	80 95       	com	r24
    10e4:	84 23       	and	r24, r20
    10e6:	8c 93       	st	X, r24
                DDRD |=  (Copy_u8Direction << Copy_u8PinID);
    10e8:	a1 e3       	ldi	r26, 0x31	; 49
    10ea:	b0 e0       	ldi	r27, 0x00	; 0
    10ec:	e1 e3       	ldi	r30, 0x31	; 49
    10ee:	f0 e0       	ldi	r31, 0x00	; 0
    10f0:	80 81       	ld	r24, Z
    10f2:	48 2f       	mov	r20, r24
    10f4:	8c 81       	ldd	r24, Y+4	; 0x04
    10f6:	28 2f       	mov	r18, r24
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	8b 81       	ldd	r24, Y+3	; 0x03
    10fc:	88 2f       	mov	r24, r24
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	b9 01       	movw	r22, r18
    1102:	02 c0       	rjmp	.+4      	; 0x1108 <DIO_enuSetPinDirection+0x1b2>
    1104:	66 0f       	add	r22, r22
    1106:	77 1f       	adc	r23, r23
    1108:	8a 95       	dec	r24
    110a:	e2 f7       	brpl	.-8      	; 0x1104 <DIO_enuSetPinDirection+0x1ae>
    110c:	cb 01       	movw	r24, r22
    110e:	84 2b       	or	r24, r20
    1110:	8c 93       	st	X, r24
            break;

            default:
            break;
        }
        Local_enuErrorState = ES_OK;
    1112:	19 82       	std	Y+1, r1	; 0x01
    1114:	02 c0       	rjmp	.+4      	; 0x111a <DIO_enuSetPinDirection+0x1c4>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    1116:	82 e0       	ldi	r24, 0x02	; 2
    1118:	89 83       	std	Y+1, r24	; 0x01
    }

    return Local_enuErrorState;
    111a:	89 81       	ldd	r24, Y+1	; 0x01
}
    111c:	26 96       	adiw	r28, 0x06	; 6
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	de bf       	out	0x3e, r29	; 62
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	cd bf       	out	0x3d, r28	; 61
    1128:	cf 91       	pop	r28
    112a:	df 91       	pop	r29
    112c:	08 95       	ret

0000112e <DIO_enuSetPinValue>:

ES_t DIO_enuSetPinValue(u8 Copy_u8GroupID , u8 Copy_u8PinID , u8 Copy_u8Value)
{
    112e:	df 93       	push	r29
    1130:	cf 93       	push	r28
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
    1136:	29 97       	sbiw	r28, 0x09	; 9
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	de bf       	out	0x3e, r29	; 62
    113e:	0f be       	out	0x3f, r0	; 63
    1140:	cd bf       	out	0x3d, r28	; 61
    1142:	8a 83       	std	Y+2, r24	; 0x02
    1144:	6b 83       	std	Y+3, r22	; 0x03
    1146:	4c 83       	std	Y+4, r20	; 0x04
    ES_t Local_enuErrorState = ES_NOK;
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	89 83       	std	Y+1, r24	; 0x01

        if ((Copy_u8GroupID <= DIO_GROUP_D) && (Copy_u8PinID <= DIO_PIN_7)
    114c:	8a 81       	ldd	r24, Y+2	; 0x02
    114e:	84 30       	cpi	r24, 0x04	; 4
    1150:	08 f0       	brcs	.+2      	; 0x1154 <DIO_enuSetPinValue+0x26>
    1152:	df c0       	rjmp	.+446    	; 0x1312 <DIO_enuSetPinValue+0x1e4>
    1154:	8b 81       	ldd	r24, Y+3	; 0x03
    1156:	88 30       	cpi	r24, 0x08	; 8
    1158:	08 f0       	brcs	.+2      	; 0x115c <DIO_enuSetPinValue+0x2e>
    115a:	db c0       	rjmp	.+438    	; 0x1312 <DIO_enuSetPinValue+0x1e4>
    115c:	8c 81       	ldd	r24, Y+4	; 0x04
    115e:	82 30       	cpi	r24, 0x02	; 2
    1160:	08 f0       	brcs	.+2      	; 0x1164 <DIO_enuSetPinValue+0x36>
    1162:	d7 c0       	rjmp	.+430    	; 0x1312 <DIO_enuSetPinValue+0x1e4>
            && (Copy_u8Value <= DIO_HIGH))
    {
        switch(Copy_u8GroupID)
    1164:	8a 81       	ldd	r24, Y+2	; 0x02
    1166:	28 2f       	mov	r18, r24
    1168:	30 e0       	ldi	r19, 0x00	; 0
    116a:	39 87       	std	Y+9, r19	; 0x09
    116c:	28 87       	std	Y+8, r18	; 0x08
    116e:	88 85       	ldd	r24, Y+8	; 0x08
    1170:	99 85       	ldd	r25, Y+9	; 0x09
    1172:	81 30       	cpi	r24, 0x01	; 1
    1174:	91 05       	cpc	r25, r1
    1176:	09 f4       	brne	.+2      	; 0x117a <DIO_enuSetPinValue+0x4c>
    1178:	44 c0       	rjmp	.+136    	; 0x1202 <DIO_enuSetPinValue+0xd4>
    117a:	e8 85       	ldd	r30, Y+8	; 0x08
    117c:	f9 85       	ldd	r31, Y+9	; 0x09
    117e:	e2 30       	cpi	r30, 0x02	; 2
    1180:	f1 05       	cpc	r31, r1
    1182:	34 f4       	brge	.+12     	; 0x1190 <DIO_enuSetPinValue+0x62>
    1184:	28 85       	ldd	r18, Y+8	; 0x08
    1186:	39 85       	ldd	r19, Y+9	; 0x09
    1188:	21 15       	cp	r18, r1
    118a:	31 05       	cpc	r19, r1
    118c:	71 f0       	breq	.+28     	; 0x11aa <DIO_enuSetPinValue+0x7c>
    118e:	bf c0       	rjmp	.+382    	; 0x130e <DIO_enuSetPinValue+0x1e0>
    1190:	88 85       	ldd	r24, Y+8	; 0x08
    1192:	99 85       	ldd	r25, Y+9	; 0x09
    1194:	82 30       	cpi	r24, 0x02	; 2
    1196:	91 05       	cpc	r25, r1
    1198:	09 f4       	brne	.+2      	; 0x119c <DIO_enuSetPinValue+0x6e>
    119a:	62 c0       	rjmp	.+196    	; 0x1260 <DIO_enuSetPinValue+0x132>
    119c:	e8 85       	ldd	r30, Y+8	; 0x08
    119e:	f9 85       	ldd	r31, Y+9	; 0x09
    11a0:	e3 30       	cpi	r30, 0x03	; 3
    11a2:	f1 05       	cpc	r31, r1
    11a4:	09 f4       	brne	.+2      	; 0x11a8 <DIO_enuSetPinValue+0x7a>
    11a6:	88 c0       	rjmp	.+272    	; 0x12b8 <DIO_enuSetPinValue+0x18a>
    11a8:	b2 c0       	rjmp	.+356    	; 0x130e <DIO_enuSetPinValue+0x1e0>
        {
            case DIO_GROUP_A:
                if(Copy_u8Value == DIO_HIGH)
    11aa:	8c 81       	ldd	r24, Y+4	; 0x04
    11ac:	81 30       	cpi	r24, 0x01	; 1
    11ae:	a1 f4       	brne	.+40     	; 0x11d8 <DIO_enuSetPinValue+0xaa>
                {
                    PORTA |=  (DIO_MASK_BIT << Copy_u8PinID);
    11b0:	ab e3       	ldi	r26, 0x3B	; 59
    11b2:	b0 e0       	ldi	r27, 0x00	; 0
    11b4:	eb e3       	ldi	r30, 0x3B	; 59
    11b6:	f0 e0       	ldi	r31, 0x00	; 0
    11b8:	80 81       	ld	r24, Z
    11ba:	48 2f       	mov	r20, r24
    11bc:	8b 81       	ldd	r24, Y+3	; 0x03
    11be:	28 2f       	mov	r18, r24
    11c0:	30 e0       	ldi	r19, 0x00	; 0
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	02 2e       	mov	r0, r18
    11c8:	02 c0       	rjmp	.+4      	; 0x11ce <DIO_enuSetPinValue+0xa0>
    11ca:	88 0f       	add	r24, r24
    11cc:	99 1f       	adc	r25, r25
    11ce:	0a 94       	dec	r0
    11d0:	e2 f7       	brpl	.-8      	; 0x11ca <DIO_enuSetPinValue+0x9c>
    11d2:	84 2b       	or	r24, r20
    11d4:	8c 93       	st	X, r24
    11d6:	9b c0       	rjmp	.+310    	; 0x130e <DIO_enuSetPinValue+0x1e0>
//							:"I" (Copy_u8PinID)
//							);
                }
                else
                {
                    PORTA &= ~(DIO_MASK_BIT << Copy_u8PinID);
    11d8:	ab e3       	ldi	r26, 0x3B	; 59
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	eb e3       	ldi	r30, 0x3B	; 59
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	48 2f       	mov	r20, r24
    11e4:	8b 81       	ldd	r24, Y+3	; 0x03
    11e6:	28 2f       	mov	r18, r24
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	02 2e       	mov	r0, r18
    11f0:	02 c0       	rjmp	.+4      	; 0x11f6 <DIO_enuSetPinValue+0xc8>
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	0a 94       	dec	r0
    11f8:	e2 f7       	brpl	.-8      	; 0x11f2 <DIO_enuSetPinValue+0xc4>
    11fa:	80 95       	com	r24
    11fc:	84 23       	and	r24, r20
    11fe:	8c 93       	st	X, r24
    1200:	86 c0       	rjmp	.+268    	; 0x130e <DIO_enuSetPinValue+0x1e0>
                }
            break;

            case DIO_GROUP_B:
                PORTB = (Copy_u8Value == DIO_HIGH)? (PORTB | (DIO_MASK_BIT<<Copy_u8PinID)) : (PORTB &  (~(DIO_MASK_BIT<<Copy_u8PinID)));
    1202:	28 e3       	ldi	r18, 0x38	; 56
    1204:	30 e0       	ldi	r19, 0x00	; 0
    1206:	3f 83       	std	Y+7, r19	; 0x07
    1208:	2e 83       	std	Y+6, r18	; 0x06
    120a:	8c 81       	ldd	r24, Y+4	; 0x04
    120c:	81 30       	cpi	r24, 0x01	; 1
    120e:	91 f4       	brne	.+36     	; 0x1234 <DIO_enuSetPinValue+0x106>
    1210:	e8 e3       	ldi	r30, 0x38	; 56
    1212:	f0 e0       	ldi	r31, 0x00	; 0
    1214:	80 81       	ld	r24, Z
    1216:	48 2f       	mov	r20, r24
    1218:	8b 81       	ldd	r24, Y+3	; 0x03
    121a:	28 2f       	mov	r18, r24
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	02 2e       	mov	r0, r18
    1224:	02 c0       	rjmp	.+4      	; 0x122a <DIO_enuSetPinValue+0xfc>
    1226:	88 0f       	add	r24, r24
    1228:	99 1f       	adc	r25, r25
    122a:	0a 94       	dec	r0
    122c:	e2 f7       	brpl	.-8      	; 0x1226 <DIO_enuSetPinValue+0xf8>
    122e:	84 2b       	or	r24, r20
    1230:	8d 83       	std	Y+5, r24	; 0x05
    1232:	11 c0       	rjmp	.+34     	; 0x1256 <DIO_enuSetPinValue+0x128>
    1234:	e8 e3       	ldi	r30, 0x38	; 56
    1236:	f0 e0       	ldi	r31, 0x00	; 0
    1238:	80 81       	ld	r24, Z
    123a:	48 2f       	mov	r20, r24
    123c:	8b 81       	ldd	r24, Y+3	; 0x03
    123e:	28 2f       	mov	r18, r24
    1240:	30 e0       	ldi	r19, 0x00	; 0
    1242:	81 e0       	ldi	r24, 0x01	; 1
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	02 c0       	rjmp	.+4      	; 0x124c <DIO_enuSetPinValue+0x11e>
    1248:	88 0f       	add	r24, r24
    124a:	99 1f       	adc	r25, r25
    124c:	2a 95       	dec	r18
    124e:	e2 f7       	brpl	.-8      	; 0x1248 <DIO_enuSetPinValue+0x11a>
    1250:	80 95       	com	r24
    1252:	84 23       	and	r24, r20
    1254:	8d 83       	std	Y+5, r24	; 0x05
    1256:	2d 81       	ldd	r18, Y+5	; 0x05
    1258:	ee 81       	ldd	r30, Y+6	; 0x06
    125a:	ff 81       	ldd	r31, Y+7	; 0x07
    125c:	20 83       	st	Z, r18
    125e:	57 c0       	rjmp	.+174    	; 0x130e <DIO_enuSetPinValue+0x1e0>
            break;

            case DIO_GROUP_C:
                if(Copy_u8Value == DIO_HIGH)
    1260:	8c 81       	ldd	r24, Y+4	; 0x04
    1262:	81 30       	cpi	r24, 0x01	; 1
    1264:	a1 f4       	brne	.+40     	; 0x128e <DIO_enuSetPinValue+0x160>
                {
                    PORTC |=  (DIO_MASK_BIT << Copy_u8PinID);
    1266:	a5 e3       	ldi	r26, 0x35	; 53
    1268:	b0 e0       	ldi	r27, 0x00	; 0
    126a:	e5 e3       	ldi	r30, 0x35	; 53
    126c:	f0 e0       	ldi	r31, 0x00	; 0
    126e:	80 81       	ld	r24, Z
    1270:	48 2f       	mov	r20, r24
    1272:	8b 81       	ldd	r24, Y+3	; 0x03
    1274:	28 2f       	mov	r18, r24
    1276:	30 e0       	ldi	r19, 0x00	; 0
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	02 2e       	mov	r0, r18
    127e:	02 c0       	rjmp	.+4      	; 0x1284 <DIO_enuSetPinValue+0x156>
    1280:	88 0f       	add	r24, r24
    1282:	99 1f       	adc	r25, r25
    1284:	0a 94       	dec	r0
    1286:	e2 f7       	brpl	.-8      	; 0x1280 <DIO_enuSetPinValue+0x152>
    1288:	84 2b       	or	r24, r20
    128a:	8c 93       	st	X, r24
    128c:	40 c0       	rjmp	.+128    	; 0x130e <DIO_enuSetPinValue+0x1e0>
                }
                else
                {
                    PORTC &= ~(DIO_MASK_BIT << Copy_u8PinID);
    128e:	a5 e3       	ldi	r26, 0x35	; 53
    1290:	b0 e0       	ldi	r27, 0x00	; 0
    1292:	e5 e3       	ldi	r30, 0x35	; 53
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	80 81       	ld	r24, Z
    1298:	48 2f       	mov	r20, r24
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	28 2f       	mov	r18, r24
    129e:	30 e0       	ldi	r19, 0x00	; 0
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	02 2e       	mov	r0, r18
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <DIO_enuSetPinValue+0x17e>
    12a8:	88 0f       	add	r24, r24
    12aa:	99 1f       	adc	r25, r25
    12ac:	0a 94       	dec	r0
    12ae:	e2 f7       	brpl	.-8      	; 0x12a8 <DIO_enuSetPinValue+0x17a>
    12b0:	80 95       	com	r24
    12b2:	84 23       	and	r24, r20
    12b4:	8c 93       	st	X, r24
    12b6:	2b c0       	rjmp	.+86     	; 0x130e <DIO_enuSetPinValue+0x1e0>
                }
                break;
            
            case DIO_GROUP_D:
                if(Copy_u8Value == DIO_HIGH)
    12b8:	8c 81       	ldd	r24, Y+4	; 0x04
    12ba:	81 30       	cpi	r24, 0x01	; 1
    12bc:	a1 f4       	brne	.+40     	; 0x12e6 <DIO_enuSetPinValue+0x1b8>
                {
                    PORTD |=  (DIO_MASK_BIT << Copy_u8PinID);
    12be:	a2 e3       	ldi	r26, 0x32	; 50
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	e2 e3       	ldi	r30, 0x32	; 50
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	48 2f       	mov	r20, r24
    12ca:	8b 81       	ldd	r24, Y+3	; 0x03
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	02 2e       	mov	r0, r18
    12d6:	02 c0       	rjmp	.+4      	; 0x12dc <DIO_enuSetPinValue+0x1ae>
    12d8:	88 0f       	add	r24, r24
    12da:	99 1f       	adc	r25, r25
    12dc:	0a 94       	dec	r0
    12de:	e2 f7       	brpl	.-8      	; 0x12d8 <DIO_enuSetPinValue+0x1aa>
    12e0:	84 2b       	or	r24, r20
    12e2:	8c 93       	st	X, r24
    12e4:	14 c0       	rjmp	.+40     	; 0x130e <DIO_enuSetPinValue+0x1e0>
                }
                else
                {
                    PORTD &= ~(DIO_MASK_BIT << Copy_u8PinID);
    12e6:	a2 e3       	ldi	r26, 0x32	; 50
    12e8:	b0 e0       	ldi	r27, 0x00	; 0
    12ea:	e2 e3       	ldi	r30, 0x32	; 50
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	48 2f       	mov	r20, r24
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	28 2f       	mov	r18, r24
    12f6:	30 e0       	ldi	r19, 0x00	; 0
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	02 2e       	mov	r0, r18
    12fe:	02 c0       	rjmp	.+4      	; 0x1304 <DIO_enuSetPinValue+0x1d6>
    1300:	88 0f       	add	r24, r24
    1302:	99 1f       	adc	r25, r25
    1304:	0a 94       	dec	r0
    1306:	e2 f7       	brpl	.-8      	; 0x1300 <DIO_enuSetPinValue+0x1d2>
    1308:	80 95       	com	r24
    130a:	84 23       	and	r24, r20
    130c:	8c 93       	st	X, r24
                break;

            default:
            break;
        }
        Local_enuErrorState = ES_OK;
    130e:	19 82       	std	Y+1, r1	; 0x01
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <DIO_enuSetPinValue+0x1e8>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    1312:	82 e0       	ldi	r24, 0x02	; 2
    1314:	89 83       	std	Y+1, r24	; 0x01
    }

    return Local_enuErrorState;
    1316:	89 81       	ldd	r24, Y+1	; 0x01
}
    1318:	29 96       	adiw	r28, 0x09	; 9
    131a:	0f b6       	in	r0, 0x3f	; 63
    131c:	f8 94       	cli
    131e:	de bf       	out	0x3e, r29	; 62
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	cd bf       	out	0x3d, r28	; 61
    1324:	cf 91       	pop	r28
    1326:	df 91       	pop	r29
    1328:	08 95       	ret

0000132a <DIO_enuTogglePinValue>:

ES_t DIO_enuTogglePinValue(u8 Copy_u8GroupID , u8 Copy_u8PinID)
{
    132a:	df 93       	push	r29
    132c:	cf 93       	push	r28
    132e:	00 d0       	rcall	.+0      	; 0x1330 <DIO_enuTogglePinValue+0x6>
    1330:	00 d0       	rcall	.+0      	; 0x1332 <DIO_enuTogglePinValue+0x8>
    1332:	0f 92       	push	r0
    1334:	cd b7       	in	r28, 0x3d	; 61
    1336:	de b7       	in	r29, 0x3e	; 62
    1338:	8a 83       	std	Y+2, r24	; 0x02
    133a:	6b 83       	std	Y+3, r22	; 0x03
    ES_t Local_enuErrorState = ES_NOK;
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	89 83       	std	Y+1, r24	; 0x01

    if ((Copy_u8GroupID <= DIO_GROUP_D) && (Copy_u8PinID <= DIO_PIN_7))
    1340:	8a 81       	ldd	r24, Y+2	; 0x02
    1342:	84 30       	cpi	r24, 0x04	; 4
    1344:	08 f0       	brcs	.+2      	; 0x1348 <DIO_enuTogglePinValue+0x1e>
    1346:	74 c0       	rjmp	.+232    	; 0x1430 <DIO_enuTogglePinValue+0x106>
    1348:	8b 81       	ldd	r24, Y+3	; 0x03
    134a:	88 30       	cpi	r24, 0x08	; 8
    134c:	08 f0       	brcs	.+2      	; 0x1350 <DIO_enuTogglePinValue+0x26>
    134e:	70 c0       	rjmp	.+224    	; 0x1430 <DIO_enuTogglePinValue+0x106>
    {
        switch(Copy_u8GroupID)
    1350:	8a 81       	ldd	r24, Y+2	; 0x02
    1352:	28 2f       	mov	r18, r24
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	3d 83       	std	Y+5, r19	; 0x05
    1358:	2c 83       	std	Y+4, r18	; 0x04
    135a:	8c 81       	ldd	r24, Y+4	; 0x04
    135c:	9d 81       	ldd	r25, Y+5	; 0x05
    135e:	81 30       	cpi	r24, 0x01	; 1
    1360:	91 05       	cpc	r25, r1
    1362:	49 f1       	breq	.+82     	; 0x13b6 <DIO_enuTogglePinValue+0x8c>
    1364:	2c 81       	ldd	r18, Y+4	; 0x04
    1366:	3d 81       	ldd	r19, Y+5	; 0x05
    1368:	22 30       	cpi	r18, 0x02	; 2
    136a:	31 05       	cpc	r19, r1
    136c:	2c f4       	brge	.+10     	; 0x1378 <DIO_enuTogglePinValue+0x4e>
    136e:	8c 81       	ldd	r24, Y+4	; 0x04
    1370:	9d 81       	ldd	r25, Y+5	; 0x05
    1372:	00 97       	sbiw	r24, 0x00	; 0
    1374:	61 f0       	breq	.+24     	; 0x138e <DIO_enuTogglePinValue+0x64>
    1376:	5a c0       	rjmp	.+180    	; 0x142c <DIO_enuTogglePinValue+0x102>
    1378:	2c 81       	ldd	r18, Y+4	; 0x04
    137a:	3d 81       	ldd	r19, Y+5	; 0x05
    137c:	22 30       	cpi	r18, 0x02	; 2
    137e:	31 05       	cpc	r19, r1
    1380:	71 f1       	breq	.+92     	; 0x13de <DIO_enuTogglePinValue+0xb4>
    1382:	8c 81       	ldd	r24, Y+4	; 0x04
    1384:	9d 81       	ldd	r25, Y+5	; 0x05
    1386:	83 30       	cpi	r24, 0x03	; 3
    1388:	91 05       	cpc	r25, r1
    138a:	e9 f1       	breq	.+122    	; 0x1406 <DIO_enuTogglePinValue+0xdc>
    138c:	4f c0       	rjmp	.+158    	; 0x142c <DIO_enuTogglePinValue+0x102>
        {
            case DIO_GROUP_A:
                PORTA ^= (DIO_MASK_BIT <<Copy_u8PinID);
    138e:	ab e3       	ldi	r26, 0x3B	; 59
    1390:	b0 e0       	ldi	r27, 0x00	; 0
    1392:	eb e3       	ldi	r30, 0x3B	; 59
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	80 81       	ld	r24, Z
    1398:	48 2f       	mov	r20, r24
    139a:	8b 81       	ldd	r24, Y+3	; 0x03
    139c:	28 2f       	mov	r18, r24
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	81 e0       	ldi	r24, 0x01	; 1
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	02 2e       	mov	r0, r18
    13a6:	02 c0       	rjmp	.+4      	; 0x13ac <DIO_enuTogglePinValue+0x82>
    13a8:	88 0f       	add	r24, r24
    13aa:	99 1f       	adc	r25, r25
    13ac:	0a 94       	dec	r0
    13ae:	e2 f7       	brpl	.-8      	; 0x13a8 <DIO_enuTogglePinValue+0x7e>
    13b0:	84 27       	eor	r24, r20
    13b2:	8c 93       	st	X, r24
    13b4:	3b c0       	rjmp	.+118    	; 0x142c <DIO_enuTogglePinValue+0x102>
            break;

            case DIO_GROUP_B:
                PORTB ^= (DIO_MASK_BIT <<Copy_u8PinID);
    13b6:	a8 e3       	ldi	r26, 0x38	; 56
    13b8:	b0 e0       	ldi	r27, 0x00	; 0
    13ba:	e8 e3       	ldi	r30, 0x38	; 56
    13bc:	f0 e0       	ldi	r31, 0x00	; 0
    13be:	80 81       	ld	r24, Z
    13c0:	48 2f       	mov	r20, r24
    13c2:	8b 81       	ldd	r24, Y+3	; 0x03
    13c4:	28 2f       	mov	r18, r24
    13c6:	30 e0       	ldi	r19, 0x00	; 0
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	02 2e       	mov	r0, r18
    13ce:	02 c0       	rjmp	.+4      	; 0x13d4 <DIO_enuTogglePinValue+0xaa>
    13d0:	88 0f       	add	r24, r24
    13d2:	99 1f       	adc	r25, r25
    13d4:	0a 94       	dec	r0
    13d6:	e2 f7       	brpl	.-8      	; 0x13d0 <DIO_enuTogglePinValue+0xa6>
    13d8:	84 27       	eor	r24, r20
    13da:	8c 93       	st	X, r24
    13dc:	27 c0       	rjmp	.+78     	; 0x142c <DIO_enuTogglePinValue+0x102>
            break;

            case DIO_GROUP_C:
                PORTC ^= (DIO_MASK_BIT <<Copy_u8PinID);
    13de:	a5 e3       	ldi	r26, 0x35	; 53
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	e5 e3       	ldi	r30, 0x35	; 53
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	80 81       	ld	r24, Z
    13e8:	48 2f       	mov	r20, r24
    13ea:	8b 81       	ldd	r24, Y+3	; 0x03
    13ec:	28 2f       	mov	r18, r24
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	02 2e       	mov	r0, r18
    13f6:	02 c0       	rjmp	.+4      	; 0x13fc <DIO_enuTogglePinValue+0xd2>
    13f8:	88 0f       	add	r24, r24
    13fa:	99 1f       	adc	r25, r25
    13fc:	0a 94       	dec	r0
    13fe:	e2 f7       	brpl	.-8      	; 0x13f8 <DIO_enuTogglePinValue+0xce>
    1400:	84 27       	eor	r24, r20
    1402:	8c 93       	st	X, r24
    1404:	13 c0       	rjmp	.+38     	; 0x142c <DIO_enuTogglePinValue+0x102>
            break;
            
            case DIO_GROUP_D:
                PORTD ^= (DIO_MASK_BIT <<Copy_u8PinID);
    1406:	a2 e3       	ldi	r26, 0x32	; 50
    1408:	b0 e0       	ldi	r27, 0x00	; 0
    140a:	e2 e3       	ldi	r30, 0x32	; 50
    140c:	f0 e0       	ldi	r31, 0x00	; 0
    140e:	80 81       	ld	r24, Z
    1410:	48 2f       	mov	r20, r24
    1412:	8b 81       	ldd	r24, Y+3	; 0x03
    1414:	28 2f       	mov	r18, r24
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	02 2e       	mov	r0, r18
    141e:	02 c0       	rjmp	.+4      	; 0x1424 <DIO_enuTogglePinValue+0xfa>
    1420:	88 0f       	add	r24, r24
    1422:	99 1f       	adc	r25, r25
    1424:	0a 94       	dec	r0
    1426:	e2 f7       	brpl	.-8      	; 0x1420 <DIO_enuTogglePinValue+0xf6>
    1428:	84 27       	eor	r24, r20
    142a:	8c 93       	st	X, r24
            break;

            default:
            break;
        }
        Local_enuErrorState = ES_OK;
    142c:	19 82       	std	Y+1, r1	; 0x01
    142e:	02 c0       	rjmp	.+4      	; 0x1434 <DIO_enuTogglePinValue+0x10a>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    1430:	82 e0       	ldi	r24, 0x02	; 2
    1432:	89 83       	std	Y+1, r24	; 0x01
    }

    return Local_enuErrorState;
    1434:	89 81       	ldd	r24, Y+1	; 0x01
}
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	0f 90       	pop	r0
    1440:	cf 91       	pop	r28
    1442:	df 91       	pop	r29
    1444:	08 95       	ret

00001446 <DIO_enuGetPinValue>:

ES_t DIO_enuGetPinValue(u8 Copy_u8GroupID , u8 Copy_u8PinID , u8 * Copy_pu8PinValue)
{
    1446:	df 93       	push	r29
    1448:	cf 93       	push	r28
    144a:	cd b7       	in	r28, 0x3d	; 61
    144c:	de b7       	in	r29, 0x3e	; 62
    144e:	27 97       	sbiw	r28, 0x07	; 7
    1450:	0f b6       	in	r0, 0x3f	; 63
    1452:	f8 94       	cli
    1454:	de bf       	out	0x3e, r29	; 62
    1456:	0f be       	out	0x3f, r0	; 63
    1458:	cd bf       	out	0x3d, r28	; 61
    145a:	8a 83       	std	Y+2, r24	; 0x02
    145c:	6b 83       	std	Y+3, r22	; 0x03
    145e:	5d 83       	std	Y+5, r21	; 0x05
    1460:	4c 83       	std	Y+4, r20	; 0x04
    ES_t Local_enuErrorState = ES_NOK;
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	89 83       	std	Y+1, r24	; 0x01

    if (Copy_pu8PinValue != NULL)
    1466:	8c 81       	ldd	r24, Y+4	; 0x04
    1468:	9d 81       	ldd	r25, Y+5	; 0x05
    146a:	00 97       	sbiw	r24, 0x00	; 0
    146c:	09 f4       	brne	.+2      	; 0x1470 <DIO_enuGetPinValue+0x2a>
    146e:	7d c0       	rjmp	.+250    	; 0x156a <DIO_enuGetPinValue+0x124>
    {
        if ((Copy_u8GroupID <= DIO_GROUP_D) && (Copy_u8PinID <= DIO_PIN_7))
    1470:	8a 81       	ldd	r24, Y+2	; 0x02
    1472:	84 30       	cpi	r24, 0x04	; 4
    1474:	08 f0       	brcs	.+2      	; 0x1478 <DIO_enuGetPinValue+0x32>
    1476:	76 c0       	rjmp	.+236    	; 0x1564 <DIO_enuGetPinValue+0x11e>
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	88 30       	cpi	r24, 0x08	; 8
    147c:	08 f0       	brcs	.+2      	; 0x1480 <DIO_enuGetPinValue+0x3a>
    147e:	72 c0       	rjmp	.+228    	; 0x1564 <DIO_enuGetPinValue+0x11e>
        {
            switch(Copy_u8GroupID)
    1480:	8a 81       	ldd	r24, Y+2	; 0x02
    1482:	28 2f       	mov	r18, r24
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	3f 83       	std	Y+7, r19	; 0x07
    1488:	2e 83       	std	Y+6, r18	; 0x06
    148a:	4e 81       	ldd	r20, Y+6	; 0x06
    148c:	5f 81       	ldd	r21, Y+7	; 0x07
    148e:	41 30       	cpi	r20, 0x01	; 1
    1490:	51 05       	cpc	r21, r1
    1492:	59 f1       	breq	.+86     	; 0x14ea <DIO_enuGetPinValue+0xa4>
    1494:	8e 81       	ldd	r24, Y+6	; 0x06
    1496:	9f 81       	ldd	r25, Y+7	; 0x07
    1498:	82 30       	cpi	r24, 0x02	; 2
    149a:	91 05       	cpc	r25, r1
    149c:	34 f4       	brge	.+12     	; 0x14aa <DIO_enuGetPinValue+0x64>
    149e:	2e 81       	ldd	r18, Y+6	; 0x06
    14a0:	3f 81       	ldd	r19, Y+7	; 0x07
    14a2:	21 15       	cp	r18, r1
    14a4:	31 05       	cpc	r19, r1
    14a6:	69 f0       	breq	.+26     	; 0x14c2 <DIO_enuGetPinValue+0x7c>
    14a8:	5b c0       	rjmp	.+182    	; 0x1560 <DIO_enuGetPinValue+0x11a>
    14aa:	4e 81       	ldd	r20, Y+6	; 0x06
    14ac:	5f 81       	ldd	r21, Y+7	; 0x07
    14ae:	42 30       	cpi	r20, 0x02	; 2
    14b0:	51 05       	cpc	r21, r1
    14b2:	79 f1       	breq	.+94     	; 0x1512 <DIO_enuGetPinValue+0xcc>
    14b4:	8e 81       	ldd	r24, Y+6	; 0x06
    14b6:	9f 81       	ldd	r25, Y+7	; 0x07
    14b8:	83 30       	cpi	r24, 0x03	; 3
    14ba:	91 05       	cpc	r25, r1
    14bc:	09 f4       	brne	.+2      	; 0x14c0 <DIO_enuGetPinValue+0x7a>
    14be:	3d c0       	rjmp	.+122    	; 0x153a <DIO_enuGetPinValue+0xf4>
    14c0:	4f c0       	rjmp	.+158    	; 0x1560 <DIO_enuGetPinValue+0x11a>
            {
                case DIO_GROUP_A:
                    *Copy_pu8PinValue = ((PINA >> Copy_u8PinID) & DIO_MASK_BIT);
    14c2:	e9 e3       	ldi	r30, 0x39	; 57
    14c4:	f0 e0       	ldi	r31, 0x00	; 0
    14c6:	80 81       	ld	r24, Z
    14c8:	28 2f       	mov	r18, r24
    14ca:	30 e0       	ldi	r19, 0x00	; 0
    14cc:	8b 81       	ldd	r24, Y+3	; 0x03
    14ce:	88 2f       	mov	r24, r24
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	a9 01       	movw	r20, r18
    14d4:	02 c0       	rjmp	.+4      	; 0x14da <DIO_enuGetPinValue+0x94>
    14d6:	55 95       	asr	r21
    14d8:	47 95       	ror	r20
    14da:	8a 95       	dec	r24
    14dc:	e2 f7       	brpl	.-8      	; 0x14d6 <DIO_enuGetPinValue+0x90>
    14de:	ca 01       	movw	r24, r20
    14e0:	81 70       	andi	r24, 0x01	; 1
    14e2:	ec 81       	ldd	r30, Y+4	; 0x04
    14e4:	fd 81       	ldd	r31, Y+5	; 0x05
    14e6:	80 83       	st	Z, r24
    14e8:	3b c0       	rjmp	.+118    	; 0x1560 <DIO_enuGetPinValue+0x11a>
                break;

                case DIO_GROUP_B:
                    *Copy_pu8PinValue = ((PINB >> Copy_u8PinID) & DIO_MASK_BIT);
    14ea:	e6 e3       	ldi	r30, 0x36	; 54
    14ec:	f0 e0       	ldi	r31, 0x00	; 0
    14ee:	80 81       	ld	r24, Z
    14f0:	28 2f       	mov	r18, r24
    14f2:	30 e0       	ldi	r19, 0x00	; 0
    14f4:	8b 81       	ldd	r24, Y+3	; 0x03
    14f6:	88 2f       	mov	r24, r24
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	a9 01       	movw	r20, r18
    14fc:	02 c0       	rjmp	.+4      	; 0x1502 <DIO_enuGetPinValue+0xbc>
    14fe:	55 95       	asr	r21
    1500:	47 95       	ror	r20
    1502:	8a 95       	dec	r24
    1504:	e2 f7       	brpl	.-8      	; 0x14fe <DIO_enuGetPinValue+0xb8>
    1506:	ca 01       	movw	r24, r20
    1508:	81 70       	andi	r24, 0x01	; 1
    150a:	ec 81       	ldd	r30, Y+4	; 0x04
    150c:	fd 81       	ldd	r31, Y+5	; 0x05
    150e:	80 83       	st	Z, r24
    1510:	27 c0       	rjmp	.+78     	; 0x1560 <DIO_enuGetPinValue+0x11a>
                break;

                case DIO_GROUP_C:
                    *Copy_pu8PinValue = ((PINC >> Copy_u8PinID) & DIO_MASK_BIT);
    1512:	e3 e3       	ldi	r30, 0x33	; 51
    1514:	f0 e0       	ldi	r31, 0x00	; 0
    1516:	80 81       	ld	r24, Z
    1518:	28 2f       	mov	r18, r24
    151a:	30 e0       	ldi	r19, 0x00	; 0
    151c:	8b 81       	ldd	r24, Y+3	; 0x03
    151e:	88 2f       	mov	r24, r24
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	a9 01       	movw	r20, r18
    1524:	02 c0       	rjmp	.+4      	; 0x152a <DIO_enuGetPinValue+0xe4>
    1526:	55 95       	asr	r21
    1528:	47 95       	ror	r20
    152a:	8a 95       	dec	r24
    152c:	e2 f7       	brpl	.-8      	; 0x1526 <DIO_enuGetPinValue+0xe0>
    152e:	ca 01       	movw	r24, r20
    1530:	81 70       	andi	r24, 0x01	; 1
    1532:	ec 81       	ldd	r30, Y+4	; 0x04
    1534:	fd 81       	ldd	r31, Y+5	; 0x05
    1536:	80 83       	st	Z, r24
    1538:	13 c0       	rjmp	.+38     	; 0x1560 <DIO_enuGetPinValue+0x11a>
                break;
                
                case DIO_GROUP_D:
                    *Copy_pu8PinValue = ((PIND >> Copy_u8PinID) & DIO_MASK_BIT);
    153a:	e0 e3       	ldi	r30, 0x30	; 48
    153c:	f0 e0       	ldi	r31, 0x00	; 0
    153e:	80 81       	ld	r24, Z
    1540:	28 2f       	mov	r18, r24
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	88 2f       	mov	r24, r24
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	a9 01       	movw	r20, r18
    154c:	02 c0       	rjmp	.+4      	; 0x1552 <DIO_enuGetPinValue+0x10c>
    154e:	55 95       	asr	r21
    1550:	47 95       	ror	r20
    1552:	8a 95       	dec	r24
    1554:	e2 f7       	brpl	.-8      	; 0x154e <DIO_enuGetPinValue+0x108>
    1556:	ca 01       	movw	r24, r20
    1558:	81 70       	andi	r24, 0x01	; 1
    155a:	ec 81       	ldd	r30, Y+4	; 0x04
    155c:	fd 81       	ldd	r31, Y+5	; 0x05
    155e:	80 83       	st	Z, r24
                break;

                default:
                break;
            }
            Local_enuErrorState = ES_OK;
    1560:	19 82       	std	Y+1, r1	; 0x01
    1562:	05 c0       	rjmp	.+10     	; 0x156e <DIO_enuGetPinValue+0x128>
        }
        else
        {
            Local_enuErrorState = ES_OUT_OF_RANGE;
    1564:	82 e0       	ldi	r24, 0x02	; 2
    1566:	89 83       	std	Y+1, r24	; 0x01
    1568:	02 c0       	rjmp	.+4      	; 0x156e <DIO_enuGetPinValue+0x128>
        }
    }   
    else
    {
        Local_enuErrorState = ES_NULL_POINTER;
    156a:	83 e0       	ldi	r24, 0x03	; 3
    156c:	89 83       	std	Y+1, r24	; 0x01
    } 

    return Local_enuErrorState;
    156e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1570:	27 96       	adiw	r28, 0x07	; 7
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	de bf       	out	0x3e, r29	; 62
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	cf 91       	pop	r28
    157e:	df 91       	pop	r29
    1580:	08 95       	ret

00001582 <Switch_enuInit>:

extern u8 Switch_u8MaxSwitchNum;
extern Switch_t Switch_astrSwitchConfig [];

ES_t Switch_enuInit(void)
{
    1582:	df 93       	push	r29
    1584:	cf 93       	push	r28
    1586:	00 d0       	rcall	.+0      	; 0x1588 <Switch_enuInit+0x6>
    1588:	cd b7       	in	r28, 0x3d	; 61
    158a:	de b7       	in	r29, 0x3e	; 62
    ES_t Local_enuErrorState = ES_NOK;
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	8a 83       	std	Y+2, r24	; 0x02
    u8 Local_u8Iter = 0;
    1590:	19 82       	std	Y+1, r1	; 0x01
    for (Local_u8Iter = 0 ; Local_u8Iter < Switch_u8MaxSwitchNum ; Local_u8Iter++)
    1592:	19 82       	std	Y+1, r1	; 0x01
    1594:	51 c0       	rjmp	.+162    	; 0x1638 <Switch_enuInit+0xb6>
    {
        Local_enuErrorState = DIO_enuSetPinDirection(Switch_astrSwitchConfig[Local_u8Iter].swGrp ,
    1596:	89 81       	ldd	r24, Y+1	; 0x01
    1598:	28 2f       	mov	r18, r24
    159a:	30 e0       	ldi	r19, 0x00	; 0
    159c:	c9 01       	movw	r24, r18
    159e:	88 0f       	add	r24, r24
    15a0:	99 1f       	adc	r25, r25
    15a2:	82 0f       	add	r24, r18
    15a4:	93 1f       	adc	r25, r19
    15a6:	fc 01       	movw	r30, r24
    15a8:	e4 56       	subi	r30, 0x64	; 100
    15aa:	ff 4f       	sbci	r31, 0xFF	; 255
    15ac:	40 81       	ld	r20, Z
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	28 2f       	mov	r18, r24
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	c9 01       	movw	r24, r18
    15b6:	88 0f       	add	r24, r24
    15b8:	99 1f       	adc	r25, r25
    15ba:	82 0f       	add	r24, r18
    15bc:	93 1f       	adc	r25, r19
    15be:	fc 01       	movw	r30, r24
    15c0:	e3 56       	subi	r30, 0x63	; 99
    15c2:	ff 4f       	sbci	r31, 0xFF	; 255
    15c4:	90 81       	ld	r25, Z
    15c6:	84 2f       	mov	r24, r20
    15c8:	69 2f       	mov	r22, r25
    15ca:	40 e0       	ldi	r20, 0x00	; 0
    15cc:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    15d0:	8a 83       	std	Y+2, r24	; 0x02
                        Switch_astrSwitchConfig[Local_u8Iter].swPin , DIO_INPUT);
        if (Local_enuErrorState != ES_OK)
    15d2:	8a 81       	ldd	r24, Y+2	; 0x02
    15d4:	88 23       	and	r24, r24
    15d6:	b1 f5       	brne	.+108    	; 0x1644 <Switch_enuInit+0xc2>
        {
            break;
        }
        Local_enuErrorState = DIO_enuSetPinValue(Switch_astrSwitchConfig[Local_u8Iter].swGrp ,
    15d8:	89 81       	ldd	r24, Y+1	; 0x01
    15da:	28 2f       	mov	r18, r24
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	c9 01       	movw	r24, r18
    15e0:	88 0f       	add	r24, r24
    15e2:	99 1f       	adc	r25, r25
    15e4:	82 0f       	add	r24, r18
    15e6:	93 1f       	adc	r25, r19
    15e8:	fc 01       	movw	r30, r24
    15ea:	e4 56       	subi	r30, 0x64	; 100
    15ec:	ff 4f       	sbci	r31, 0xFF	; 255
    15ee:	50 81       	ld	r21, Z
    15f0:	89 81       	ldd	r24, Y+1	; 0x01
    15f2:	28 2f       	mov	r18, r24
    15f4:	30 e0       	ldi	r19, 0x00	; 0
    15f6:	c9 01       	movw	r24, r18
    15f8:	88 0f       	add	r24, r24
    15fa:	99 1f       	adc	r25, r25
    15fc:	82 0f       	add	r24, r18
    15fe:	93 1f       	adc	r25, r19
    1600:	fc 01       	movw	r30, r24
    1602:	e3 56       	subi	r30, 0x63	; 99
    1604:	ff 4f       	sbci	r31, 0xFF	; 255
    1606:	40 81       	ld	r20, Z
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	28 2f       	mov	r18, r24
    160c:	30 e0       	ldi	r19, 0x00	; 0
    160e:	c9 01       	movw	r24, r18
    1610:	88 0f       	add	r24, r24
    1612:	99 1f       	adc	r25, r25
    1614:	82 0f       	add	r24, r18
    1616:	93 1f       	adc	r25, r19
    1618:	fc 01       	movw	r30, r24
    161a:	e2 56       	subi	r30, 0x62	; 98
    161c:	ff 4f       	sbci	r31, 0xFF	; 255
    161e:	90 81       	ld	r25, Z
    1620:	85 2f       	mov	r24, r21
    1622:	64 2f       	mov	r22, r20
    1624:	49 2f       	mov	r20, r25
    1626:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    162a:	8a 83       	std	Y+2, r24	; 0x02
                        Switch_astrSwitchConfig[Local_u8Iter].swPin , Switch_astrSwitchConfig[Local_u8Iter].swState);
        if (Local_enuErrorState != ES_OK)
    162c:	8a 81       	ldd	r24, Y+2	; 0x02
    162e:	88 23       	and	r24, r24
    1630:	49 f4       	brne	.+18     	; 0x1644 <Switch_enuInit+0xc2>

ES_t Switch_enuInit(void)
{
    ES_t Local_enuErrorState = ES_NOK;
    u8 Local_u8Iter = 0;
    for (Local_u8Iter = 0 ; Local_u8Iter < Switch_u8MaxSwitchNum ; Local_u8Iter++)
    1632:	89 81       	ldd	r24, Y+1	; 0x01
    1634:	8f 5f       	subi	r24, 0xFF	; 255
    1636:	89 83       	std	Y+1, r24	; 0x01
    1638:	90 91 9b 00 	lds	r25, 0x009B
    163c:	89 81       	ldd	r24, Y+1	; 0x01
    163e:	89 17       	cp	r24, r25
    1640:	08 f4       	brcc	.+2      	; 0x1644 <Switch_enuInit+0xc2>
    1642:	a9 cf       	rjmp	.-174    	; 0x1596 <Switch_enuInit+0x14>
        {
            break;
        }
    }

    return Local_enuErrorState ;
    1644:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1646:	0f 90       	pop	r0
    1648:	0f 90       	pop	r0
    164a:	cf 91       	pop	r28
    164c:	df 91       	pop	r29
    164e:	08 95       	ret

00001650 <Switch_enuGetSwitchState>:

ES_t Switch_enuGetSwitchState(u8 Copy_u8SwitchID , u8 *Copy_pu8SwitchState)
{
    1650:	df 93       	push	r29
    1652:	cf 93       	push	r28
    1654:	00 d0       	rcall	.+0      	; 0x1656 <Switch_enuGetSwitchState+0x6>
    1656:	00 d0       	rcall	.+0      	; 0x1658 <Switch_enuGetSwitchState+0x8>
    1658:	cd b7       	in	r28, 0x3d	; 61
    165a:	de b7       	in	r29, 0x3e	; 62
    165c:	8a 83       	std	Y+2, r24	; 0x02
    165e:	7c 83       	std	Y+4, r23	; 0x04
    1660:	6b 83       	std	Y+3, r22	; 0x03
    ES_t Local_enuErrorState = ES_NOK;
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	89 83       	std	Y+1, r24	; 0x01
    
    if (Copy_pu8SwitchState != NULL)
    1666:	8b 81       	ldd	r24, Y+3	; 0x03
    1668:	9c 81       	ldd	r25, Y+4	; 0x04
    166a:	00 97       	sbiw	r24, 0x00	; 0
    166c:	49 f1       	breq	.+82     	; 0x16c0 <Switch_enuGetSwitchState+0x70>
    {
        if (Copy_u8SwitchID < Switch_u8MaxSwitchNum)
    166e:	90 91 9b 00 	lds	r25, 0x009B
    1672:	8a 81       	ldd	r24, Y+2	; 0x02
    1674:	89 17       	cp	r24, r25
    1676:	08 f5       	brcc	.+66     	; 0x16ba <Switch_enuGetSwitchState+0x6a>
        {
            Local_enuErrorState = DIO_enuGetPinValue(Switch_astrSwitchConfig[Copy_u8SwitchID].swGrp ,
    1678:	8a 81       	ldd	r24, Y+2	; 0x02
    167a:	28 2f       	mov	r18, r24
    167c:	30 e0       	ldi	r19, 0x00	; 0
    167e:	c9 01       	movw	r24, r18
    1680:	88 0f       	add	r24, r24
    1682:	99 1f       	adc	r25, r25
    1684:	82 0f       	add	r24, r18
    1686:	93 1f       	adc	r25, r19
    1688:	fc 01       	movw	r30, r24
    168a:	e4 56       	subi	r30, 0x64	; 100
    168c:	ff 4f       	sbci	r31, 0xFF	; 255
    168e:	40 81       	ld	r20, Z
    1690:	8a 81       	ldd	r24, Y+2	; 0x02
    1692:	28 2f       	mov	r18, r24
    1694:	30 e0       	ldi	r19, 0x00	; 0
    1696:	c9 01       	movw	r24, r18
    1698:	88 0f       	add	r24, r24
    169a:	99 1f       	adc	r25, r25
    169c:	82 0f       	add	r24, r18
    169e:	93 1f       	adc	r25, r19
    16a0:	fc 01       	movw	r30, r24
    16a2:	e3 56       	subi	r30, 0x63	; 99
    16a4:	ff 4f       	sbci	r31, 0xFF	; 255
    16a6:	90 81       	ld	r25, Z
    16a8:	2b 81       	ldd	r18, Y+3	; 0x03
    16aa:	3c 81       	ldd	r19, Y+4	; 0x04
    16ac:	84 2f       	mov	r24, r20
    16ae:	69 2f       	mov	r22, r25
    16b0:	a9 01       	movw	r20, r18
    16b2:	0e 94 23 0a 	call	0x1446	; 0x1446 <DIO_enuGetPinValue>
    16b6:	89 83       	std	Y+1, r24	; 0x01
    16b8:	05 c0       	rjmp	.+10     	; 0x16c4 <Switch_enuGetSwitchState+0x74>
                    Switch_astrSwitchConfig[Copy_u8SwitchID].swPin , Copy_pu8SwitchState);
        
        }
        else
        {
            Local_enuErrorState = ES_OUT_OF_RANGE;
    16ba:	82 e0       	ldi	r24, 0x02	; 2
    16bc:	89 83       	std	Y+1, r24	; 0x01
    16be:	02 c0       	rjmp	.+4      	; 0x16c4 <Switch_enuGetSwitchState+0x74>
        }
    }
    else
    {
        Local_enuErrorState = ES_NULL_POINTER;
    16c0:	83 e0       	ldi	r24, 0x03	; 3
    16c2:	89 83       	std	Y+1, r24	; 0x01
    }
    
    return Local_enuErrorState ;
    16c4:	89 81       	ldd	r24, Y+1	; 0x01
}
    16c6:	0f 90       	pop	r0
    16c8:	0f 90       	pop	r0
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	cf 91       	pop	r28
    16d0:	df 91       	pop	r29
    16d2:	08 95       	ret

000016d4 <HexaDec_enuInit>:
							0x7C,0x39,0x5E,0x79,0x71
						};
#endif

ES_t HexaDec_enuInit(void)
{
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
    16dc:	28 97       	sbiw	r28, 0x08	; 8
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	0f be       	out	0x3f, r0	; 63
    16e6:	cd bf       	out	0x3d, r28	; 61
    ES_t Local_enuErrorState = ES_NOK;
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	8a 83       	std	Y+2, r24	; 0x02

    #if HEX_DEC_A_PIN <= DIO_PIN_7 &&HEX_DEC_B_PIN <= DIO_PIN_7 &&HEX_DEC_C_PIN <= DIO_PIN_7 &&HEX_DEC_D_PIN <= DIO_PIN_7 && HEX_DEC_EN1_PIN <= DIO_PIN_7&& HEX_DEC_EN2_PIN <= DIO_PIN_7
        #if HEX_DEC_A_GRP <=DIO_GROUP_D && HEX_DEC_B_GRP <=DIO_GROUP_D && HEX_DEC_C_GRP <=DIO_GROUP_D && HEX_DEC_D_GRP <=DIO_GROUP_D && HEX_DEC_EN1_GRP <=DIO_GROUP_D && HEX_DEC_EN2_GRP <=DIO_GROUP_D   
            
            ES_t Local_aenuErrors [6] = {0};
    16ec:	86 e0       	ldi	r24, 0x06	; 6
    16ee:	fe 01       	movw	r30, r28
    16f0:	33 96       	adiw	r30, 0x03	; 3
    16f2:	df 01       	movw	r26, r30
    16f4:	98 2f       	mov	r25, r24
    16f6:	1d 92       	st	X+, r1
    16f8:	9a 95       	dec	r25
    16fa:	e9 f7       	brne	.-6      	; 0x16f6 <HexaDec_enuInit+0x22>
            Local_aenuErrors[0]=DIO_enuSetPinDirection(HEX_DEC_A_GRP , HEX_DEC_A_PIN , DIO_OUTPUT);
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	60 e0       	ldi	r22, 0x00	; 0
    1700:	41 e0       	ldi	r20, 0x01	; 1
    1702:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    1706:	8b 83       	std	Y+3, r24	; 0x03
            Local_aenuErrors[1]=DIO_enuSetPinDirection(HEX_DEC_B_GRP , HEX_DEC_B_PIN , DIO_OUTPUT);
    1708:	81 e0       	ldi	r24, 0x01	; 1
    170a:	61 e0       	ldi	r22, 0x01	; 1
    170c:	41 e0       	ldi	r20, 0x01	; 1
    170e:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    1712:	8c 83       	std	Y+4, r24	; 0x04
            Local_aenuErrors[2]=DIO_enuSetPinDirection(HEX_DEC_C_GRP , HEX_DEC_C_PIN , DIO_OUTPUT);
    1714:	81 e0       	ldi	r24, 0x01	; 1
    1716:	62 e0       	ldi	r22, 0x02	; 2
    1718:	41 e0       	ldi	r20, 0x01	; 1
    171a:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    171e:	8d 83       	std	Y+5, r24	; 0x05
            Local_aenuErrors[3]=DIO_enuSetPinDirection(HEX_DEC_D_GRP , HEX_DEC_D_PIN , DIO_OUTPUT);
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	64 e0       	ldi	r22, 0x04	; 4
    1724:	41 e0       	ldi	r20, 0x01	; 1
    1726:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    172a:	8e 83       	std	Y+6, r24	; 0x06

            Local_aenuErrors[4]=DIO_enuSetPinDirection(HEX_DEC_EN1_GRP , HEX_DEC_EN1_PIN , DIO_OUTPUT);
    172c:	81 e0       	ldi	r24, 0x01	; 1
    172e:	65 e0       	ldi	r22, 0x05	; 5
    1730:	41 e0       	ldi	r20, 0x01	; 1
    1732:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    1736:	8f 83       	std	Y+7, r24	; 0x07
            Local_aenuErrors[5]=DIO_enuSetPinDirection(HEX_DEC_EN2_GRP , HEX_DEC_EN2_PIN , DIO_OUTPUT);
    1738:	80 e0       	ldi	r24, 0x00	; 0
    173a:	62 e0       	ldi	r22, 0x02	; 2
    173c:	41 e0       	ldi	r20, 0x01	; 1
    173e:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    1742:	88 87       	std	Y+8, r24	; 0x08
            #if SSG_HW_CONFIG == SSG_PINS_ANODE || SSG_HW_CONFIG == SSG_PINS_ANODE 
                DIO_enuSetPinDirection(HEX_DEC_E_GRP , HEX_DEC_E_PIN , DIO_OUTPUT);
                DIO_enuSetPinDirection(HEX_DEC_F_GRP , HEX_DEC_F_PIN , DIO_OUTPUT);
                DIO_enuSetPinDirection(HEX_DEC_G_GRP , HEX_DEC_G_PIN , DIO_OUTPUT);
            #endif
            for (u8 i =0 ; i<6 ; i++)
    1744:	19 82       	std	Y+1, r1	; 0x01
    1746:	19 c0       	rjmp	.+50     	; 0x177a <HexaDec_enuInit+0xa6>
            {
                if (Local_aenuErrors[i] != ES_OK)
    1748:	89 81       	ldd	r24, Y+1	; 0x01
    174a:	28 2f       	mov	r18, r24
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	ce 01       	movw	r24, r28
    1750:	03 96       	adiw	r24, 0x03	; 3
    1752:	fc 01       	movw	r30, r24
    1754:	e2 0f       	add	r30, r18
    1756:	f3 1f       	adc	r31, r19
    1758:	80 81       	ld	r24, Z
    175a:	88 23       	and	r24, r24
    175c:	59 f0       	breq	.+22     	; 0x1774 <HexaDec_enuInit+0xa0>
                {
                    Local_enuErrorState = Local_aenuErrors[i];
    175e:	89 81       	ldd	r24, Y+1	; 0x01
    1760:	28 2f       	mov	r18, r24
    1762:	30 e0       	ldi	r19, 0x00	; 0
    1764:	ce 01       	movw	r24, r28
    1766:	03 96       	adiw	r24, 0x03	; 3
    1768:	fc 01       	movw	r30, r24
    176a:	e2 0f       	add	r30, r18
    176c:	f3 1f       	adc	r31, r19
    176e:	80 81       	ld	r24, Z
    1770:	8a 83       	std	Y+2, r24	; 0x02
    1772:	06 c0       	rjmp	.+12     	; 0x1780 <HexaDec_enuInit+0xac>
            #if SSG_HW_CONFIG == SSG_PINS_ANODE || SSG_HW_CONFIG == SSG_PINS_ANODE 
                DIO_enuSetPinDirection(HEX_DEC_E_GRP , HEX_DEC_E_PIN , DIO_OUTPUT);
                DIO_enuSetPinDirection(HEX_DEC_F_GRP , HEX_DEC_F_PIN , DIO_OUTPUT);
                DIO_enuSetPinDirection(HEX_DEC_G_GRP , HEX_DEC_G_PIN , DIO_OUTPUT);
            #endif
            for (u8 i =0 ; i<6 ; i++)
    1774:	89 81       	ldd	r24, Y+1	; 0x01
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	89 83       	std	Y+1, r24	; 0x01
    177a:	89 81       	ldd	r24, Y+1	; 0x01
    177c:	86 30       	cpi	r24, 0x06	; 6
    177e:	20 f3       	brcs	.-56     	; 0x1748 <HexaDec_enuInit+0x74>
            #error hexa group config is out of range 
        #endif
    #else
        #error hexa pins config is out of range 
    #endif
    return Local_enuErrorState;
    1780:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1782:	28 96       	adiw	r28, 0x08	; 8
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	de bf       	out	0x3e, r29	; 62
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	cd bf       	out	0x3d, r28	; 61
    178e:	cf 91       	pop	r28
    1790:	df 91       	pop	r29
    1792:	08 95       	ret

00001794 <HexaDec_enuDisplayNum>:

ES_t HexaDec_enuDisplayNum(u8 Copy_u8Num)
{
    1794:	df 93       	push	r29
    1796:	cf 93       	push	r28
    1798:	00 d0       	rcall	.+0      	; 0x179a <HexaDec_enuDisplayNum+0x6>
    179a:	cd b7       	in	r28, 0x3d	; 61
    179c:	de b7       	in	r29, 0x3e	; 62
    179e:	8a 83       	std	Y+2, r24	; 0x02
    ES_t Local_enuErrorState = ES_NOK;
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    }
#else
    if (Copy_u8Num <= 9)
    17a4:	8a 81       	ldd	r24, Y+2	; 0x02
    17a6:	8a 30       	cpi	r24, 0x0A	; 10
    17a8:	38 f5       	brcc	.+78     	; 0x17f8 <HexaDec_enuDisplayNum+0x64>
    {
        DIO_enuSetPinValue(HEX_DEC_A_GRP , HEX_DEC_A_PIN , ((Copy_u8Num>> 0 )& 1));
    17aa:	8a 81       	ldd	r24, Y+2	; 0x02
    17ac:	98 2f       	mov	r25, r24
    17ae:	91 70       	andi	r25, 0x01	; 1
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	60 e0       	ldi	r22, 0x00	; 0
    17b4:	49 2f       	mov	r20, r25
    17b6:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
        DIO_enuSetPinValue(HEX_DEC_B_GRP , HEX_DEC_B_PIN , ((Copy_u8Num>> 1 )& 1));
    17ba:	8a 81       	ldd	r24, Y+2	; 0x02
    17bc:	86 95       	lsr	r24
    17be:	98 2f       	mov	r25, r24
    17c0:	91 70       	andi	r25, 0x01	; 1
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	61 e0       	ldi	r22, 0x01	; 1
    17c6:	49 2f       	mov	r20, r25
    17c8:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
        DIO_enuSetPinValue(HEX_DEC_C_GRP , HEX_DEC_C_PIN , ((Copy_u8Num>> 2 )& 1));
    17cc:	8a 81       	ldd	r24, Y+2	; 0x02
    17ce:	86 95       	lsr	r24
    17d0:	86 95       	lsr	r24
    17d2:	98 2f       	mov	r25, r24
    17d4:	91 70       	andi	r25, 0x01	; 1
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	62 e0       	ldi	r22, 0x02	; 2
    17da:	49 2f       	mov	r20, r25
    17dc:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
        DIO_enuSetPinValue(HEX_DEC_D_GRP , HEX_DEC_D_PIN , ((Copy_u8Num>> 3 )& 1));
    17e0:	8a 81       	ldd	r24, Y+2	; 0x02
    17e2:	86 95       	lsr	r24
    17e4:	86 95       	lsr	r24
    17e6:	86 95       	lsr	r24
    17e8:	98 2f       	mov	r25, r24
    17ea:	91 70       	andi	r25, 0x01	; 1
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	64 e0       	ldi	r22, 0x04	; 4
    17f0:	49 2f       	mov	r20, r25
    17f2:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    17f6:	02 c0       	rjmp	.+4      	; 0x17fc <HexaDec_enuDisplayNum+0x68>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    17f8:	82 e0       	ldi	r24, 0x02	; 2
    17fa:	89 83       	std	Y+1, r24	; 0x01
    }
#endif
    return Local_enuErrorState;
    17fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	cf 91       	pop	r28
    1804:	df 91       	pop	r29
    1806:	08 95       	ret

00001808 <HexaDec_enuEnableSSG>:


ES_t HexaDec_enuEnableSSG(u8 Copy_u8SSGNum)
{
    1808:	df 93       	push	r29
    180a:	cf 93       	push	r28
    180c:	00 d0       	rcall	.+0      	; 0x180e <HexaDec_enuEnableSSG+0x6>
    180e:	cd b7       	in	r28, 0x3d	; 61
    1810:	de b7       	in	r29, 0x3e	; 62
    1812:	8a 83       	std	Y+2, r24	; 0x02
    ES_t Local_enuErrorState = ES_NOK;
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	89 83       	std	Y+1, r24	; 0x01

    if (Copy_u8SSGNum == SSG_RIGHT)
    1818:	8a 81       	ldd	r24, Y+2	; 0x02
    181a:	82 36       	cpi	r24, 0x62	; 98
    181c:	39 f4       	brne	.+14     	; 0x182c <HexaDec_enuEnableSSG+0x24>
    {
        Local_enuErrorState = DIO_enuSetPinValue(HEX_DEC_EN1_GRP , HEX_DEC_EN1_PIN , DIO_HIGH);
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	65 e0       	ldi	r22, 0x05	; 5
    1822:	41 e0       	ldi	r20, 0x01	; 1
    1824:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    1828:	89 83       	std	Y+1, r24	; 0x01
    182a:	0c c0       	rjmp	.+24     	; 0x1844 <HexaDec_enuEnableSSG+0x3c>
    }
    else if (Copy_u8SSGNum == SSG_LEFT)
    182c:	8a 81       	ldd	r24, Y+2	; 0x02
    182e:	8d 32       	cpi	r24, 0x2D	; 45
    1830:	39 f4       	brne	.+14     	; 0x1840 <HexaDec_enuEnableSSG+0x38>
    {
        Local_enuErrorState = DIO_enuSetPinValue(HEX_DEC_EN2_GRP , HEX_DEC_EN2_PIN , DIO_HIGH);
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	62 e0       	ldi	r22, 0x02	; 2
    1836:	41 e0       	ldi	r20, 0x01	; 1
    1838:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    183c:	89 83       	std	Y+1, r24	; 0x01
    183e:	02 c0       	rjmp	.+4      	; 0x1844 <HexaDec_enuEnableSSG+0x3c>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    1840:	82 e0       	ldi	r24, 0x02	; 2
    1842:	89 83       	std	Y+1, r24	; 0x01
    }

    return Local_enuErrorState;
    1844:	89 81       	ldd	r24, Y+1	; 0x01
}
    1846:	0f 90       	pop	r0
    1848:	0f 90       	pop	r0
    184a:	cf 91       	pop	r28
    184c:	df 91       	pop	r29
    184e:	08 95       	ret

00001850 <HexaDec_enuDisableSSG>:


ES_t HexaDec_enuDisableSSG(u8 Copy_u8SSGNum)
{
    1850:	df 93       	push	r29
    1852:	cf 93       	push	r28
    1854:	00 d0       	rcall	.+0      	; 0x1856 <HexaDec_enuDisableSSG+0x6>
    1856:	cd b7       	in	r28, 0x3d	; 61
    1858:	de b7       	in	r29, 0x3e	; 62
    185a:	8a 83       	std	Y+2, r24	; 0x02
    ES_t Local_enuErrorState = ES_NOK;
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	89 83       	std	Y+1, r24	; 0x01

    if (Copy_u8SSGNum == SSG_RIGHT)
    1860:	8a 81       	ldd	r24, Y+2	; 0x02
    1862:	82 36       	cpi	r24, 0x62	; 98
    1864:	39 f4       	brne	.+14     	; 0x1874 <HexaDec_enuDisableSSG+0x24>
    {
        Local_enuErrorState = DIO_enuSetPinValue(HEX_DEC_EN1_GRP , HEX_DEC_EN1_PIN , DIO_LOW);
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	65 e0       	ldi	r22, 0x05	; 5
    186a:	40 e0       	ldi	r20, 0x00	; 0
    186c:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    1870:	89 83       	std	Y+1, r24	; 0x01
    1872:	0c c0       	rjmp	.+24     	; 0x188c <HexaDec_enuDisableSSG+0x3c>
    }
    else if (Copy_u8SSGNum == SSG_LEFT)
    1874:	8a 81       	ldd	r24, Y+2	; 0x02
    1876:	8d 32       	cpi	r24, 0x2D	; 45
    1878:	39 f4       	brne	.+14     	; 0x1888 <HexaDec_enuDisableSSG+0x38>
    {
        Local_enuErrorState = DIO_enuSetPinValue(HEX_DEC_EN2_GRP , HEX_DEC_EN2_PIN , DIO_LOW);
    187a:	80 e0       	ldi	r24, 0x00	; 0
    187c:	62 e0       	ldi	r22, 0x02	; 2
    187e:	40 e0       	ldi	r20, 0x00	; 0
    1880:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    1884:	89 83       	std	Y+1, r24	; 0x01
    1886:	02 c0       	rjmp	.+4      	; 0x188c <HexaDec_enuDisableSSG+0x3c>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    1888:	82 e0       	ldi	r24, 0x02	; 2
    188a:	89 83       	std	Y+1, r24	; 0x01
    }
    
    return Local_enuErrorState;
    188c:	89 81       	ldd	r24, Y+1	; 0x01
}
    188e:	0f 90       	pop	r0
    1890:	0f 90       	pop	r0
    1892:	cf 91       	pop	r28
    1894:	df 91       	pop	r29
    1896:	08 95       	ret

00001898 <HexaDec_enuStopDisplay>:


ES_t HexaDec_enuStopDisplay(void)
{
    1898:	df 93       	push	r29
    189a:	cf 93       	push	r28
    189c:	0f 92       	push	r0
    189e:	cd b7       	in	r28, 0x3d	; 61
    18a0:	de b7       	in	r29, 0x3e	; 62
    ES_t Local_enuErrorState = ES_NOK;
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	89 83       	std	Y+1, r24	; 0x01

    DIO_enuSetPinValue(HEX_DEC_EN1_GRP , HEX_DEC_EN1_PIN , DIO_LOW);
    18a6:	81 e0       	ldi	r24, 0x01	; 1
    18a8:	65 e0       	ldi	r22, 0x05	; 5
    18aa:	40 e0       	ldi	r20, 0x00	; 0
    18ac:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    DIO_enuSetPinValue(HEX_DEC_EN2_GRP , HEX_DEC_EN2_PIN , DIO_LOW);
    18b0:	80 e0       	ldi	r24, 0x00	; 0
    18b2:	62 e0       	ldi	r22, 0x02	; 2
    18b4:	40 e0       	ldi	r20, 0x00	; 0
    18b6:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>

    return Local_enuErrorState;
    18ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    18bc:	0f 90       	pop	r0
    18be:	cf 91       	pop	r28
    18c0:	df 91       	pop	r29
    18c2:	08 95       	ret

000018c4 <Update_vidInit>:

static BOOL LOC_bDecFirstPress = FALSE;
static BOOL LOC_bDecHoldPress = FALSE;

void Update_vidInit(void)
{
    18c4:	df 93       	push	r29
    18c6:	cf 93       	push	r28
    18c8:	cd b7       	in	r28, 0x3d	; 61
    18ca:	de b7       	in	r29, 0x3e	; 62
	Switch_enuInit();
    18cc:	0e 94 c1 0a 	call	0x1582	; 0x1582 <Switch_enuInit>
}
    18d0:	cf 91       	pop	r28
    18d2:	df 91       	pop	r29
    18d4:	08 95       	ret

000018d6 <Update_vidIncreaseTask>:

void Update_vidIncreaseTask(void)
{
    18d6:	df 93       	push	r29
    18d8:	cf 93       	push	r28
    18da:	00 d0       	rcall	.+0      	; 0x18dc <Update_vidIncreaseTask+0x6>
    18dc:	cd b7       	in	r28, 0x3d	; 61
    18de:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8SwitchVal;
	Switch_enuGetSwitchState(SWITCH_BUTTON_0 , &Local_u8SwitchVal);
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	9e 01       	movw	r18, r28
    18e4:	2f 5f       	subi	r18, 0xFF	; 255
    18e6:	3f 4f       	sbci	r19, 0xFF	; 255
    18e8:	b9 01       	movw	r22, r18
    18ea:	0e 94 28 0b 	call	0x1650	; 0x1650 <Switch_enuGetSwitchState>
	if ((Local_u8SwitchVal == FALSE) && (LOC_bIncFirstPress == FALSE) )
    18ee:	89 81       	ldd	r24, Y+1	; 0x01
    18f0:	88 23       	and	r24, r24
    18f2:	41 f4       	brne	.+16     	; 0x1904 <Update_vidIncreaseTask+0x2e>
    18f4:	80 91 b1 00 	lds	r24, 0x00B1
    18f8:	88 23       	and	r24, r24
    18fa:	21 f4       	brne	.+8      	; 0x1904 <Update_vidIncreaseTask+0x2e>
	{
		LOC_bIncFirstPress = TRUE;
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	80 93 b1 00 	sts	0x00B1, r24
    1902:	2e c0       	rjmp	.+92     	; 0x1960 <Update_vidIncreaseTask+0x8a>
	}
	else if ((Local_u8SwitchVal == TRUE) && (LOC_bIncFirstPress == TRUE) && (LOC_bIncHoldPress == FALSE))
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	81 30       	cpi	r24, 0x01	; 1
    1908:	e1 f4       	brne	.+56     	; 0x1942 <Update_vidIncreaseTask+0x6c>
    190a:	80 91 b1 00 	lds	r24, 0x00B1
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	c1 f4       	brne	.+48     	; 0x1942 <Update_vidIncreaseTask+0x6c>
    1912:	80 91 b2 00 	lds	r24, 0x00B2
    1916:	88 23       	and	r24, r24
    1918:	a1 f4       	brne	.+40     	; 0x1942 <Update_vidIncreaseTask+0x6c>
	{
		LOC_u8SystemTime = (LOC_u8SystemTime < 99 )? (LOC_u8SystemTime + 1): (LOC_u8SystemTime);
    191a:	80 91 a5 00 	lds	r24, 0x00A5
    191e:	83 36       	cpi	r24, 0x63	; 99
    1920:	30 f4       	brcc	.+12     	; 0x192e <Update_vidIncreaseTask+0x58>
    1922:	80 91 a5 00 	lds	r24, 0x00A5
    1926:	98 2f       	mov	r25, r24
    1928:	9f 5f       	subi	r25, 0xFF	; 255
    192a:	9a 83       	std	Y+2, r25	; 0x02
    192c:	03 c0       	rjmp	.+6      	; 0x1934 <Update_vidIncreaseTask+0x5e>
    192e:	80 91 a5 00 	lds	r24, 0x00A5
    1932:	8a 83       	std	Y+2, r24	; 0x02
    1934:	9a 81       	ldd	r25, Y+2	; 0x02
    1936:	90 93 a5 00 	sts	0x00A5, r25
		LOC_bIncHoldPress = TRUE;
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	80 93 b2 00 	sts	0x00B2, r24
    1940:	0f c0       	rjmp	.+30     	; 0x1960 <Update_vidIncreaseTask+0x8a>
	}
	else if ((Local_u8SwitchVal == TRUE) && (LOC_bIncFirstPress == TRUE) && (LOC_bIncHoldPress == TRUE))
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	81 30       	cpi	r24, 0x01	; 1
    1946:	61 f4       	brne	.+24     	; 0x1960 <Update_vidIncreaseTask+0x8a>
    1948:	80 91 b1 00 	lds	r24, 0x00B1
    194c:	81 30       	cpi	r24, 0x01	; 1
    194e:	41 f4       	brne	.+16     	; 0x1960 <Update_vidIncreaseTask+0x8a>
    1950:	80 91 b2 00 	lds	r24, 0x00B2
    1954:	81 30       	cpi	r24, 0x01	; 1
    1956:	21 f4       	brne	.+8      	; 0x1960 <Update_vidIncreaseTask+0x8a>
	{
		LOC_bIncFirstPress = FALSE;
    1958:	10 92 b1 00 	sts	0x00B1, r1
		LOC_bIncHoldPress = FALSE;
    195c:	10 92 b2 00 	sts	0x00B2, r1
	{

	}
	

}
    1960:	0f 90       	pop	r0
    1962:	0f 90       	pop	r0
    1964:	cf 91       	pop	r28
    1966:	df 91       	pop	r29
    1968:	08 95       	ret

0000196a <Update_vidDecreaseTask>:

void Update_vidDecreaseTask(void)
{
    196a:	df 93       	push	r29
    196c:	cf 93       	push	r28
    196e:	00 d0       	rcall	.+0      	; 0x1970 <Update_vidDecreaseTask+0x6>
    1970:	cd b7       	in	r28, 0x3d	; 61
    1972:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8SwitchVal;
	Switch_enuGetSwitchState(SWITCH_BUTTON_1 , &Local_u8SwitchVal);
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	9e 01       	movw	r18, r28
    1978:	2f 5f       	subi	r18, 0xFF	; 255
    197a:	3f 4f       	sbci	r19, 0xFF	; 255
    197c:	b9 01       	movw	r22, r18
    197e:	0e 94 28 0b 	call	0x1650	; 0x1650 <Switch_enuGetSwitchState>
	if ((Local_u8SwitchVal == FALSE) && (LOC_bDecFirstPress == FALSE) )
    1982:	89 81       	ldd	r24, Y+1	; 0x01
    1984:	88 23       	and	r24, r24
    1986:	41 f4       	brne	.+16     	; 0x1998 <Update_vidDecreaseTask+0x2e>
    1988:	80 91 b3 00 	lds	r24, 0x00B3
    198c:	88 23       	and	r24, r24
    198e:	21 f4       	brne	.+8      	; 0x1998 <Update_vidDecreaseTask+0x2e>
	{
		LOC_bDecFirstPress = TRUE;
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	80 93 b3 00 	sts	0x00B3, r24
    1996:	2e c0       	rjmp	.+92     	; 0x19f4 <Update_vidDecreaseTask+0x8a>
	}
	else if ((Local_u8SwitchVal == TRUE) && (LOC_bDecFirstPress == TRUE) && (LOC_bDecHoldPress == FALSE))
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	81 30       	cpi	r24, 0x01	; 1
    199c:	e1 f4       	brne	.+56     	; 0x19d6 <Update_vidDecreaseTask+0x6c>
    199e:	80 91 b3 00 	lds	r24, 0x00B3
    19a2:	81 30       	cpi	r24, 0x01	; 1
    19a4:	c1 f4       	brne	.+48     	; 0x19d6 <Update_vidDecreaseTask+0x6c>
    19a6:	80 91 b4 00 	lds	r24, 0x00B4
    19aa:	88 23       	and	r24, r24
    19ac:	a1 f4       	brne	.+40     	; 0x19d6 <Update_vidDecreaseTask+0x6c>
	{
		LOC_u8SystemTime = (LOC_u8SystemTime > 15 )? (LOC_u8SystemTime - 1): (LOC_u8SystemTime);
    19ae:	80 91 a5 00 	lds	r24, 0x00A5
    19b2:	80 31       	cpi	r24, 0x10	; 16
    19b4:	30 f0       	brcs	.+12     	; 0x19c2 <Update_vidDecreaseTask+0x58>
    19b6:	80 91 a5 00 	lds	r24, 0x00A5
    19ba:	98 2f       	mov	r25, r24
    19bc:	91 50       	subi	r25, 0x01	; 1
    19be:	9a 83       	std	Y+2, r25	; 0x02
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <Update_vidDecreaseTask+0x5e>
    19c2:	80 91 a5 00 	lds	r24, 0x00A5
    19c6:	8a 83       	std	Y+2, r24	; 0x02
    19c8:	9a 81       	ldd	r25, Y+2	; 0x02
    19ca:	90 93 a5 00 	sts	0x00A5, r25
		LOC_bDecHoldPress = TRUE;
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	80 93 b4 00 	sts	0x00B4, r24
    19d4:	0f c0       	rjmp	.+30     	; 0x19f4 <Update_vidDecreaseTask+0x8a>
	}
	else if ((Local_u8SwitchVal == TRUE) && (LOC_bDecFirstPress == TRUE) && (LOC_bDecHoldPress == TRUE))
    19d6:	89 81       	ldd	r24, Y+1	; 0x01
    19d8:	81 30       	cpi	r24, 0x01	; 1
    19da:	61 f4       	brne	.+24     	; 0x19f4 <Update_vidDecreaseTask+0x8a>
    19dc:	80 91 b3 00 	lds	r24, 0x00B3
    19e0:	81 30       	cpi	r24, 0x01	; 1
    19e2:	41 f4       	brne	.+16     	; 0x19f4 <Update_vidDecreaseTask+0x8a>
    19e4:	80 91 b4 00 	lds	r24, 0x00B4
    19e8:	81 30       	cpi	r24, 0x01	; 1
    19ea:	21 f4       	brne	.+8      	; 0x19f4 <Update_vidDecreaseTask+0x8a>
	{
		LOC_bDecFirstPress = FALSE;
    19ec:	10 92 b3 00 	sts	0x00B3, r1
		LOC_bDecHoldPress = FALSE;
    19f0:	10 92 b4 00 	sts	0x00B4, r1
	}
	else
	{

	}
}
    19f4:	0f 90       	pop	r0
    19f6:	0f 90       	pop	r0
    19f8:	cf 91       	pop	r28
    19fa:	df 91       	pop	r29
    19fc:	08 95       	ret

000019fe <Update_vidSetTrafficTime>:

void Update_vidSetTrafficTime(u8 Copy_u8Time)
{
    19fe:	df 93       	push	r29
    1a00:	cf 93       	push	r28
    1a02:	0f 92       	push	r0
    1a04:	cd b7       	in	r28, 0x3d	; 61
    1a06:	de b7       	in	r29, 0x3e	; 62
    1a08:	89 83       	std	Y+1, r24	; 0x01
	if ((Copy_u8Time >= 15) && (Copy_u8Time <= 99))
    1a0a:	89 81       	ldd	r24, Y+1	; 0x01
    1a0c:	8f 30       	cpi	r24, 0x0F	; 15
    1a0e:	30 f0       	brcs	.+12     	; 0x1a1c <Update_vidSetTrafficTime+0x1e>
    1a10:	89 81       	ldd	r24, Y+1	; 0x01
    1a12:	84 36       	cpi	r24, 0x64	; 100
    1a14:	18 f4       	brcc	.+6      	; 0x1a1c <Update_vidSetTrafficTime+0x1e>
	{
		LOC_u8SystemTime = Copy_u8Time;
    1a16:	89 81       	ldd	r24, Y+1	; 0x01
    1a18:	80 93 a5 00 	sts	0x00A5, r24
	}
}
    1a1c:	0f 90       	pop	r0
    1a1e:	cf 91       	pop	r28
    1a20:	df 91       	pop	r29
    1a22:	08 95       	ret

00001a24 <Update_u8GetTrafficTime>:

u8 Update_u8GetTrafficTime(void)
{
    1a24:	df 93       	push	r29
    1a26:	cf 93       	push	r28
    1a28:	cd b7       	in	r28, 0x3d	; 61
    1a2a:	de b7       	in	r29, 0x3e	; 62
	return LOC_u8SystemTime;
    1a2c:	80 91 a5 00 	lds	r24, 0x00A5
}
    1a30:	cf 91       	pop	r28
    1a32:	df 91       	pop	r29
    1a34:	08 95       	ret

00001a36 <Update_bIsIncButtonReleased>:
BOOL Update_bIsIncButtonReleased(void)
{
    1a36:	df 93       	push	r29
    1a38:	cf 93       	push	r28
    1a3a:	0f 92       	push	r0
    1a3c:	cd b7       	in	r28, 0x3d	; 61
    1a3e:	de b7       	in	r29, 0x3e	; 62
	BOOL bFlag = FALSE;
    1a40:	19 82       	std	Y+1, r1	; 0x01
	if ((LOC_bIncFirstPress == FALSE) && (LOC_bIncHoldPress == FALSE))
    1a42:	80 91 b1 00 	lds	r24, 0x00B1
    1a46:	88 23       	and	r24, r24
    1a48:	31 f4       	brne	.+12     	; 0x1a56 <Update_bIsIncButtonReleased+0x20>
    1a4a:	80 91 b2 00 	lds	r24, 0x00B2
    1a4e:	88 23       	and	r24, r24
    1a50:	11 f4       	brne	.+4      	; 0x1a56 <Update_bIsIncButtonReleased+0x20>
	{
		bFlag = TRUE;
    1a52:	81 e0       	ldi	r24, 0x01	; 1
    1a54:	89 83       	std	Y+1, r24	; 0x01
	}
	return bFlag;
    1a56:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a58:	0f 90       	pop	r0
    1a5a:	cf 91       	pop	r28
    1a5c:	df 91       	pop	r29
    1a5e:	08 95       	ret

00001a60 <Update_bIsDecButtonReleased>:

BOOL Update_bIsDecButtonReleased(void)
{
    1a60:	df 93       	push	r29
    1a62:	cf 93       	push	r28
    1a64:	0f 92       	push	r0
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
	BOOL bFlag = FALSE;
    1a6a:	19 82       	std	Y+1, r1	; 0x01
	if ((LOC_bDecFirstPress == FALSE) && (LOC_bDecFirstPress == FALSE))
    1a6c:	80 91 b3 00 	lds	r24, 0x00B3
    1a70:	88 23       	and	r24, r24
    1a72:	31 f4       	brne	.+12     	; 0x1a80 <Update_bIsDecButtonReleased+0x20>
    1a74:	80 91 b3 00 	lds	r24, 0x00B3
    1a78:	88 23       	and	r24, r24
    1a7a:	11 f4       	brne	.+4      	; 0x1a80 <Update_bIsDecButtonReleased+0x20>
	{
		bFlag = TRUE;
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	89 83       	std	Y+1, r24	; 0x01
	}
	return bFlag;
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a82:	0f 90       	pop	r0
    1a84:	cf 91       	pop	r28
    1a86:	df 91       	pop	r29
    1a88:	08 95       	ret

00001a8a <Light_vidInit>:
static u8 LOC_u8SystemTime = 0;
static u16 LOC_u16TimeQualifier = 0;


void Light_vidInit(void)
{
    1a8a:	df 93       	push	r29
    1a8c:	cf 93       	push	r28
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
    DIO_enuSetPinDirection(GREEN_LED , DIO_OUTPUT);
    1a92:	80 e0       	ldi	r24, 0x00	; 0
    1a94:	64 e0       	ldi	r22, 0x04	; 4
    1a96:	41 e0       	ldi	r20, 0x01	; 1
    1a98:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    DIO_enuSetPinDirection(YELLOW_LED , DIO_OUTPUT);
    1a9c:	80 e0       	ldi	r24, 0x00	; 0
    1a9e:	66 e0       	ldi	r22, 0x06	; 6
    1aa0:	41 e0       	ldi	r20, 0x01	; 1
    1aa2:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    DIO_enuSetPinDirection(RED_LED , DIO_OUTPUT);
    1aa6:	81 e0       	ldi	r24, 0x01	; 1
    1aa8:	67 e0       	ldi	r22, 0x07	; 7
    1aaa:	41 e0       	ldi	r20, 0x01	; 1
    1aac:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
    
    DIO_enuSetPinValue(GREEN_LED , DIO_LOW);
    1ab0:	80 e0       	ldi	r24, 0x00	; 0
    1ab2:	64 e0       	ldi	r22, 0x04	; 4
    1ab4:	40 e0       	ldi	r20, 0x00	; 0
    1ab6:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    DIO_enuSetPinValue(YELLOW_LED , DIO_LOW);
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	66 e0       	ldi	r22, 0x06	; 6
    1abe:	40 e0       	ldi	r20, 0x00	; 0
    1ac0:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
    DIO_enuSetPinValue(RED_LED , DIO_LOW);
    1ac4:	81 e0       	ldi	r24, 0x01	; 1
    1ac6:	67 e0       	ldi	r22, 0x07	; 7
    1ac8:	40 e0       	ldi	r20, 0x00	; 0
    1aca:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>

}
    1ace:	cf 91       	pop	r28
    1ad0:	df 91       	pop	r29
    1ad2:	08 95       	ret

00001ad4 <Light_vidTrafficTask>:

void Light_vidTrafficTask(void)
{
    1ad4:	df 93       	push	r29
    1ad6:	cf 93       	push	r28
    1ad8:	00 d0       	rcall	.+0      	; 0x1ada <Light_vidTrafficTask+0x6>
    1ada:	cd b7       	in	r28, 0x3d	; 61
    1adc:	de b7       	in	r29, 0x3e	; 62
    switch (LOC_enuLightStateMachine)
    1ade:	80 91 b5 00 	lds	r24, 0x00B5
    1ae2:	28 2f       	mov	r18, r24
    1ae4:	30 e0       	ldi	r19, 0x00	; 0
    1ae6:	3a 83       	std	Y+2, r19	; 0x02
    1ae8:	29 83       	std	Y+1, r18	; 0x01
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	81 30       	cpi	r24, 0x01	; 1
    1af0:	91 05       	cpc	r25, r1
    1af2:	09 f4       	brne	.+2      	; 0x1af6 <Light_vidTrafficTask+0x22>
    1af4:	61 c0       	rjmp	.+194    	; 0x1bb8 <Light_vidTrafficTask+0xe4>
    1af6:	29 81       	ldd	r18, Y+1	; 0x01
    1af8:	3a 81       	ldd	r19, Y+2	; 0x02
    1afa:	22 30       	cpi	r18, 0x02	; 2
    1afc:	31 05       	cpc	r19, r1
    1afe:	09 f4       	brne	.+2      	; 0x1b02 <Light_vidTrafficTask+0x2e>
    1b00:	8a c0       	rjmp	.+276    	; 0x1c16 <Light_vidTrafficTask+0x142>
    1b02:	89 81       	ldd	r24, Y+1	; 0x01
    1b04:	9a 81       	ldd	r25, Y+2	; 0x02
    1b06:	00 97       	sbiw	r24, 0x00	; 0
    1b08:	09 f0       	breq	.+2      	; 0x1b0c <Light_vidTrafficTask+0x38>
    1b0a:	da c0       	rjmp	.+436    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
    {
    case LIGHT_GREEN:
        if (LOC_bOneTimeAccess == FALSE)
    1b0c:	80 91 b7 00 	lds	r24, 0x00B7
    1b10:	88 23       	and	r24, r24
    1b12:	49 f5       	brne	.+82     	; 0x1b66 <Light_vidTrafficTask+0x92>
        {
            DIO_enuSetPinValue(GREEN_LED , DIO_HIGH);
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	64 e0       	ldi	r22, 0x04	; 4
    1b18:	41 e0       	ldi	r20, 0x01	; 1
    1b1a:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            DIO_enuSetPinValue(YELLOW_LED , DIO_LOW);
    1b1e:	80 e0       	ldi	r24, 0x00	; 0
    1b20:	66 e0       	ldi	r22, 0x06	; 6
    1b22:	40 e0       	ldi	r20, 0x00	; 0
    1b24:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            DIO_enuSetPinValue(RED_LED , DIO_LOW);
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	67 e0       	ldi	r22, 0x07	; 7
    1b2c:	40 e0       	ldi	r20, 0x00	; 0
    1b2e:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            LOC_u8SystemTime = Update_u8GetTrafficTime();
    1b32:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <Update_u8GetTrafficTime>
    1b36:	80 93 b8 00 	sts	0x00B8, r24
            POV_vidSetDisplayedNumber(LOC_u8SystemTime);
    1b3a:	80 91 b8 00 	lds	r24, 0x00B8
    1b3e:	0e 94 90 10 	call	0x2120	; 0x2120 <POV_vidSetDisplayedNumber>
            LOC_u16TimeQualifier = ((LOC_u8SystemTime - 3) * 4) - 1 ;
    1b42:	80 91 b8 00 	lds	r24, 0x00B8
    1b46:	88 2f       	mov	r24, r24
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	03 97       	sbiw	r24, 0x03	; 3
    1b4c:	88 0f       	add	r24, r24
    1b4e:	99 1f       	adc	r25, r25
    1b50:	88 0f       	add	r24, r24
    1b52:	99 1f       	adc	r25, r25
    1b54:	01 97       	sbiw	r24, 0x01	; 1
    1b56:	90 93 ba 00 	sts	0x00BA, r25
    1b5a:	80 93 b9 00 	sts	0x00B9, r24

            LOC_bOneTimeAccess = TRUE;
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	80 93 b7 00 	sts	0x00B7, r24
    1b64:	ad c0       	rjmp	.+346    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
        }
        else
        {
            LOC_u16TimeQualifier--;
    1b66:	80 91 b9 00 	lds	r24, 0x00B9
    1b6a:	90 91 ba 00 	lds	r25, 0x00BA
    1b6e:	01 97       	sbiw	r24, 0x01	; 1
    1b70:	90 93 ba 00 	sts	0x00BA, r25
    1b74:	80 93 b9 00 	sts	0x00B9, r24
            POV_vidSetDisplayedNumber((LOC_u16TimeQualifier+12+1+3)/4);
    1b78:	80 91 b9 00 	lds	r24, 0x00B9
    1b7c:	90 91 ba 00 	lds	r25, 0x00BA
    1b80:	40 96       	adiw	r24, 0x10	; 16
    1b82:	96 95       	lsr	r25
    1b84:	87 95       	ror	r24
    1b86:	96 95       	lsr	r25
    1b88:	87 95       	ror	r24
    1b8a:	0e 94 90 10 	call	0x2120	; 0x2120 <POV_vidSetDisplayedNumber>
            if (LOC_u16TimeQualifier == 0)
    1b8e:	80 91 b9 00 	lds	r24, 0x00B9
    1b92:	90 91 ba 00 	lds	r25, 0x00BA
    1b96:	00 97       	sbiw	r24, 0x00	; 0
    1b98:	09 f0       	breq	.+2      	; 0x1b9c <Light_vidTrafficTask+0xc8>
    1b9a:	92 c0       	rjmp	.+292    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            {
                LOC_bOneTimeAccess = FALSE;
    1b9c:	10 92 b7 00 	sts	0x00B7, r1
                LOC_enuPrevLightStateMachine = LIGHT_GREEN;
    1ba0:	10 92 b6 00 	sts	0x00B6, r1
                LOC_enuLightStateMachine = LIGHT_YELLOW;
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	80 93 b5 00 	sts	0x00B5, r24
                LOC_u16TimeQualifier = 11;
    1baa:	8b e0       	ldi	r24, 0x0B	; 11
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	90 93 ba 00 	sts	0x00BA, r25
    1bb2:	80 93 b9 00 	sts	0x00B9, r24
    1bb6:	84 c0       	rjmp	.+264    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            }
        }
        break;
    case LIGHT_YELLOW:
        LOC_u16TimeQualifier--;
    1bb8:	80 91 b9 00 	lds	r24, 0x00B9
    1bbc:	90 91 ba 00 	lds	r25, 0x00BA
    1bc0:	01 97       	sbiw	r24, 0x01	; 1
    1bc2:	90 93 ba 00 	sts	0x00BA, r25
    1bc6:	80 93 b9 00 	sts	0x00B9, r24
        
        DIO_enuTogglePinValue(YELLOW_LED);
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	66 e0       	ldi	r22, 0x06	; 6
    1bce:	0e 94 95 09 	call	0x132a	; 0x132a <DIO_enuTogglePinValue>
        POV_vidSetDisplayedNumber((LOC_u16TimeQualifier+3)/4);
    1bd2:	80 91 b9 00 	lds	r24, 0x00B9
    1bd6:	90 91 ba 00 	lds	r25, 0x00BA
    1bda:	03 96       	adiw	r24, 0x03	; 3
    1bdc:	96 95       	lsr	r25
    1bde:	87 95       	ror	r24
    1be0:	96 95       	lsr	r25
    1be2:	87 95       	ror	r24
    1be4:	0e 94 90 10 	call	0x2120	; 0x2120 <POV_vidSetDisplayedNumber>

        if (LOC_u16TimeQualifier == 0 )
    1be8:	80 91 b9 00 	lds	r24, 0x00B9
    1bec:	90 91 ba 00 	lds	r25, 0x00BA
    1bf0:	00 97       	sbiw	r24, 0x00	; 0
    1bf2:	09 f0       	breq	.+2      	; 0x1bf6 <Light_vidTrafficTask+0x122>
    1bf4:	65 c0       	rjmp	.+202    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
        {
            if (LOC_enuPrevLightStateMachine == LIGHT_GREEN)
    1bf6:	80 91 b6 00 	lds	r24, 0x00B6
    1bfa:	88 23       	and	r24, r24
    1bfc:	21 f4       	brne	.+8      	; 0x1c06 <Light_vidTrafficTask+0x132>
            {
                LOC_enuLightStateMachine = LIGHT_RED;
    1bfe:	82 e0       	ldi	r24, 0x02	; 2
    1c00:	80 93 b5 00 	sts	0x00B5, r24
    1c04:	5d c0       	rjmp	.+186    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            } 
            else if (LOC_enuPrevLightStateMachine == LIGHT_RED)
    1c06:	80 91 b6 00 	lds	r24, 0x00B6
    1c0a:	82 30       	cpi	r24, 0x02	; 2
    1c0c:	09 f0       	breq	.+2      	; 0x1c10 <Light_vidTrafficTask+0x13c>
    1c0e:	58 c0       	rjmp	.+176    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            {
                LOC_enuLightStateMachine = LIGHT_GREEN;
    1c10:	10 92 b5 00 	sts	0x00B5, r1
    1c14:	55 c0       	rjmp	.+170    	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            else
            {}  
        }
        break;
    case LIGHT_RED:
        if (LOC_bOneTimeAccess == FALSE)
    1c16:	80 91 b7 00 	lds	r24, 0x00B7
    1c1a:	88 23       	and	r24, r24
    1c1c:	49 f5       	brne	.+82     	; 0x1c70 <Light_vidTrafficTask+0x19c>
        {
            DIO_enuSetPinValue(GREEN_LED , DIO_LOW);
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	64 e0       	ldi	r22, 0x04	; 4
    1c22:	40 e0       	ldi	r20, 0x00	; 0
    1c24:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            DIO_enuSetPinValue(YELLOW_LED , DIO_LOW);
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	66 e0       	ldi	r22, 0x06	; 6
    1c2c:	40 e0       	ldi	r20, 0x00	; 0
    1c2e:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            DIO_enuSetPinValue(RED_LED , DIO_HIGH);
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	67 e0       	ldi	r22, 0x07	; 7
    1c36:	41 e0       	ldi	r20, 0x01	; 1
    1c38:	0e 94 97 08 	call	0x112e	; 0x112e <DIO_enuSetPinValue>
            LOC_u8SystemTime = Update_u8GetTrafficTime();
    1c3c:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <Update_u8GetTrafficTime>
    1c40:	80 93 b8 00 	sts	0x00B8, r24
            POV_vidSetDisplayedNumber(LOC_u8SystemTime);
    1c44:	80 91 b8 00 	lds	r24, 0x00B8
    1c48:	0e 94 90 10 	call	0x2120	; 0x2120 <POV_vidSetDisplayedNumber>

            LOC_u16TimeQualifier = ((LOC_u8SystemTime - 3) * 4) -1 ;
    1c4c:	80 91 b8 00 	lds	r24, 0x00B8
    1c50:	88 2f       	mov	r24, r24
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	03 97       	sbiw	r24, 0x03	; 3
    1c56:	88 0f       	add	r24, r24
    1c58:	99 1f       	adc	r25, r25
    1c5a:	88 0f       	add	r24, r24
    1c5c:	99 1f       	adc	r25, r25
    1c5e:	01 97       	sbiw	r24, 0x01	; 1
    1c60:	90 93 ba 00 	sts	0x00BA, r25
    1c64:	80 93 b9 00 	sts	0x00B9, r24

            LOC_bOneTimeAccess = TRUE;
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	80 93 b7 00 	sts	0x00B7, r24
    1c6e:	28 c0       	rjmp	.+80     	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
        }
        else
        {
            LOC_u16TimeQualifier--;
    1c70:	80 91 b9 00 	lds	r24, 0x00B9
    1c74:	90 91 ba 00 	lds	r25, 0x00BA
    1c78:	01 97       	sbiw	r24, 0x01	; 1
    1c7a:	90 93 ba 00 	sts	0x00BA, r25
    1c7e:	80 93 b9 00 	sts	0x00B9, r24
            POV_vidSetDisplayedNumber((LOC_u16TimeQualifier+16)/4);
    1c82:	80 91 b9 00 	lds	r24, 0x00B9
    1c86:	90 91 ba 00 	lds	r25, 0x00BA
    1c8a:	40 96       	adiw	r24, 0x10	; 16
    1c8c:	96 95       	lsr	r25
    1c8e:	87 95       	ror	r24
    1c90:	96 95       	lsr	r25
    1c92:	87 95       	ror	r24
    1c94:	0e 94 90 10 	call	0x2120	; 0x2120 <POV_vidSetDisplayedNumber>
            if (LOC_u16TimeQualifier == 0)
    1c98:	80 91 b9 00 	lds	r24, 0x00B9
    1c9c:	90 91 ba 00 	lds	r25, 0x00BA
    1ca0:	00 97       	sbiw	r24, 0x00	; 0
    1ca2:	71 f4       	brne	.+28     	; 0x1cc0 <Light_vidTrafficTask+0x1ec>
            {
                LOC_bOneTimeAccess = FALSE;
    1ca4:	10 92 b7 00 	sts	0x00B7, r1
                LOC_enuPrevLightStateMachine = LIGHT_RED;
    1ca8:	82 e0       	ldi	r24, 0x02	; 2
    1caa:	80 93 b6 00 	sts	0x00B6, r24
                LOC_enuLightStateMachine = LIGHT_YELLOW;
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	80 93 b5 00 	sts	0x00B5, r24
                LOC_u16TimeQualifier = 12;
    1cb4:	8c e0       	ldi	r24, 0x0C	; 12
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	90 93 ba 00 	sts	0x00BA, r25
    1cbc:	80 93 b9 00 	sts	0x00B9, r24
        }
        break;
    default:
        break;
    }
}
    1cc0:	0f 90       	pop	r0
    1cc2:	0f 90       	pop	r0
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <Project_vidInit>:

// static void vidReceivingTask (void);
static BOOL bStringCompare(const char * s1 , const char * s2);

void Project_vidInit(void)
{
    1cca:	df 93       	push	r29
    1ccc:	cf 93       	push	r28
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
	POV_enuInit();
    1cd2:	0e 94 23 10 	call	0x2046	; 0x2046 <POV_enuInit>
	Light_vidInit();
    1cd6:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <Light_vidInit>
	Update_vidInit();
    1cda:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <Update_vidInit>
	DIO_enuSetPinDirection(DIO_GROUP_D, DIO_PIN_0, DIO_INPUT);
    1cde:	83 e0       	ldi	r24, 0x03	; 3
    1ce0:	60 e0       	ldi	r22, 0x00	; 0
    1ce2:	40 e0       	ldi	r20, 0x00	; 0
    1ce4:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
	DIO_enuSetPinDirection(DIO_GROUP_D, DIO_PIN_1, DIO_OUTPUT);
    1ce8:	83 e0       	ldi	r24, 0x03	; 3
    1cea:	61 e0       	ldi	r22, 0x01	; 1
    1cec:	41 e0       	ldi	r20, 0x01	; 1
    1cee:	0e 94 ab 07 	call	0xf56	; 0xf56 <DIO_enuSetPinDirection>
	UART_enuInit();
    1cf2:	0e 94 a3 05 	call	0xb46	; 0xb46 <UART_enuInit>
	// UART_enuSetRxCallBack(vidReceivingTask);

	vSemaphoreCreateBinary(LOC_smphrMaskHoldPress,1);
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	60 e0       	ldi	r22, 0x00	; 0
    1cfa:	43 e0       	ldi	r20, 0x03	; 3
    1cfc:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <xQueueGenericCreate>
    1d00:	90 93 c6 00 	sts	0x00C6, r25
    1d04:	80 93 c5 00 	sts	0x00C5, r24
    1d08:	80 91 c5 00 	lds	r24, 0x00C5
    1d0c:	90 91 c6 00 	lds	r25, 0x00C6
    1d10:	00 97       	sbiw	r24, 0x00	; 0
    1d12:	59 f0       	breq	.+22     	; 0x1d2a <Project_vidInit+0x60>
    1d14:	80 91 c5 00 	lds	r24, 0x00C5
    1d18:	90 91 c6 00 	lds	r25, 0x00C6
    1d1c:	60 e0       	ldi	r22, 0x00	; 0
    1d1e:	70 e0       	ldi	r23, 0x00	; 0
    1d20:	40 e0       	ldi	r20, 0x00	; 0
    1d22:	50 e0       	ldi	r21, 0x00	; 0
    1d24:	20 e0       	ldi	r18, 0x00	; 0
    1d26:	0e 94 20 20 	call	0x4040	; 0x4040 <xQueueGenericSend>
	vSemaphoreCreateBinary(LOC_smphrReceiveComplete,0);
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	60 e0       	ldi	r22, 0x00	; 0
    1d2e:	43 e0       	ldi	r20, 0x03	; 3
    1d30:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <xQueueGenericCreate>
    1d34:	90 93 c8 00 	sts	0x00C8, r25
    1d38:	80 93 c7 00 	sts	0x00C7, r24
	LOC_qFirstQueue = xQueueCreate(7,1);
    1d3c:	87 e0       	ldi	r24, 0x07	; 7
    1d3e:	61 e0       	ldi	r22, 0x01	; 1
    1d40:	40 e0       	ldi	r20, 0x00	; 0
    1d42:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <xQueueGenericCreate>
    1d46:	90 93 ca 00 	sts	0x00CA, r25
    1d4a:	80 93 c9 00 	sts	0x00C9, r24
	// LOC_egReceiveComplete = xEventGroupCreate();
}
    1d4e:	cf 91       	pop	r28
    1d50:	df 91       	pop	r29
    1d52:	08 95       	ret

00001d54 <Project_vidDisplayTask>:

void Project_vidDisplayTask(void*pv)
{
    1d54:	df 93       	push	r29
    1d56:	cf 93       	push	r28
    1d58:	00 d0       	rcall	.+0      	; 0x1d5a <Project_vidDisplayTask+0x6>
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
    1d5e:	9a 83       	std	Y+2, r25	; 0x02
    1d60:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		POV_vidDisplayTask();
    1d62:	0e 94 2c 10 	call	0x2058	; 0x2058 <POV_vidDisplayTask>
		vTaskDelay(1);
    1d66:	81 e0       	ldi	r24, 0x01	; 1
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    1d6e:	f9 cf       	rjmp	.-14     	; 0x1d62 <Project_vidDisplayTask+0xe>

00001d70 <Project_vidLight>:
	}
}

void Project_vidLight(void*pv)
{
    1d70:	df 93       	push	r29
    1d72:	cf 93       	push	r28
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <Project_vidLight+0x6>
    1d76:	cd b7       	in	r28, 0x3d	; 61
    1d78:	de b7       	in	r29, 0x3e	; 62
    1d7a:	9a 83       	std	Y+2, r25	; 0x02
    1d7c:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		Light_vidTrafficTask();
    1d7e:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <Light_vidTrafficTask>
		vTaskDelay(50);
    1d82:	82 e3       	ldi	r24, 0x32	; 50
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    1d8a:	f9 cf       	rjmp	.-14     	; 0x1d7e <Project_vidLight+0xe>

00001d8c <Project_vidIncrease>:
	}
}

void Project_vidIncrease(void*pv)
{
    1d8c:	df 93       	push	r29
    1d8e:	cf 93       	push	r28
    1d90:	00 d0       	rcall	.+0      	; 0x1d92 <Project_vidIncrease+0x6>
    1d92:	0f 92       	push	r0
    1d94:	cd b7       	in	r28, 0x3d	; 61
    1d96:	de b7       	in	r29, 0x3e	; 62
    1d98:	9b 83       	std	Y+3, r25	; 0x03
    1d9a:	8a 83       	std	Y+2, r24	; 0x02
	BOOL bIsSemaphoreTaken = FALSE;
    1d9c:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if (pdPASS == xSemaphoreTake(LOC_smphrMaskHoldPress , 1))
    1d9e:	80 91 c5 00 	lds	r24, 0x00C5
    1da2:	90 91 c6 00 	lds	r25, 0x00C6
    1da6:	60 e0       	ldi	r22, 0x00	; 0
    1da8:	70 e0       	ldi	r23, 0x00	; 0
    1daa:	41 e0       	ldi	r20, 0x01	; 1
    1dac:	50 e0       	ldi	r21, 0x00	; 0
    1dae:	20 e0       	ldi	r18, 0x00	; 0
    1db0:	0e 94 2e 21 	call	0x425c	; 0x425c <xQueueGenericReceive>
    1db4:	81 30       	cpi	r24, 0x01	; 1
    1db6:	11 f4       	brne	.+4      	; 0x1dbc <Project_vidIncrease+0x30>
		{
			bIsSemaphoreTaken = TRUE;
    1db8:	81 e0       	ldi	r24, 0x01	; 1
    1dba:	89 83       	std	Y+1, r24	; 0x01
		}
		if ((bIsSemaphoreTaken == TRUE) && (LOC_bIsUARTReceivingStart == FALSE))//(NOTHING_RECEIVED == xEventGroupGetBits(LOC_egReceiveComplete)))
    1dbc:	89 81       	ldd	r24, Y+1	; 0x01
    1dbe:	81 30       	cpi	r24, 0x01	; 1
    1dc0:	31 f4       	brne	.+12     	; 0x1dce <Project_vidIncrease+0x42>
    1dc2:	80 91 c4 00 	lds	r24, 0x00C4
    1dc6:	88 23       	and	r24, r24
    1dc8:	11 f4       	brne	.+4      	; 0x1dce <Project_vidIncrease+0x42>
		{
			Update_vidIncreaseTask();
    1dca:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <Update_vidIncreaseTask>
		}
		if (TRUE == Update_bIsDecButtonReleased())
    1dce:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <Update_bIsDecButtonReleased>
    1dd2:	81 30       	cpi	r24, 0x01	; 1
    1dd4:	61 f4       	brne	.+24     	; 0x1dee <Project_vidIncrease+0x62>
		{
			bIsSemaphoreTaken = FALSE;
    1dd6:	19 82       	std	Y+1, r1	; 0x01
			xSemaphoreGive(LOC_smphrMaskHoldPress);
    1dd8:	80 91 c5 00 	lds	r24, 0x00C5
    1ddc:	90 91 c6 00 	lds	r25, 0x00C6
    1de0:	60 e0       	ldi	r22, 0x00	; 0
    1de2:	70 e0       	ldi	r23, 0x00	; 0
    1de4:	40 e0       	ldi	r20, 0x00	; 0
    1de6:	50 e0       	ldi	r21, 0x00	; 0
    1de8:	20 e0       	ldi	r18, 0x00	; 0
    1dea:	0e 94 20 20 	call	0x4040	; 0x4040 <xQueueGenericSend>
		}
		vTaskDelay(2);
    1dee:	82 e0       	ldi	r24, 0x02	; 2
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    1df6:	d3 cf       	rjmp	.-90     	; 0x1d9e <Project_vidIncrease+0x12>

00001df8 <Project_vidDecrease>:
	}
}

void Project_vidDecrease(void*pv)
{
    1df8:	df 93       	push	r29
    1dfa:	cf 93       	push	r28
    1dfc:	00 d0       	rcall	.+0      	; 0x1dfe <Project_vidDecrease+0x6>
    1dfe:	00 d0       	rcall	.+0      	; 0x1e00 <Project_vidDecrease+0x8>
    1e00:	cd b7       	in	r28, 0x3d	; 61
    1e02:	de b7       	in	r29, 0x3e	; 62
    1e04:	9c 83       	std	Y+4, r25	; 0x04
    1e06:	8b 83       	std	Y+3, r24	; 0x03
	u8 i=0;
    1e08:	1a 82       	std	Y+2, r1	; 0x02
	BOOL bIsSemaphoreTaken = FALSE;
    1e0a:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		*((u8*)0x43)= i;
    1e0c:	e3 e4       	ldi	r30, 0x43	; 67
    1e0e:	f0 e0       	ldi	r31, 0x00	; 0
    1e10:	8a 81       	ldd	r24, Y+2	; 0x02
    1e12:	80 83       	st	Z, r24
		if (pdPASS == xSemaphoreTake(LOC_smphrMaskHoldPress , 1))
    1e14:	80 91 c5 00 	lds	r24, 0x00C5
    1e18:	90 91 c6 00 	lds	r25, 0x00C6
    1e1c:	60 e0       	ldi	r22, 0x00	; 0
    1e1e:	70 e0       	ldi	r23, 0x00	; 0
    1e20:	41 e0       	ldi	r20, 0x01	; 1
    1e22:	50 e0       	ldi	r21, 0x00	; 0
    1e24:	20 e0       	ldi	r18, 0x00	; 0
    1e26:	0e 94 2e 21 	call	0x425c	; 0x425c <xQueueGenericReceive>
    1e2a:	81 30       	cpi	r24, 0x01	; 1
    1e2c:	11 f4       	brne	.+4      	; 0x1e32 <Project_vidDecrease+0x3a>
		{
			bIsSemaphoreTaken = TRUE;
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	89 83       	std	Y+1, r24	; 0x01
		}
		if ((bIsSemaphoreTaken == TRUE) && (LOC_bIsUARTReceivingStart == FALSE))//(NOTHING_RECEIVED == xEventGroupGetBits(LOC_egReceiveComplete)))
    1e32:	89 81       	ldd	r24, Y+1	; 0x01
    1e34:	81 30       	cpi	r24, 0x01	; 1
    1e36:	31 f4       	brne	.+12     	; 0x1e44 <Project_vidDecrease+0x4c>
    1e38:	80 91 c4 00 	lds	r24, 0x00C4
    1e3c:	88 23       	and	r24, r24
    1e3e:	11 f4       	brne	.+4      	; 0x1e44 <Project_vidDecrease+0x4c>
		{
			Update_vidDecreaseTask();
    1e40:	0e 94 b5 0c 	call	0x196a	; 0x196a <Update_vidDecreaseTask>
		}
		if (TRUE == Update_bIsIncButtonReleased())
    1e44:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <Update_bIsIncButtonReleased>
    1e48:	81 30       	cpi	r24, 0x01	; 1
    1e4a:	79 f4       	brne	.+30     	; 0x1e6a <Project_vidDecrease+0x72>
		{
			i++;
    1e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e4e:	8f 5f       	subi	r24, 0xFF	; 255
    1e50:	8a 83       	std	Y+2, r24	; 0x02
			bIsSemaphoreTaken = FALSE;
    1e52:	19 82       	std	Y+1, r1	; 0x01
			xSemaphoreGive(LOC_smphrMaskHoldPress);
    1e54:	80 91 c5 00 	lds	r24, 0x00C5
    1e58:	90 91 c6 00 	lds	r25, 0x00C6
    1e5c:	60 e0       	ldi	r22, 0x00	; 0
    1e5e:	70 e0       	ldi	r23, 0x00	; 0
    1e60:	40 e0       	ldi	r20, 0x00	; 0
    1e62:	50 e0       	ldi	r21, 0x00	; 0
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	0e 94 20 20 	call	0x4040	; 0x4040 <xQueueGenericSend>
		}
		vTaskDelay(2);
    1e6a:	82 e0       	ldi	r24, 0x02	; 2
    1e6c:	90 e0       	ldi	r25, 0x00	; 0
    1e6e:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    1e72:	cc cf       	rjmp	.-104    	; 0x1e0c <Project_vidDecrease+0x14>

00001e74 <Project_vidUpdateByUART>:
	}
}

void Project_vidUpdateByUART(void*pv)
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <Project_vidUpdateByUART+0x6>
    1e7a:	0f 92       	push	r0
    1e7c:	cd b7       	in	r28, 0x3d	; 61
    1e7e:	de b7       	in	r29, 0x3e	; 62
    1e80:	9b 83       	std	Y+3, r25	; 0x03
    1e82:	8a 83       	std	Y+2, r24	; 0x02
	while(1)
	{
		if (pdPASS == xSemaphoreTake(LOC_smphrReceiveComplete,1))
    1e84:	80 91 c7 00 	lds	r24, 0x00C7
    1e88:	90 91 c8 00 	lds	r25, 0x00C8
    1e8c:	60 e0       	ldi	r22, 0x00	; 0
    1e8e:	70 e0       	ldi	r23, 0x00	; 0
    1e90:	41 e0       	ldi	r20, 0x01	; 1
    1e92:	50 e0       	ldi	r21, 0x00	; 0
    1e94:	20 e0       	ldi	r18, 0x00	; 0
    1e96:	0e 94 2e 21 	call	0x425c	; 0x425c <xQueueGenericReceive>
    1e9a:	81 30       	cpi	r24, 0x01	; 1
    1e9c:	09 f0       	breq	.+2      	; 0x1ea0 <Project_vidUpdateByUART+0x2c>
    1e9e:	42 c0       	rjmp	.+132    	; 0x1f24 <Project_vidUpdateByUART+0xb0>
		{
			for(u8 i=0 ; i<8;i++)
    1ea0:	19 82       	std	Y+1, r1	; 0x01
    1ea2:	14 c0       	rjmp	.+40     	; 0x1ecc <Project_vidUpdateByUART+0x58>
				xQueueReceive(LOC_qFirstQueue,LOC_acReceivedBuffer+i,1);
    1ea4:	40 91 c9 00 	lds	r20, 0x00C9
    1ea8:	50 91 ca 00 	lds	r21, 0x00CA
    1eac:	89 81       	ldd	r24, Y+1	; 0x01
    1eae:	88 2f       	mov	r24, r24
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	9c 01       	movw	r18, r24
    1eb4:	25 54       	subi	r18, 0x45	; 69
    1eb6:	3f 4f       	sbci	r19, 0xFF	; 255
    1eb8:	ca 01       	movw	r24, r20
    1eba:	b9 01       	movw	r22, r18
    1ebc:	41 e0       	ldi	r20, 0x01	; 1
    1ebe:	50 e0       	ldi	r21, 0x00	; 0
    1ec0:	20 e0       	ldi	r18, 0x00	; 0
    1ec2:	0e 94 2e 21 	call	0x425c	; 0x425c <xQueueGenericReceive>
{
	while(1)
	{
		if (pdPASS == xSemaphoreTake(LOC_smphrReceiveComplete,1))
		{
			for(u8 i=0 ; i<8;i++)
    1ec6:	89 81       	ldd	r24, Y+1	; 0x01
    1ec8:	8f 5f       	subi	r24, 0xFF	; 255
    1eca:	89 83       	std	Y+1, r24	; 0x01
    1ecc:	89 81       	ldd	r24, Y+1	; 0x01
    1ece:	88 30       	cpi	r24, 0x08	; 8
    1ed0:	48 f3       	brcs	.-46     	; 0x1ea4 <Project_vidUpdateByUART+0x30>
				xQueueReceive(LOC_qFirstQueue,LOC_acReceivedBuffer+i,1);
//			xEventGroupClearBits(LOC_egReceiveComplete , RECEIVING_IN_FIRST);
			LOC_bIsUARTReceivingStart = FALSE;
    1ed2:	10 92 c4 00 	sts	0x00C4, r1
			if (bStringCompare((const char*)LOC_acReceivedBuffer ,"Time="))
    1ed6:	8b eb       	ldi	r24, 0xBB	; 187
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	20 e6       	ldi	r18, 0x60	; 96
    1edc:	30 e0       	ldi	r19, 0x00	; 0
    1ede:	b9 01       	movw	r22, r18
    1ee0:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <bStringCompare>
    1ee4:	88 23       	and	r24, r24
    1ee6:	d1 f0       	breq	.+52     	; 0x1f1c <Project_vidUpdateByUART+0xa8>
			{
				Update_vidSetTrafficTime(((LOC_acReceivedBuffer[5]-48)*10) + (LOC_acReceivedBuffer[6]-48) );
    1ee8:	80 91 c0 00 	lds	r24, 0x00C0
    1eec:	88 2f       	mov	r24, r24
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	9c 01       	movw	r18, r24
    1ef2:	22 0f       	add	r18, r18
    1ef4:	33 1f       	adc	r19, r19
    1ef6:	c9 01       	movw	r24, r18
    1ef8:	88 0f       	add	r24, r24
    1efa:	99 1f       	adc	r25, r25
    1efc:	88 0f       	add	r24, r24
    1efe:	99 1f       	adc	r25, r25
    1f00:	82 0f       	add	r24, r18
    1f02:	93 1f       	adc	r25, r19
    1f04:	98 2f       	mov	r25, r24
    1f06:	80 91 c1 00 	lds	r24, 0x00C1
    1f0a:	89 0f       	add	r24, r25
    1f0c:	80 51       	subi	r24, 0x10	; 16
    1f0e:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <Update_vidSetTrafficTime>
				UART_enuSendString("\r\nDone");
    1f12:	86 e6       	ldi	r24, 0x66	; 102
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	0e 94 32 07 	call	0xe64	; 0xe64 <UART_enuSendString>
    1f1a:	04 c0       	rjmp	.+8      	; 0x1f24 <Project_vidUpdateByUART+0xb0>
			}
			else
			{
				UART_enuSendString("\r\nError");
    1f1c:	8d e6       	ldi	r24, 0x6D	; 109
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	0e 94 32 07 	call	0xe64	; 0xe64 <UART_enuSendString>
			}
		}
		vTaskDelay(5);
    1f24:	85 e0       	ldi	r24, 0x05	; 5
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    1f2c:	ab cf       	rjmp	.-170    	; 0x1e84 <Project_vidUpdateByUART+0x10>

00001f2e <__vector_13>:


// static void vidReceivingTask (void)
void __vector_13 (void)__attribute__((signal));
void __vector_13 (void)
{
    1f2e:	1f 92       	push	r1
    1f30:	0f 92       	push	r0
    1f32:	0f b6       	in	r0, 0x3f	; 63
    1f34:	0f 92       	push	r0
    1f36:	11 24       	eor	r1, r1
    1f38:	2f 93       	push	r18
    1f3a:	3f 93       	push	r19
    1f3c:	4f 93       	push	r20
    1f3e:	5f 93       	push	r21
    1f40:	6f 93       	push	r22
    1f42:	7f 93       	push	r23
    1f44:	8f 93       	push	r24
    1f46:	9f 93       	push	r25
    1f48:	af 93       	push	r26
    1f4a:	bf 93       	push	r27
    1f4c:	ef 93       	push	r30
    1f4e:	ff 93       	push	r31
    1f50:	df 93       	push	r29
    1f52:	cf 93       	push	r28
    1f54:	0f 92       	push	r0
    1f56:	cd b7       	in	r28, 0x3d	; 61
    1f58:	de b7       	in	r29, 0x3e	; 62
	char cData = UART_u8GetRxBufferFromISR();
    1f5a:	0e 94 76 06 	call	0xcec	; 0xcec <UART_u8GetRxBufferFromISR>
    1f5e:	89 83       	std	Y+1, r24	; 0x01

	// xEventGroupSetBits(LOC_egReceiveComplete , RECEIVING_IN_FIRST);
	LOC_bIsUARTReceivingStart = TRUE;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	80 93 c4 00 	sts	0x00C4, r24

	UART_enuSendChar((u8)cData);
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <UART_enuSendChar>

	if(cData != '\r')
    1f6c:	89 81       	ldd	r24, Y+1	; 0x01
    1f6e:	8d 30       	cpi	r24, 0x0D	; 13
    1f70:	71 f0       	breq	.+28     	; 0x1f8e <__vector_13+0x60>
	{
		xQueueSendFromISR(LOC_qFirstQueue,&cData,NULL);
    1f72:	80 91 c9 00 	lds	r24, 0x00C9
    1f76:	90 91 ca 00 	lds	r25, 0x00CA
    1f7a:	9e 01       	movw	r18, r28
    1f7c:	2f 5f       	subi	r18, 0xFF	; 255
    1f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f80:	b9 01       	movw	r22, r18
    1f82:	40 e0       	ldi	r20, 0x00	; 0
    1f84:	50 e0       	ldi	r21, 0x00	; 0
    1f86:	20 e0       	ldi	r18, 0x00	; 0
    1f88:	0e 94 cc 20 	call	0x4198	; 0x4198 <xQueueGenericSendFromISR>
    1f8c:	0b c0       	rjmp	.+22     	; 0x1fa4 <__vector_13+0x76>
	}	
	else
	{
		xSemaphoreGiveFromISR(LOC_smphrReceiveComplete,NULL);
    1f8e:	80 91 c7 00 	lds	r24, 0x00C7
    1f92:	90 91 c8 00 	lds	r25, 0x00C8
    1f96:	60 e0       	ldi	r22, 0x00	; 0
    1f98:	70 e0       	ldi	r23, 0x00	; 0
    1f9a:	40 e0       	ldi	r20, 0x00	; 0
    1f9c:	50 e0       	ldi	r21, 0x00	; 0
    1f9e:	20 e0       	ldi	r18, 0x00	; 0
    1fa0:	0e 94 cc 20 	call	0x4198	; 0x4198 <xQueueGenericSendFromISR>
	}
}
    1fa4:	0f 90       	pop	r0
    1fa6:	cf 91       	pop	r28
    1fa8:	df 91       	pop	r29
    1faa:	ff 91       	pop	r31
    1fac:	ef 91       	pop	r30
    1fae:	bf 91       	pop	r27
    1fb0:	af 91       	pop	r26
    1fb2:	9f 91       	pop	r25
    1fb4:	8f 91       	pop	r24
    1fb6:	7f 91       	pop	r23
    1fb8:	6f 91       	pop	r22
    1fba:	5f 91       	pop	r21
    1fbc:	4f 91       	pop	r20
    1fbe:	3f 91       	pop	r19
    1fc0:	2f 91       	pop	r18
    1fc2:	0f 90       	pop	r0
    1fc4:	0f be       	out	0x3f, r0	; 63
    1fc6:	0f 90       	pop	r0
    1fc8:	1f 90       	pop	r1
    1fca:	18 95       	reti

00001fcc <bStringCompare>:

static BOOL bStringCompare(const char * s1 , const char * s2)
{
    1fcc:	df 93       	push	r29
    1fce:	cf 93       	push	r28
    1fd0:	00 d0       	rcall	.+0      	; 0x1fd2 <bStringCompare+0x6>
    1fd2:	00 d0       	rcall	.+0      	; 0x1fd4 <bStringCompare+0x8>
    1fd4:	00 d0       	rcall	.+0      	; 0x1fd6 <bStringCompare+0xa>
    1fd6:	cd b7       	in	r28, 0x3d	; 61
    1fd8:	de b7       	in	r29, 0x3e	; 62
    1fda:	9c 83       	std	Y+4, r25	; 0x04
    1fdc:	8b 83       	std	Y+3, r24	; 0x03
    1fde:	7e 83       	std	Y+6, r23	; 0x06
    1fe0:	6d 83       	std	Y+5, r22	; 0x05
	BOOL bFlag = TRUE;
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	8a 83       	std	Y+2, r24	; 0x02
	for (u8 i=0; s2[i];i++)
    1fe6:	19 82       	std	Y+1, r1	; 0x01
    1fe8:	19 c0       	rjmp	.+50     	; 0x201c <bStringCompare+0x50>
	{
		if (s1[i] != s2[i])
    1fea:	89 81       	ldd	r24, Y+1	; 0x01
    1fec:	28 2f       	mov	r18, r24
    1fee:	30 e0       	ldi	r19, 0x00	; 0
    1ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	e2 0f       	add	r30, r18
    1ff8:	f3 1f       	adc	r31, r19
    1ffa:	40 81       	ld	r20, Z
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	28 2f       	mov	r18, r24
    2000:	30 e0       	ldi	r19, 0x00	; 0
    2002:	8d 81       	ldd	r24, Y+5	; 0x05
    2004:	9e 81       	ldd	r25, Y+6	; 0x06
    2006:	fc 01       	movw	r30, r24
    2008:	e2 0f       	add	r30, r18
    200a:	f3 1f       	adc	r31, r19
    200c:	80 81       	ld	r24, Z
    200e:	48 17       	cp	r20, r24
    2010:	11 f0       	breq	.+4      	; 0x2016 <bStringCompare+0x4a>
		{
			bFlag = FALSE;
    2012:	1a 82       	std	Y+2, r1	; 0x02
    2014:	0e c0       	rjmp	.+28     	; 0x2032 <bStringCompare+0x66>
}

static BOOL bStringCompare(const char * s1 , const char * s2)
{
	BOOL bFlag = TRUE;
	for (u8 i=0; s2[i];i++)
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	8f 5f       	subi	r24, 0xFF	; 255
    201a:	89 83       	std	Y+1, r24	; 0x01
    201c:	89 81       	ldd	r24, Y+1	; 0x01
    201e:	28 2f       	mov	r18, r24
    2020:	30 e0       	ldi	r19, 0x00	; 0
    2022:	8d 81       	ldd	r24, Y+5	; 0x05
    2024:	9e 81       	ldd	r25, Y+6	; 0x06
    2026:	fc 01       	movw	r30, r24
    2028:	e2 0f       	add	r30, r18
    202a:	f3 1f       	adc	r31, r19
    202c:	80 81       	ld	r24, Z
    202e:	88 23       	and	r24, r24
    2030:	e1 f6       	brne	.-72     	; 0x1fea <bStringCompare+0x1e>
		{
			bFlag = FALSE;
			break;
		}
	}
	return bFlag;
    2032:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2034:	26 96       	adiw	r28, 0x06	; 6
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	de bf       	out	0x3e, r29	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	cd bf       	out	0x3d, r28	; 61
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <POV_enuInit>:

static POVState_t LOC_enuPOVStateMachine = POV_WRITE_FIRST; 
static u8 LOC_u8DisplayedNumber =0;

ES_t POV_enuInit(void)
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
   return HexaDec_enuInit();
    204e:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <HexaDec_enuInit>
}
    2052:	cf 91       	pop	r28
    2054:	df 91       	pop	r29
    2056:	08 95       	ret

00002058 <POV_vidDisplayTask>:

void POV_vidDisplayTask(void)
{
    2058:	df 93       	push	r29
    205a:	cf 93       	push	r28
    205c:	00 d0       	rcall	.+0      	; 0x205e <POV_vidDisplayTask+0x6>
    205e:	cd b7       	in	r28, 0x3d	; 61
    2060:	de b7       	in	r29, 0x3e	; 62
    switch (LOC_enuPOVStateMachine)
    2062:	80 91 cb 00 	lds	r24, 0x00CB
    2066:	28 2f       	mov	r18, r24
    2068:	30 e0       	ldi	r19, 0x00	; 0
    206a:	3a 83       	std	Y+2, r19	; 0x02
    206c:	29 83       	std	Y+1, r18	; 0x01
    206e:	89 81       	ldd	r24, Y+1	; 0x01
    2070:	9a 81       	ldd	r25, Y+2	; 0x02
    2072:	82 30       	cpi	r24, 0x02	; 2
    2074:	91 05       	cpc	r25, r1
    2076:	a1 f1       	breq	.+104    	; 0x20e0 <POV_vidDisplayTask+0x88>
    2078:	29 81       	ldd	r18, Y+1	; 0x01
    207a:	3a 81       	ldd	r19, Y+2	; 0x02
    207c:	23 30       	cpi	r18, 0x03	; 3
    207e:	31 05       	cpc	r19, r1
    2080:	54 f4       	brge	.+20     	; 0x2096 <POV_vidDisplayTask+0x3e>
    2082:	89 81       	ldd	r24, Y+1	; 0x01
    2084:	9a 81       	ldd	r25, Y+2	; 0x02
    2086:	00 97       	sbiw	r24, 0x00	; 0
    2088:	89 f0       	breq	.+34     	; 0x20ac <POV_vidDisplayTask+0x54>
    208a:	29 81       	ldd	r18, Y+1	; 0x01
    208c:	3a 81       	ldd	r19, Y+2	; 0x02
    208e:	21 30       	cpi	r18, 0x01	; 1
    2090:	31 05       	cpc	r19, r1
    2092:	11 f1       	breq	.+68     	; 0x20d8 <POV_vidDisplayTask+0x80>
    2094:	40 c0       	rjmp	.+128    	; 0x2116 <POV_vidDisplayTask+0xbe>
    2096:	89 81       	ldd	r24, Y+1	; 0x01
    2098:	9a 81       	ldd	r25, Y+2	; 0x02
    209a:	83 30       	cpi	r24, 0x03	; 3
    209c:	91 05       	cpc	r25, r1
    209e:	91 f1       	breq	.+100    	; 0x2104 <POV_vidDisplayTask+0xac>
    20a0:	29 81       	ldd	r18, Y+1	; 0x01
    20a2:	3a 81       	ldd	r19, Y+2	; 0x02
    20a4:	24 30       	cpi	r18, 0x04	; 4
    20a6:	31 05       	cpc	r19, r1
    20a8:	81 f1       	breq	.+96     	; 0x210a <POV_vidDisplayTask+0xb2>
    20aa:	35 c0       	rjmp	.+106    	; 0x2116 <POV_vidDisplayTask+0xbe>
    {
    case POV_WRITE_FIRST:
        HexaDec_enuDisableSSG(SSG_RIGHT);
    20ac:	82 e6       	ldi	r24, 0x62	; 98
    20ae:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
        HexaDec_enuDisableSSG(SSG_LEFT);
    20b2:	8d e2       	ldi	r24, 0x2D	; 45
    20b4:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>

        HexaDec_enuDisplayNum(LOC_u8DisplayedNumber % 10);
    20b8:	80 91 cc 00 	lds	r24, 0x00CC
    20bc:	9a e0       	ldi	r25, 0x0A	; 10
    20be:	69 2f       	mov	r22, r25
    20c0:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__udivmodqi4>
    20c4:	89 2f       	mov	r24, r25
    20c6:	0e 94 ca 0b 	call	0x1794	; 0x1794 <HexaDec_enuDisplayNum>
        HexaDec_enuEnableSSG(SSG_RIGHT);
    20ca:	82 e6       	ldi	r24, 0x62	; 98
    20cc:	0e 94 04 0c 	call	0x1808	; 0x1808 <HexaDec_enuEnableSSG>
        LOC_enuPOVStateMachine = POV_DELAY_FIRST;
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	80 93 cb 00 	sts	0x00CB, r24
    20d6:	1f c0       	rjmp	.+62     	; 0x2116 <POV_vidDisplayTask+0xbe>
        break;

    case POV_DELAY_FIRST:
        LOC_enuPOVStateMachine = POV_WRITE_SECOND;
    20d8:	82 e0       	ldi	r24, 0x02	; 2
    20da:	80 93 cb 00 	sts	0x00CB, r24
    20de:	1b c0       	rjmp	.+54     	; 0x2116 <POV_vidDisplayTask+0xbe>
        break;

    case POV_WRITE_SECOND:
        HexaDec_enuDisableSSG(SSG_RIGHT);
    20e0:	82 e6       	ldi	r24, 0x62	; 98
    20e2:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>

        HexaDec_enuDisplayNum(LOC_u8DisplayedNumber / 10);
    20e6:	80 91 cc 00 	lds	r24, 0x00CC
    20ea:	9a e0       	ldi	r25, 0x0A	; 10
    20ec:	69 2f       	mov	r22, r25
    20ee:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__udivmodqi4>
    20f2:	0e 94 ca 0b 	call	0x1794	; 0x1794 <HexaDec_enuDisplayNum>
        HexaDec_enuEnableSSG(SSG_LEFT);
    20f6:	8d e2       	ldi	r24, 0x2D	; 45
    20f8:	0e 94 04 0c 	call	0x1808	; 0x1808 <HexaDec_enuEnableSSG>
        LOC_enuPOVStateMachine = POV_DELAY_SECOND;
    20fc:	83 e0       	ldi	r24, 0x03	; 3
    20fe:	80 93 cb 00 	sts	0x00CB, r24
    2102:	09 c0       	rjmp	.+18     	; 0x2116 <POV_vidDisplayTask+0xbe>
        break;

    case POV_DELAY_SECOND:
        LOC_enuPOVStateMachine = POV_WRITE_FIRST;
    2104:	10 92 cb 00 	sts	0x00CB, r1
    2108:	06 c0       	rjmp	.+12     	; 0x2116 <POV_vidDisplayTask+0xbe>
        break;
    case POV_STOP_DISPLAY:
        HexaDec_enuDisableSSG(SSG_RIGHT);
    210a:	82 e6       	ldi	r24, 0x62	; 98
    210c:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
        HexaDec_enuDisableSSG(SSG_LEFT);
    2110:	8d e2       	ldi	r24, 0x2D	; 45
    2112:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
        break;
    default:
        break;
    }
}
    2116:	0f 90       	pop	r0
    2118:	0f 90       	pop	r0
    211a:	cf 91       	pop	r28
    211c:	df 91       	pop	r29
    211e:	08 95       	ret

00002120 <POV_vidSetDisplayedNumber>:

void POV_vidSetDisplayedNumber(u8 Copy_u8Number)
{
    2120:	df 93       	push	r29
    2122:	cf 93       	push	r28
    2124:	0f 92       	push	r0
    2126:	cd b7       	in	r28, 0x3d	; 61
    2128:	de b7       	in	r29, 0x3e	; 62
    212a:	89 83       	std	Y+1, r24	; 0x01
    LOC_u8DisplayedNumber = Copy_u8Number;
    212c:	89 81       	ldd	r24, Y+1	; 0x01
    212e:	80 93 cc 00 	sts	0x00CC, r24
}
    2132:	0f 90       	pop	r0
    2134:	cf 91       	pop	r28
    2136:	df 91       	pop	r29
    2138:	08 95       	ret

0000213a <POV_vidStopDisplay>:

void POV_vidStopDisplay(void)
{
    213a:	df 93       	push	r29
    213c:	cf 93       	push	r28
    213e:	cd b7       	in	r28, 0x3d	; 61
    2140:	de b7       	in	r29, 0x3e	; 62
    LOC_enuPOVStateMachine = POV_STOP_DISPLAY;
    2142:	84 e0       	ldi	r24, 0x04	; 4
    2144:	80 93 cb 00 	sts	0x00CB, r24
}
    2148:	cf 91       	pop	r28
    214a:	df 91       	pop	r29
    214c:	08 95       	ret

0000214e <POV_vidResumeDisplay>:

void POV_vidResumeDisplay(void)
{
    214e:	df 93       	push	r29
    2150:	cf 93       	push	r28
    2152:	cd b7       	in	r28, 0x3d	; 61
    2154:	de b7       	in	r29, 0x3e	; 62
    LOC_enuPOVStateMachine = POV_WRITE_FIRST;
    2156:	10 92 cb 00 	sts	0x00CB, r1
}
    215a:	cf 91       	pop	r28
    215c:	df 91       	pop	r29
    215e:	08 95       	ret

00002160 <POV_enuDisplayNum>:


ES_t POV_enuDisplayNum(u8 Copy_u8Num)
{
    2160:	df 93       	push	r29
    2162:	cf 93       	push	r28
    2164:	cd b7       	in	r28, 0x3d	; 61
    2166:	de b7       	in	r29, 0x3e	; 62
    2168:	6e 97       	sbiw	r28, 0x1e	; 30
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	f8 94       	cli
    216e:	de bf       	out	0x3e, r29	; 62
    2170:	0f be       	out	0x3f, r0	; 63
    2172:	cd bf       	out	0x3d, r28	; 61
    2174:	8e 8f       	std	Y+30, r24	; 0x1e
    ES_t Local_enuErrorState = ES_NOK;
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	8d 8f       	std	Y+29, r24	; 0x1d

    if (Copy_u8Num <= 99)
    217a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    217c:	84 36       	cpi	r24, 0x64	; 100
    217e:	08 f0       	brcs	.+2      	; 0x2182 <POV_enuDisplayNum+0x22>
    2180:	06 c1       	rjmp	.+524    	; 0x238e <POV_enuDisplayNum+0x22e>
    {
        HexaDec_enuDisableSSG(SSG_RIGHT);
    2182:	82 e6       	ldi	r24, 0x62	; 98
    2184:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
        HexaDec_enuDisableSSG(SSG_LEFT);
    2188:	8d e2       	ldi	r24, 0x2D	; 45
    218a:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>

        HexaDec_enuDisplayNum(Copy_u8Num % 10);
    218e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2190:	9a e0       	ldi	r25, 0x0A	; 10
    2192:	69 2f       	mov	r22, r25
    2194:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__udivmodqi4>
    2198:	89 2f       	mov	r24, r25
    219a:	0e 94 ca 0b 	call	0x1794	; 0x1794 <HexaDec_enuDisplayNum>
        HexaDec_enuEnableSSG(SSG_RIGHT);
    219e:	82 e6       	ldi	r24, 0x62	; 98
    21a0:	0e 94 04 0c 	call	0x1808	; 0x1808 <HexaDec_enuEnableSSG>
    21a4:	80 e0       	ldi	r24, 0x00	; 0
    21a6:	90 e0       	ldi	r25, 0x00	; 0
    21a8:	a0 e2       	ldi	r26, 0x20	; 32
    21aa:	b1 e4       	ldi	r27, 0x41	; 65
    21ac:	89 8f       	std	Y+25, r24	; 0x19
    21ae:	9a 8f       	std	Y+26, r25	; 0x1a
    21b0:	ab 8f       	std	Y+27, r26	; 0x1b
    21b2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21b4:	69 8d       	ldd	r22, Y+25	; 0x19
    21b6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    21b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21bc:	20 e0       	ldi	r18, 0x00	; 0
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	4a e7       	ldi	r20, 0x7A	; 122
    21c2:	55 e4       	ldi	r21, 0x45	; 69
    21c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21c8:	dc 01       	movw	r26, r24
    21ca:	cb 01       	movw	r24, r22
    21cc:	8d 8b       	std	Y+21, r24	; 0x15
    21ce:	9e 8b       	std	Y+22, r25	; 0x16
    21d0:	af 8b       	std	Y+23, r26	; 0x17
    21d2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    21d4:	6d 89       	ldd	r22, Y+21	; 0x15
    21d6:	7e 89       	ldd	r23, Y+22	; 0x16
    21d8:	8f 89       	ldd	r24, Y+23	; 0x17
    21da:	98 8d       	ldd	r25, Y+24	; 0x18
    21dc:	20 e0       	ldi	r18, 0x00	; 0
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	40 e8       	ldi	r20, 0x80	; 128
    21e2:	5f e3       	ldi	r21, 0x3F	; 63
    21e4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21e8:	88 23       	and	r24, r24
    21ea:	2c f4       	brge	.+10     	; 0x21f6 <POV_enuDisplayNum+0x96>
		__ticks = 1;
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	9c 8b       	std	Y+20, r25	; 0x14
    21f2:	8b 8b       	std	Y+19, r24	; 0x13
    21f4:	3f c0       	rjmp	.+126    	; 0x2274 <POV_enuDisplayNum+0x114>
	else if (__tmp > 65535)
    21f6:	6d 89       	ldd	r22, Y+21	; 0x15
    21f8:	7e 89       	ldd	r23, Y+22	; 0x16
    21fa:	8f 89       	ldd	r24, Y+23	; 0x17
    21fc:	98 8d       	ldd	r25, Y+24	; 0x18
    21fe:	20 e0       	ldi	r18, 0x00	; 0
    2200:	3f ef       	ldi	r19, 0xFF	; 255
    2202:	4f e7       	ldi	r20, 0x7F	; 127
    2204:	57 e4       	ldi	r21, 0x47	; 71
    2206:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    220a:	18 16       	cp	r1, r24
    220c:	4c f5       	brge	.+82     	; 0x2260 <POV_enuDisplayNum+0x100>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    220e:	69 8d       	ldd	r22, Y+25	; 0x19
    2210:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2212:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2214:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2216:	20 e0       	ldi	r18, 0x00	; 0
    2218:	30 e0       	ldi	r19, 0x00	; 0
    221a:	40 e2       	ldi	r20, 0x20	; 32
    221c:	51 e4       	ldi	r21, 0x41	; 65
    221e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2222:	dc 01       	movw	r26, r24
    2224:	cb 01       	movw	r24, r22
    2226:	bc 01       	movw	r22, r24
    2228:	cd 01       	movw	r24, r26
    222a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    222e:	dc 01       	movw	r26, r24
    2230:	cb 01       	movw	r24, r22
    2232:	9c 8b       	std	Y+20, r25	; 0x14
    2234:	8b 8b       	std	Y+19, r24	; 0x13
    2236:	0f c0       	rjmp	.+30     	; 0x2256 <POV_enuDisplayNum+0xf6>
    2238:	80 e9       	ldi	r24, 0x90	; 144
    223a:	91 e0       	ldi	r25, 0x01	; 1
    223c:	9a 8b       	std	Y+18, r25	; 0x12
    223e:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2240:	89 89       	ldd	r24, Y+17	; 0x11
    2242:	9a 89       	ldd	r25, Y+18	; 0x12
    2244:	01 97       	sbiw	r24, 0x01	; 1
    2246:	f1 f7       	brne	.-4      	; 0x2244 <POV_enuDisplayNum+0xe4>
    2248:	9a 8b       	std	Y+18, r25	; 0x12
    224a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    224c:	8b 89       	ldd	r24, Y+19	; 0x13
    224e:	9c 89       	ldd	r25, Y+20	; 0x14
    2250:	01 97       	sbiw	r24, 0x01	; 1
    2252:	9c 8b       	std	Y+20, r25	; 0x14
    2254:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2256:	8b 89       	ldd	r24, Y+19	; 0x13
    2258:	9c 89       	ldd	r25, Y+20	; 0x14
    225a:	00 97       	sbiw	r24, 0x00	; 0
    225c:	69 f7       	brne	.-38     	; 0x2238 <POV_enuDisplayNum+0xd8>
    225e:	14 c0       	rjmp	.+40     	; 0x2288 <POV_enuDisplayNum+0x128>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2260:	6d 89       	ldd	r22, Y+21	; 0x15
    2262:	7e 89       	ldd	r23, Y+22	; 0x16
    2264:	8f 89       	ldd	r24, Y+23	; 0x17
    2266:	98 8d       	ldd	r25, Y+24	; 0x18
    2268:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    226c:	dc 01       	movw	r26, r24
    226e:	cb 01       	movw	r24, r22
    2270:	9c 8b       	std	Y+20, r25	; 0x14
    2272:	8b 8b       	std	Y+19, r24	; 0x13
    2274:	8b 89       	ldd	r24, Y+19	; 0x13
    2276:	9c 89       	ldd	r25, Y+20	; 0x14
    2278:	98 8b       	std	Y+16, r25	; 0x10
    227a:	8f 87       	std	Y+15, r24	; 0x0f
    227c:	8f 85       	ldd	r24, Y+15	; 0x0f
    227e:	98 89       	ldd	r25, Y+16	; 0x10
    2280:	01 97       	sbiw	r24, 0x01	; 1
    2282:	f1 f7       	brne	.-4      	; 0x2280 <POV_enuDisplayNum+0x120>
    2284:	98 8b       	std	Y+16, r25	; 0x10
    2286:	8f 87       	std	Y+15, r24	; 0x0f
        _delay_ms(10);

        HexaDec_enuDisableSSG(SSG_RIGHT);
    2288:	82 e6       	ldi	r24, 0x62	; 98
    228a:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
        HexaDec_enuDisplayNum(Copy_u8Num / 10);
    228e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2290:	9a e0       	ldi	r25, 0x0A	; 10
    2292:	69 2f       	mov	r22, r25
    2294:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__udivmodqi4>
    2298:	0e 94 ca 0b 	call	0x1794	; 0x1794 <HexaDec_enuDisplayNum>
        HexaDec_enuEnableSSG(SSG_LEFT);
    229c:	8d e2       	ldi	r24, 0x2D	; 45
    229e:	0e 94 04 0c 	call	0x1808	; 0x1808 <HexaDec_enuEnableSSG>
    22a2:	80 e0       	ldi	r24, 0x00	; 0
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	a0 e2       	ldi	r26, 0x20	; 32
    22a8:	b1 e4       	ldi	r27, 0x41	; 65
    22aa:	8b 87       	std	Y+11, r24	; 0x0b
    22ac:	9c 87       	std	Y+12, r25	; 0x0c
    22ae:	ad 87       	std	Y+13, r26	; 0x0d
    22b0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    22b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    22b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    22b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    22ba:	20 e0       	ldi	r18, 0x00	; 0
    22bc:	30 e0       	ldi	r19, 0x00	; 0
    22be:	4a e7       	ldi	r20, 0x7A	; 122
    22c0:	55 e4       	ldi	r21, 0x45	; 69
    22c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22c6:	dc 01       	movw	r26, r24
    22c8:	cb 01       	movw	r24, r22
    22ca:	8f 83       	std	Y+7, r24	; 0x07
    22cc:	98 87       	std	Y+8, r25	; 0x08
    22ce:	a9 87       	std	Y+9, r26	; 0x09
    22d0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    22d2:	6f 81       	ldd	r22, Y+7	; 0x07
    22d4:	78 85       	ldd	r23, Y+8	; 0x08
    22d6:	89 85       	ldd	r24, Y+9	; 0x09
    22d8:	9a 85       	ldd	r25, Y+10	; 0x0a
    22da:	20 e0       	ldi	r18, 0x00	; 0
    22dc:	30 e0       	ldi	r19, 0x00	; 0
    22de:	40 e8       	ldi	r20, 0x80	; 128
    22e0:	5f e3       	ldi	r21, 0x3F	; 63
    22e2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22e6:	88 23       	and	r24, r24
    22e8:	2c f4       	brge	.+10     	; 0x22f4 <POV_enuDisplayNum+0x194>
		__ticks = 1;
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	90 e0       	ldi	r25, 0x00	; 0
    22ee:	9e 83       	std	Y+6, r25	; 0x06
    22f0:	8d 83       	std	Y+5, r24	; 0x05
    22f2:	3f c0       	rjmp	.+126    	; 0x2372 <POV_enuDisplayNum+0x212>
	else if (__tmp > 65535)
    22f4:	6f 81       	ldd	r22, Y+7	; 0x07
    22f6:	78 85       	ldd	r23, Y+8	; 0x08
    22f8:	89 85       	ldd	r24, Y+9	; 0x09
    22fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    22fc:	20 e0       	ldi	r18, 0x00	; 0
    22fe:	3f ef       	ldi	r19, 0xFF	; 255
    2300:	4f e7       	ldi	r20, 0x7F	; 127
    2302:	57 e4       	ldi	r21, 0x47	; 71
    2304:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2308:	18 16       	cp	r1, r24
    230a:	4c f5       	brge	.+82     	; 0x235e <POV_enuDisplayNum+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    230c:	6b 85       	ldd	r22, Y+11	; 0x0b
    230e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2310:	8d 85       	ldd	r24, Y+13	; 0x0d
    2312:	9e 85       	ldd	r25, Y+14	; 0x0e
    2314:	20 e0       	ldi	r18, 0x00	; 0
    2316:	30 e0       	ldi	r19, 0x00	; 0
    2318:	40 e2       	ldi	r20, 0x20	; 32
    231a:	51 e4       	ldi	r21, 0x41	; 65
    231c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2320:	dc 01       	movw	r26, r24
    2322:	cb 01       	movw	r24, r22
    2324:	bc 01       	movw	r22, r24
    2326:	cd 01       	movw	r24, r26
    2328:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    232c:	dc 01       	movw	r26, r24
    232e:	cb 01       	movw	r24, r22
    2330:	9e 83       	std	Y+6, r25	; 0x06
    2332:	8d 83       	std	Y+5, r24	; 0x05
    2334:	0f c0       	rjmp	.+30     	; 0x2354 <POV_enuDisplayNum+0x1f4>
    2336:	80 e9       	ldi	r24, 0x90	; 144
    2338:	91 e0       	ldi	r25, 0x01	; 1
    233a:	9c 83       	std	Y+4, r25	; 0x04
    233c:	8b 83       	std	Y+3, r24	; 0x03
    233e:	8b 81       	ldd	r24, Y+3	; 0x03
    2340:	9c 81       	ldd	r25, Y+4	; 0x04
    2342:	01 97       	sbiw	r24, 0x01	; 1
    2344:	f1 f7       	brne	.-4      	; 0x2342 <POV_enuDisplayNum+0x1e2>
    2346:	9c 83       	std	Y+4, r25	; 0x04
    2348:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    234a:	8d 81       	ldd	r24, Y+5	; 0x05
    234c:	9e 81       	ldd	r25, Y+6	; 0x06
    234e:	01 97       	sbiw	r24, 0x01	; 1
    2350:	9e 83       	std	Y+6, r25	; 0x06
    2352:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2354:	8d 81       	ldd	r24, Y+5	; 0x05
    2356:	9e 81       	ldd	r25, Y+6	; 0x06
    2358:	00 97       	sbiw	r24, 0x00	; 0
    235a:	69 f7       	brne	.-38     	; 0x2336 <POV_enuDisplayNum+0x1d6>
    235c:	14 c0       	rjmp	.+40     	; 0x2386 <POV_enuDisplayNum+0x226>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    235e:	6f 81       	ldd	r22, Y+7	; 0x07
    2360:	78 85       	ldd	r23, Y+8	; 0x08
    2362:	89 85       	ldd	r24, Y+9	; 0x09
    2364:	9a 85       	ldd	r25, Y+10	; 0x0a
    2366:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    236a:	dc 01       	movw	r26, r24
    236c:	cb 01       	movw	r24, r22
    236e:	9e 83       	std	Y+6, r25	; 0x06
    2370:	8d 83       	std	Y+5, r24	; 0x05
    2372:	8d 81       	ldd	r24, Y+5	; 0x05
    2374:	9e 81       	ldd	r25, Y+6	; 0x06
    2376:	9a 83       	std	Y+2, r25	; 0x02
    2378:	89 83       	std	Y+1, r24	; 0x01
    237a:	89 81       	ldd	r24, Y+1	; 0x01
    237c:	9a 81       	ldd	r25, Y+2	; 0x02
    237e:	01 97       	sbiw	r24, 0x01	; 1
    2380:	f1 f7       	brne	.-4      	; 0x237e <POV_enuDisplayNum+0x21e>
    2382:	9a 83       	std	Y+2, r25	; 0x02
    2384:	89 83       	std	Y+1, r24	; 0x01
        _delay_ms(10);

        HexaDec_enuDisableSSG(SSG_LEFT);
    2386:	8d e2       	ldi	r24, 0x2D	; 45
    2388:	0e 94 28 0c 	call	0x1850	; 0x1850 <HexaDec_enuDisableSSG>
    238c:	02 c0       	rjmp	.+4      	; 0x2392 <POV_enuDisplayNum+0x232>
    }
    else
    {
        Local_enuErrorState = ES_OUT_OF_RANGE;
    238e:	82 e0       	ldi	r24, 0x02	; 2
    2390:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    return Local_enuErrorState;
    2392:	8d 8d       	ldd	r24, Y+29	; 0x1d
}
    2394:	6e 96       	adiw	r28, 0x1e	; 30
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	de bf       	out	0x3e, r29	; 62
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	cd bf       	out	0x3d, r28	; 61
    23a0:	cf 91       	pop	r28
    23a2:	df 91       	pop	r29
    23a4:	08 95       	ret

000023a6 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    23a6:	af 92       	push	r10
    23a8:	bf 92       	push	r11
    23aa:	cf 92       	push	r12
    23ac:	df 92       	push	r13
    23ae:	ef 92       	push	r14
    23b0:	ff 92       	push	r15
    23b2:	0f 93       	push	r16
    23b4:	df 93       	push	r29
    23b6:	cf 93       	push	r28
    23b8:	0f 92       	push	r0
    23ba:	cd b7       	in	r28, 0x3d	; 61
    23bc:	de b7       	in	r29, 0x3e	; 62
    23be:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    23c0:	8a e0       	ldi	r24, 0x0A	; 10
    23c2:	62 e0       	ldi	r22, 0x02	; 2
    23c4:	40 e0       	ldi	r20, 0x00	; 0
    23c6:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <xQueueGenericCreate>
    23ca:	90 93 d0 00 	sts	0x00D0, r25
    23ce:	80 93 cf 00 	sts	0x00CF, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    23d2:	87 e5       	ldi	r24, 0x57	; 87
    23d4:	92 e1       	ldi	r25, 0x12	; 18
    23d6:	25 e7       	ldi	r18, 0x75	; 117
    23d8:	30 e0       	ldi	r19, 0x00	; 0
    23da:	ef ec       	ldi	r30, 0xCF	; 207
    23dc:	f0 e0       	ldi	r31, 0x00	; 0
    23de:	b9 01       	movw	r22, r18
    23e0:	45 e5       	ldi	r20, 0x55	; 85
    23e2:	50 e0       	ldi	r21, 0x00	; 0
    23e4:	9f 01       	movw	r18, r30
    23e6:	09 81       	ldd	r16, Y+1	; 0x01
    23e8:	ee 24       	eor	r14, r14
    23ea:	ff 24       	eor	r15, r15
    23ec:	cc 24       	eor	r12, r12
    23ee:	dd 24       	eor	r13, r13
    23f0:	aa 24       	eor	r10, r10
    23f2:	bb 24       	eor	r11, r11
    23f4:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    23f8:	8a e1       	ldi	r24, 0x1A	; 26
    23fa:	92 e1       	ldi	r25, 0x12	; 18
    23fc:	2d e7       	ldi	r18, 0x7D	; 125
    23fe:	30 e0       	ldi	r19, 0x00	; 0
    2400:	ef ec       	ldi	r30, 0xCF	; 207
    2402:	f0 e0       	ldi	r31, 0x00	; 0
    2404:	b9 01       	movw	r22, r18
    2406:	45 e5       	ldi	r20, 0x55	; 85
    2408:	50 e0       	ldi	r21, 0x00	; 0
    240a:	9f 01       	movw	r18, r30
    240c:	09 81       	ldd	r16, Y+1	; 0x01
    240e:	ee 24       	eor	r14, r14
    2410:	ff 24       	eor	r15, r15
    2412:	cc 24       	eor	r12, r12
    2414:	dd 24       	eor	r13, r13
    2416:	aa 24       	eor	r10, r10
    2418:	bb 24       	eor	r11, r11
    241a:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
}
    241e:	0f 90       	pop	r0
    2420:	cf 91       	pop	r28
    2422:	df 91       	pop	r29
    2424:	0f 91       	pop	r16
    2426:	ff 90       	pop	r15
    2428:	ef 90       	pop	r14
    242a:	df 90       	pop	r13
    242c:	cf 90       	pop	r12
    242e:	bf 90       	pop	r11
    2430:	af 90       	pop	r10
    2432:	08 95       	ret

00002434 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    2434:	df 93       	push	r29
    2436:	cf 93       	push	r28
    2438:	00 d0       	rcall	.+0      	; 0x243a <vPolledQueueProducer+0x6>
    243a:	00 d0       	rcall	.+0      	; 0x243c <vPolledQueueProducer+0x8>
    243c:	00 d0       	rcall	.+0      	; 0x243e <vPolledQueueProducer+0xa>
    243e:	cd b7       	in	r28, 0x3d	; 61
    2440:	de b7       	in	r29, 0x3e	; 62
    2442:	9e 83       	std	Y+6, r25	; 0x06
    2444:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
    2446:	1c 82       	std	Y+4, r1	; 0x04
    2448:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
    244a:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    244c:	19 82       	std	Y+1, r1	; 0x01
    244e:	27 c0       	rjmp	.+78     	; 0x249e <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    2450:	ed 81       	ldd	r30, Y+5	; 0x05
    2452:	fe 81       	ldd	r31, Y+6	; 0x06
    2454:	80 81       	ld	r24, Z
    2456:	91 81       	ldd	r25, Z+1	; 0x01
    2458:	9e 01       	movw	r18, r28
    245a:	2d 5f       	subi	r18, 0xFD	; 253
    245c:	3f 4f       	sbci	r19, 0xFF	; 255
    245e:	b9 01       	movw	r22, r18
    2460:	40 e0       	ldi	r20, 0x00	; 0
    2462:	50 e0       	ldi	r21, 0x00	; 0
    2464:	20 e0       	ldi	r18, 0x00	; 0
    2466:	0e 94 20 20 	call	0x4040	; 0x4040 <xQueueGenericSend>
    246a:	81 30       	cpi	r24, 0x01	; 1
    246c:	19 f0       	breq	.+6      	; 0x2474 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    246e:	81 e0       	ldi	r24, 0x01	; 1
    2470:	8a 83       	std	Y+2, r24	; 0x02
    2472:	12 c0       	rjmp	.+36     	; 0x2498 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
    2474:	8a 81       	ldd	r24, Y+2	; 0x02
    2476:	88 23       	and	r24, r24
    2478:	51 f4       	brne	.+20     	; 0x248e <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    247a:	0f b6       	in	r0, 0x3f	; 63
    247c:	f8 94       	cli
    247e:	0f 92       	push	r0
						xPollingProducerCount++;
    2480:	80 91 ce 00 	lds	r24, 0x00CE
    2484:	8f 5f       	subi	r24, 0xFF	; 255
    2486:	80 93 ce 00 	sts	0x00CE, r24
					portEXIT_CRITICAL();
    248a:	0f 90       	pop	r0
    248c:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    248e:	8b 81       	ldd	r24, Y+3	; 0x03
    2490:	9c 81       	ldd	r25, Y+4	; 0x04
    2492:	01 96       	adiw	r24, 0x01	; 1
    2494:	9c 83       	std	Y+4, r25	; 0x04
    2496:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    2498:	89 81       	ldd	r24, Y+1	; 0x01
    249a:	8f 5f       	subi	r24, 0xFF	; 255
    249c:	89 83       	std	Y+1, r24	; 0x01
    249e:	89 81       	ldd	r24, Y+1	; 0x01
    24a0:	83 30       	cpi	r24, 0x03	; 3
    24a2:	b4 f2       	brlt	.-84     	; 0x2450 <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    24a4:	88 e2       	ldi	r24, 0x28	; 40
    24a6:	90 e0       	ldi	r25, 0x00	; 0
    24a8:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    24ac:	cf cf       	rjmp	.-98     	; 0x244c <vPolledQueueProducer+0x18>

000024ae <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    24ae:	df 93       	push	r29
    24b0:	cf 93       	push	r28
    24b2:	cd b7       	in	r28, 0x3d	; 61
    24b4:	de b7       	in	r29, 0x3e	; 62
    24b6:	27 97       	sbiw	r28, 0x07	; 7
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	f8 94       	cli
    24bc:	de bf       	out	0x3e, r29	; 62
    24be:	0f be       	out	0x3f, r0	; 63
    24c0:	cd bf       	out	0x3d, r28	; 61
    24c2:	9f 83       	std	Y+7, r25	; 0x07
    24c4:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
    24c6:	1b 82       	std	Y+3, r1	; 0x03
    24c8:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
    24ca:	19 82       	std	Y+1, r1	; 0x01
    24cc:	2f c0       	rjmp	.+94     	; 0x252c <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    24ce:	ee 81       	ldd	r30, Y+6	; 0x06
    24d0:	ff 81       	ldd	r31, Y+7	; 0x07
    24d2:	80 81       	ld	r24, Z
    24d4:	91 81       	ldd	r25, Z+1	; 0x01
    24d6:	9e 01       	movw	r18, r28
    24d8:	2c 5f       	subi	r18, 0xFC	; 252
    24da:	3f 4f       	sbci	r19, 0xFF	; 255
    24dc:	b9 01       	movw	r22, r18
    24de:	40 e0       	ldi	r20, 0x00	; 0
    24e0:	50 e0       	ldi	r21, 0x00	; 0
    24e2:	20 e0       	ldi	r18, 0x00	; 0
    24e4:	0e 94 2e 21 	call	0x425c	; 0x425c <xQueueGenericReceive>
    24e8:	81 30       	cpi	r24, 0x01	; 1
    24ea:	01 f5       	brne	.+64     	; 0x252c <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
    24ec:	2c 81       	ldd	r18, Y+4	; 0x04
    24ee:	3d 81       	ldd	r19, Y+5	; 0x05
    24f0:	8a 81       	ldd	r24, Y+2	; 0x02
    24f2:	9b 81       	ldd	r25, Y+3	; 0x03
    24f4:	28 17       	cp	r18, r24
    24f6:	39 07       	cpc	r19, r25
    24f8:	39 f0       	breq	.+14     	; 0x2508 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    24fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2500:	9d 81       	ldd	r25, Y+5	; 0x05
    2502:	9b 83       	std	Y+3, r25	; 0x03
    2504:	8a 83       	std	Y+2, r24	; 0x02
    2506:	0d c0       	rjmp	.+26     	; 0x2522 <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	88 23       	and	r24, r24
    250c:	51 f4       	brne	.+20     	; 0x2522 <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    250e:	0f b6       	in	r0, 0x3f	; 63
    2510:	f8 94       	cli
    2512:	0f 92       	push	r0
							xPollingConsumerCount++;
    2514:	80 91 cd 00 	lds	r24, 0x00CD
    2518:	8f 5f       	subi	r24, 0xFF	; 255
    251a:	80 93 cd 00 	sts	0x00CD, r24
						portEXIT_CRITICAL();
    251e:	0f 90       	pop	r0
    2520:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    2522:	8a 81       	ldd	r24, Y+2	; 0x02
    2524:	9b 81       	ldd	r25, Y+3	; 0x03
    2526:	01 96       	adiw	r24, 0x01	; 1
    2528:	9b 83       	std	Y+3, r25	; 0x03
    252a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    252c:	ee 81       	ldd	r30, Y+6	; 0x06
    252e:	ff 81       	ldd	r31, Y+7	; 0x07
    2530:	80 81       	ld	r24, Z
    2532:	91 81       	ldd	r25, Z+1	; 0x01
    2534:	0e 94 9f 22 	call	0x453e	; 0x453e <uxQueueMessagesWaiting>
    2538:	88 23       	and	r24, r24
    253a:	49 f6       	brne	.-110    	; 0x24ce <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    253c:	84 e2       	ldi	r24, 0x24	; 36
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskDelay>
    2544:	f3 cf       	rjmp	.-26     	; 0x252c <vPolledQueueConsumer+0x7e>

00002546 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
    2546:	df 93       	push	r29
    2548:	cf 93       	push	r28
    254a:	0f 92       	push	r0
    254c:	cd b7       	in	r28, 0x3d	; 61
    254e:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2550:	80 91 cd 00 	lds	r24, 0x00CD
    2554:	88 23       	and	r24, r24
    2556:	21 f0       	breq	.+8      	; 0x2560 <xArePollingQueuesStillRunning+0x1a>
    2558:	80 91 ce 00 	lds	r24, 0x00CE
    255c:	88 23       	and	r24, r24
    255e:	11 f4       	brne	.+4      	; 0x2564 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    2560:	19 82       	std	Y+1, r1	; 0x01
    2562:	02 c0       	rjmp	.+4      	; 0x2568 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2568:	10 92 cd 00 	sts	0x00CD, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    256c:	10 92 ce 00 	sts	0x00CE, r1

	return xReturn;
    2570:	89 81       	ldd	r24, Y+1	; 0x01
}
    2572:	0f 90       	pop	r0
    2574:	cf 91       	pop	r28
    2576:	df 91       	pop	r29
    2578:	08 95       	ret

0000257a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    257a:	df 93       	push	r29
    257c:	cf 93       	push	r28
    257e:	cd b7       	in	r28, 0x3d	; 61
    2580:	de b7       	in	r29, 0x3e	; 62
    2582:	27 97       	sbiw	r28, 0x07	; 7
    2584:	0f b6       	in	r0, 0x3f	; 63
    2586:	f8 94       	cli
    2588:	de bf       	out	0x3e, r29	; 62
    258a:	0f be       	out	0x3f, r0	; 63
    258c:	cd bf       	out	0x3d, r28	; 61
    258e:	9d 83       	std	Y+5, r25	; 0x05
    2590:	8c 83       	std	Y+4, r24	; 0x04
    2592:	6e 83       	std	Y+6, r22	; 0x06
    2594:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    2596:	8a e1       	ldi	r24, 0x1A	; 26
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    259e:	9a 83       	std	Y+2, r25	; 0x02
    25a0:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    25a2:	89 81       	ldd	r24, Y+1	; 0x01
    25a4:	9a 81       	ldd	r25, Y+2	; 0x02
    25a6:	00 97       	sbiw	r24, 0x00	; 0
    25a8:	09 f4       	brne	.+2      	; 0x25ac <xCoRoutineCreate+0x32>
    25aa:	6f c0       	rjmp	.+222    	; 0x268a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    25ac:	80 91 d1 00 	lds	r24, 0x00D1
    25b0:	90 91 d2 00 	lds	r25, 0x00D2
    25b4:	00 97       	sbiw	r24, 0x00	; 0
    25b6:	41 f4       	brne	.+16     	; 0x25c8 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	90 93 d2 00 	sts	0x00D2, r25
    25c0:	80 93 d1 00 	sts	0x00D1, r24
			prvInitialiseCoRoutineLists();
    25c4:	0e 94 24 15 	call	0x2a48	; 0x2a48 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    25c8:	8e 81       	ldd	r24, Y+6	; 0x06
    25ca:	82 30       	cpi	r24, 0x02	; 2
    25cc:	10 f0       	brcs	.+4      	; 0x25d2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    25d2:	e9 81       	ldd	r30, Y+1	; 0x01
    25d4:	fa 81       	ldd	r31, Y+2	; 0x02
    25d6:	11 8e       	std	Z+25, r1	; 0x19
    25d8:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    25da:	e9 81       	ldd	r30, Y+1	; 0x01
    25dc:	fa 81       	ldd	r31, Y+2	; 0x02
    25de:	8e 81       	ldd	r24, Y+6	; 0x06
    25e0:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    25e2:	e9 81       	ldd	r30, Y+1	; 0x01
    25e4:	fa 81       	ldd	r31, Y+2	; 0x02
    25e6:	8f 81       	ldd	r24, Y+7	; 0x07
    25e8:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    25ea:	e9 81       	ldd	r30, Y+1	; 0x01
    25ec:	fa 81       	ldd	r31, Y+2	; 0x02
    25ee:	8c 81       	ldd	r24, Y+4	; 0x04
    25f0:	9d 81       	ldd	r25, Y+5	; 0x05
    25f2:	91 83       	std	Z+1, r25	; 0x01
    25f4:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	02 96       	adiw	r24, 0x02	; 2
    25fc:	0e 94 6d 1a 	call	0x34da	; 0x34da <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2600:	89 81       	ldd	r24, Y+1	; 0x01
    2602:	9a 81       	ldd	r25, Y+2	; 0x02
    2604:	0c 96       	adiw	r24, 0x0c	; 12
    2606:	0e 94 6d 1a 	call	0x34da	; 0x34da <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    260a:	e9 81       	ldd	r30, Y+1	; 0x01
    260c:	fa 81       	ldd	r31, Y+2	; 0x02
    260e:	89 81       	ldd	r24, Y+1	; 0x01
    2610:	9a 81       	ldd	r25, Y+2	; 0x02
    2612:	91 87       	std	Z+9, r25	; 0x09
    2614:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2616:	e9 81       	ldd	r30, Y+1	; 0x01
    2618:	fa 81       	ldd	r31, Y+2	; 0x02
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	93 8b       	std	Z+19, r25	; 0x13
    2620:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2622:	8e 81       	ldd	r24, Y+6	; 0x06
    2624:	28 2f       	mov	r18, r24
    2626:	30 e0       	ldi	r19, 0x00	; 0
    2628:	82 e0       	ldi	r24, 0x02	; 2
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	82 1b       	sub	r24, r18
    262e:	93 0b       	sbc	r25, r19
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	95 87       	std	Z+13, r25	; 0x0d
    2636:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2638:	e9 81       	ldd	r30, Y+1	; 0x01
    263a:	fa 81       	ldd	r31, Y+2	; 0x02
    263c:	96 89       	ldd	r25, Z+22	; 0x16
    263e:	80 91 d3 00 	lds	r24, 0x00D3
    2642:	89 17       	cp	r24, r25
    2644:	28 f4       	brcc	.+10     	; 0x2650 <xCoRoutineCreate+0xd6>
    2646:	e9 81       	ldd	r30, Y+1	; 0x01
    2648:	fa 81       	ldd	r31, Y+2	; 0x02
    264a:	86 89       	ldd	r24, Z+22	; 0x16
    264c:	80 93 d3 00 	sts	0x00D3, r24
    2650:	e9 81       	ldd	r30, Y+1	; 0x01
    2652:	fa 81       	ldd	r31, Y+2	; 0x02
    2654:	86 89       	ldd	r24, Z+22	; 0x16
    2656:	28 2f       	mov	r18, r24
    2658:	30 e0       	ldi	r19, 0x00	; 0
    265a:	c9 01       	movw	r24, r18
    265c:	88 0f       	add	r24, r24
    265e:	99 1f       	adc	r25, r25
    2660:	88 0f       	add	r24, r24
    2662:	99 1f       	adc	r25, r25
    2664:	88 0f       	add	r24, r24
    2666:	99 1f       	adc	r25, r25
    2668:	82 0f       	add	r24, r18
    266a:	93 1f       	adc	r25, r19
    266c:	ac 01       	movw	r20, r24
    266e:	46 52       	subi	r20, 0x26	; 38
    2670:	5f 4f       	sbci	r21, 0xFF	; 255
    2672:	89 81       	ldd	r24, Y+1	; 0x01
    2674:	9a 81       	ldd	r25, Y+2	; 0x02
    2676:	9c 01       	movw	r18, r24
    2678:	2e 5f       	subi	r18, 0xFE	; 254
    267a:	3f 4f       	sbci	r19, 0xFF	; 255
    267c:	ca 01       	movw	r24, r20
    267e:	b9 01       	movw	r22, r18
    2680:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

		xReturn = pdPASS;
    2684:	81 e0       	ldi	r24, 0x01	; 1
    2686:	8b 83       	std	Y+3, r24	; 0x03
    2688:	02 c0       	rjmp	.+4      	; 0x268e <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    268a:	8f ef       	ldi	r24, 0xFF	; 255
    268c:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
    268e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2690:	27 96       	adiw	r28, 0x07	; 7
    2692:	0f b6       	in	r0, 0x3f	; 63
    2694:	f8 94       	cli
    2696:	de bf       	out	0x3e, r29	; 62
    2698:	0f be       	out	0x3f, r0	; 63
    269a:	cd bf       	out	0x3d, r28	; 61
    269c:	cf 91       	pop	r28
    269e:	df 91       	pop	r29
    26a0:	08 95       	ret

000026a2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    26a2:	df 93       	push	r29
    26a4:	cf 93       	push	r28
    26a6:	00 d0       	rcall	.+0      	; 0x26a8 <vCoRoutineAddToDelayedList+0x6>
    26a8:	00 d0       	rcall	.+0      	; 0x26aa <vCoRoutineAddToDelayedList+0x8>
    26aa:	00 d0       	rcall	.+0      	; 0x26ac <vCoRoutineAddToDelayedList+0xa>
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	9c 83       	std	Y+4, r25	; 0x04
    26b2:	8b 83       	std	Y+3, r24	; 0x03
    26b4:	7e 83       	std	Y+6, r23	; 0x06
    26b6:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    26b8:	20 91 d4 00 	lds	r18, 0x00D4
    26bc:	30 91 d5 00 	lds	r19, 0x00D5
    26c0:	8b 81       	ldd	r24, Y+3	; 0x03
    26c2:	9c 81       	ldd	r25, Y+4	; 0x04
    26c4:	82 0f       	add	r24, r18
    26c6:	93 1f       	adc	r25, r19
    26c8:	9a 83       	std	Y+2, r25	; 0x02
    26ca:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26cc:	80 91 d1 00 	lds	r24, 0x00D1
    26d0:	90 91 d2 00 	lds	r25, 0x00D2
    26d4:	02 96       	adiw	r24, 0x02	; 2
    26d6:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    26da:	e0 91 d1 00 	lds	r30, 0x00D1
    26de:	f0 91 d2 00 	lds	r31, 0x00D2
    26e2:	89 81       	ldd	r24, Y+1	; 0x01
    26e4:	9a 81       	ldd	r25, Y+2	; 0x02
    26e6:	93 83       	std	Z+3, r25	; 0x03
    26e8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    26ea:	20 91 d4 00 	lds	r18, 0x00D4
    26ee:	30 91 d5 00 	lds	r19, 0x00D5
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	82 17       	cp	r24, r18
    26f8:	93 07       	cpc	r25, r19
    26fa:	70 f4       	brcc	.+28     	; 0x2718 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    26fc:	80 91 00 01 	lds	r24, 0x0100
    2700:	90 91 01 01 	lds	r25, 0x0101
    2704:	20 91 d1 00 	lds	r18, 0x00D1
    2708:	30 91 d2 00 	lds	r19, 0x00D2
    270c:	2e 5f       	subi	r18, 0xFE	; 254
    270e:	3f 4f       	sbci	r19, 0xFF	; 255
    2710:	b9 01       	movw	r22, r18
    2712:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>
    2716:	0d c0       	rjmp	.+26     	; 0x2732 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2718:	80 91 fe 00 	lds	r24, 0x00FE
    271c:	90 91 ff 00 	lds	r25, 0x00FF
    2720:	20 91 d1 00 	lds	r18, 0x00D1
    2724:	30 91 d2 00 	lds	r19, 0x00D2
    2728:	2e 5f       	subi	r18, 0xFE	; 254
    272a:	3f 4f       	sbci	r19, 0xFF	; 255
    272c:	b9 01       	movw	r22, r18
    272e:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>
	}

	if( pxEventList )
    2732:	8d 81       	ldd	r24, Y+5	; 0x05
    2734:	9e 81       	ldd	r25, Y+6	; 0x06
    2736:	00 97       	sbiw	r24, 0x00	; 0
    2738:	61 f0       	breq	.+24     	; 0x2752 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    273a:	80 91 d1 00 	lds	r24, 0x00D1
    273e:	90 91 d2 00 	lds	r25, 0x00D2
    2742:	9c 01       	movw	r18, r24
    2744:	24 5f       	subi	r18, 0xF4	; 244
    2746:	3f 4f       	sbci	r19, 0xFF	; 255
    2748:	8d 81       	ldd	r24, Y+5	; 0x05
    274a:	9e 81       	ldd	r25, Y+6	; 0x06
    274c:	b9 01       	movw	r22, r18
    274e:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>
	}
}
    2752:	26 96       	adiw	r28, 0x06	; 6
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	f8 94       	cli
    2758:	de bf       	out	0x3e, r29	; 62
    275a:	0f be       	out	0x3f, r0	; 63
    275c:	cd bf       	out	0x3d, r28	; 61
    275e:	cf 91       	pop	r28
    2760:	df 91       	pop	r29
    2762:	08 95       	ret

00002764 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2764:	df 93       	push	r29
    2766:	cf 93       	push	r28
    2768:	00 d0       	rcall	.+0      	; 0x276a <prvCheckPendingReadyList+0x6>
    276a:	cd b7       	in	r28, 0x3d	; 61
    276c:	de b7       	in	r29, 0x3e	; 62
    276e:	3a c0       	rjmp	.+116    	; 0x27e4 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2770:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2772:	e0 91 07 01 	lds	r30, 0x0107
    2776:	f0 91 08 01 	lds	r31, 0x0108
    277a:	86 81       	ldd	r24, Z+6	; 0x06
    277c:	97 81       	ldd	r25, Z+7	; 0x07
    277e:	9a 83       	std	Y+2, r25	; 0x02
    2780:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	9a 81       	ldd	r25, Y+2	; 0x02
    2786:	0c 96       	adiw	r24, 0x0c	; 12
    2788:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    278c:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    278e:	89 81       	ldd	r24, Y+1	; 0x01
    2790:	9a 81       	ldd	r25, Y+2	; 0x02
    2792:	02 96       	adiw	r24, 0x02	; 2
    2794:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2798:	e9 81       	ldd	r30, Y+1	; 0x01
    279a:	fa 81       	ldd	r31, Y+2	; 0x02
    279c:	96 89       	ldd	r25, Z+22	; 0x16
    279e:	80 91 d3 00 	lds	r24, 0x00D3
    27a2:	89 17       	cp	r24, r25
    27a4:	28 f4       	brcc	.+10     	; 0x27b0 <prvCheckPendingReadyList+0x4c>
    27a6:	e9 81       	ldd	r30, Y+1	; 0x01
    27a8:	fa 81       	ldd	r31, Y+2	; 0x02
    27aa:	86 89       	ldd	r24, Z+22	; 0x16
    27ac:	80 93 d3 00 	sts	0x00D3, r24
    27b0:	e9 81       	ldd	r30, Y+1	; 0x01
    27b2:	fa 81       	ldd	r31, Y+2	; 0x02
    27b4:	86 89       	ldd	r24, Z+22	; 0x16
    27b6:	28 2f       	mov	r18, r24
    27b8:	30 e0       	ldi	r19, 0x00	; 0
    27ba:	c9 01       	movw	r24, r18
    27bc:	88 0f       	add	r24, r24
    27be:	99 1f       	adc	r25, r25
    27c0:	88 0f       	add	r24, r24
    27c2:	99 1f       	adc	r25, r25
    27c4:	88 0f       	add	r24, r24
    27c6:	99 1f       	adc	r25, r25
    27c8:	82 0f       	add	r24, r18
    27ca:	93 1f       	adc	r25, r19
    27cc:	ac 01       	movw	r20, r24
    27ce:	46 52       	subi	r20, 0x26	; 38
    27d0:	5f 4f       	sbci	r21, 0xFF	; 255
    27d2:	89 81       	ldd	r24, Y+1	; 0x01
    27d4:	9a 81       	ldd	r25, Y+2	; 0x02
    27d6:	9c 01       	movw	r18, r24
    27d8:	2e 5f       	subi	r18, 0xFE	; 254
    27da:	3f 4f       	sbci	r19, 0xFF	; 255
    27dc:	ca 01       	movw	r24, r20
    27de:	b9 01       	movw	r22, r18
    27e0:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    27e4:	80 91 02 01 	lds	r24, 0x0102
    27e8:	88 23       	and	r24, r24
    27ea:	09 f0       	breq	.+2      	; 0x27ee <prvCheckPendingReadyList+0x8a>
    27ec:	c1 cf       	rjmp	.-126    	; 0x2770 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    27ee:	0f 90       	pop	r0
    27f0:	0f 90       	pop	r0
    27f2:	cf 91       	pop	r28
    27f4:	df 91       	pop	r29
    27f6:	08 95       	ret

000027f8 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    27f8:	df 93       	push	r29
    27fa:	cf 93       	push	r28
    27fc:	00 d0       	rcall	.+0      	; 0x27fe <prvCheckDelayedList+0x6>
    27fe:	00 d0       	rcall	.+0      	; 0x2800 <prvCheckDelayedList+0x8>
    2800:	cd b7       	in	r28, 0x3d	; 61
    2802:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2804:	0e 94 db 2b 	call	0x57b6	; 0x57b6 <xTaskGetTickCount>
    2808:	20 91 d6 00 	lds	r18, 0x00D6
    280c:	30 91 d7 00 	lds	r19, 0x00D7
    2810:	82 1b       	sub	r24, r18
    2812:	93 0b       	sbc	r25, r19
    2814:	90 93 d9 00 	sts	0x00D9, r25
    2818:	80 93 d8 00 	sts	0x00D8, r24
    281c:	85 c0       	rjmp	.+266    	; 0x2928 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    281e:	80 91 d4 00 	lds	r24, 0x00D4
    2822:	90 91 d5 00 	lds	r25, 0x00D5
    2826:	01 96       	adiw	r24, 0x01	; 1
    2828:	90 93 d5 00 	sts	0x00D5, r25
    282c:	80 93 d4 00 	sts	0x00D4, r24
		xPassedTicks--;
    2830:	80 91 d8 00 	lds	r24, 0x00D8
    2834:	90 91 d9 00 	lds	r25, 0x00D9
    2838:	01 97       	sbiw	r24, 0x01	; 1
    283a:	90 93 d9 00 	sts	0x00D9, r25
    283e:	80 93 d8 00 	sts	0x00D8, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2842:	80 91 d4 00 	lds	r24, 0x00D4
    2846:	90 91 d5 00 	lds	r25, 0x00D5
    284a:	00 97       	sbiw	r24, 0x00	; 0
    284c:	09 f0       	breq	.+2      	; 0x2850 <prvCheckDelayedList+0x58>
    284e:	64 c0       	rjmp	.+200    	; 0x2918 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2850:	80 91 fe 00 	lds	r24, 0x00FE
    2854:	90 91 ff 00 	lds	r25, 0x00FF
    2858:	9a 83       	std	Y+2, r25	; 0x02
    285a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    285c:	80 91 00 01 	lds	r24, 0x0100
    2860:	90 91 01 01 	lds	r25, 0x0101
    2864:	90 93 ff 00 	sts	0x00FF, r25
    2868:	80 93 fe 00 	sts	0x00FE, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    286c:	89 81       	ldd	r24, Y+1	; 0x01
    286e:	9a 81       	ldd	r25, Y+2	; 0x02
    2870:	90 93 01 01 	sts	0x0101, r25
    2874:	80 93 00 01 	sts	0x0100, r24
    2878:	4f c0       	rjmp	.+158    	; 0x2918 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    287a:	e0 91 fe 00 	lds	r30, 0x00FE
    287e:	f0 91 ff 00 	lds	r31, 0x00FF
    2882:	05 80       	ldd	r0, Z+5	; 0x05
    2884:	f6 81       	ldd	r31, Z+6	; 0x06
    2886:	e0 2d       	mov	r30, r0
    2888:	86 81       	ldd	r24, Z+6	; 0x06
    288a:	97 81       	ldd	r25, Z+7	; 0x07
    288c:	9c 83       	std	Y+4, r25	; 0x04
    288e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2890:	eb 81       	ldd	r30, Y+3	; 0x03
    2892:	fc 81       	ldd	r31, Y+4	; 0x04
    2894:	22 81       	ldd	r18, Z+2	; 0x02
    2896:	33 81       	ldd	r19, Z+3	; 0x03
    2898:	80 91 d4 00 	lds	r24, 0x00D4
    289c:	90 91 d5 00 	lds	r25, 0x00D5
    28a0:	82 17       	cp	r24, r18
    28a2:	93 07       	cpc	r25, r19
    28a4:	08 f4       	brcc	.+2      	; 0x28a8 <prvCheckDelayedList+0xb0>
    28a6:	40 c0       	rjmp	.+128    	; 0x2928 <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    28a8:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	02 96       	adiw	r24, 0x02	; 2
    28b0:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    28b4:	eb 81       	ldd	r30, Y+3	; 0x03
    28b6:	fc 81       	ldd	r31, Y+4	; 0x04
    28b8:	84 89       	ldd	r24, Z+20	; 0x14
    28ba:	95 89       	ldd	r25, Z+21	; 0x15
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	29 f0       	breq	.+10     	; 0x28ca <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    28c0:	8b 81       	ldd	r24, Y+3	; 0x03
    28c2:	9c 81       	ldd	r25, Y+4	; 0x04
    28c4:	0c 96       	adiw	r24, 0x0c	; 12
    28c6:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    28ca:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    28cc:	eb 81       	ldd	r30, Y+3	; 0x03
    28ce:	fc 81       	ldd	r31, Y+4	; 0x04
    28d0:	96 89       	ldd	r25, Z+22	; 0x16
    28d2:	80 91 d3 00 	lds	r24, 0x00D3
    28d6:	89 17       	cp	r24, r25
    28d8:	28 f4       	brcc	.+10     	; 0x28e4 <prvCheckDelayedList+0xec>
    28da:	eb 81       	ldd	r30, Y+3	; 0x03
    28dc:	fc 81       	ldd	r31, Y+4	; 0x04
    28de:	86 89       	ldd	r24, Z+22	; 0x16
    28e0:	80 93 d3 00 	sts	0x00D3, r24
    28e4:	eb 81       	ldd	r30, Y+3	; 0x03
    28e6:	fc 81       	ldd	r31, Y+4	; 0x04
    28e8:	86 89       	ldd	r24, Z+22	; 0x16
    28ea:	28 2f       	mov	r18, r24
    28ec:	30 e0       	ldi	r19, 0x00	; 0
    28ee:	c9 01       	movw	r24, r18
    28f0:	88 0f       	add	r24, r24
    28f2:	99 1f       	adc	r25, r25
    28f4:	88 0f       	add	r24, r24
    28f6:	99 1f       	adc	r25, r25
    28f8:	88 0f       	add	r24, r24
    28fa:	99 1f       	adc	r25, r25
    28fc:	82 0f       	add	r24, r18
    28fe:	93 1f       	adc	r25, r19
    2900:	ac 01       	movw	r20, r24
    2902:	46 52       	subi	r20, 0x26	; 38
    2904:	5f 4f       	sbci	r21, 0xFF	; 255
    2906:	8b 81       	ldd	r24, Y+3	; 0x03
    2908:	9c 81       	ldd	r25, Y+4	; 0x04
    290a:	9c 01       	movw	r18, r24
    290c:	2e 5f       	subi	r18, 0xFE	; 254
    290e:	3f 4f       	sbci	r19, 0xFF	; 255
    2910:	ca 01       	movw	r24, r20
    2912:	b9 01       	movw	r22, r18
    2914:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2918:	e0 91 fe 00 	lds	r30, 0x00FE
    291c:	f0 91 ff 00 	lds	r31, 0x00FF
    2920:	80 81       	ld	r24, Z
    2922:	88 23       	and	r24, r24
    2924:	09 f0       	breq	.+2      	; 0x2928 <prvCheckDelayedList+0x130>
    2926:	a9 cf       	rjmp	.-174    	; 0x287a <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2928:	80 91 d8 00 	lds	r24, 0x00D8
    292c:	90 91 d9 00 	lds	r25, 0x00D9
    2930:	00 97       	sbiw	r24, 0x00	; 0
    2932:	09 f0       	breq	.+2      	; 0x2936 <prvCheckDelayedList+0x13e>
    2934:	74 cf       	rjmp	.-280    	; 0x281e <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2936:	80 91 d4 00 	lds	r24, 0x00D4
    293a:	90 91 d5 00 	lds	r25, 0x00D5
    293e:	90 93 d7 00 	sts	0x00D7, r25
    2942:	80 93 d6 00 	sts	0x00D6, r24
}
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	0f 90       	pop	r0
    294c:	0f 90       	pop	r0
    294e:	cf 91       	pop	r28
    2950:	df 91       	pop	r29
    2952:	08 95       	ret

00002954 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2954:	df 93       	push	r29
    2956:	cf 93       	push	r28
    2958:	00 d0       	rcall	.+0      	; 0x295a <vCoRoutineSchedule+0x6>
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    295e:	0e 94 b2 13 	call	0x2764	; 0x2764 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2962:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <prvCheckDelayedList>
    2966:	0a c0       	rjmp	.+20     	; 0x297c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2968:	80 91 d3 00 	lds	r24, 0x00D3
    296c:	88 23       	and	r24, r24
    296e:	09 f4       	brne	.+2      	; 0x2972 <vCoRoutineSchedule+0x1e>
    2970:	66 c0       	rjmp	.+204    	; 0x2a3e <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2972:	80 91 d3 00 	lds	r24, 0x00D3
    2976:	81 50       	subi	r24, 0x01	; 1
    2978:	80 93 d3 00 	sts	0x00D3, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    297c:	80 91 d3 00 	lds	r24, 0x00D3
    2980:	28 2f       	mov	r18, r24
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	c9 01       	movw	r24, r18
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	88 0f       	add	r24, r24
    298c:	99 1f       	adc	r25, r25
    298e:	88 0f       	add	r24, r24
    2990:	99 1f       	adc	r25, r25
    2992:	82 0f       	add	r24, r18
    2994:	93 1f       	adc	r25, r19
    2996:	fc 01       	movw	r30, r24
    2998:	e6 52       	subi	r30, 0x26	; 38
    299a:	ff 4f       	sbci	r31, 0xFF	; 255
    299c:	80 81       	ld	r24, Z
    299e:	88 23       	and	r24, r24
    29a0:	19 f3       	breq	.-58     	; 0x2968 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    29a2:	80 91 d3 00 	lds	r24, 0x00D3
    29a6:	28 2f       	mov	r18, r24
    29a8:	30 e0       	ldi	r19, 0x00	; 0
    29aa:	c9 01       	movw	r24, r18
    29ac:	88 0f       	add	r24, r24
    29ae:	99 1f       	adc	r25, r25
    29b0:	88 0f       	add	r24, r24
    29b2:	99 1f       	adc	r25, r25
    29b4:	88 0f       	add	r24, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	82 0f       	add	r24, r18
    29ba:	93 1f       	adc	r25, r19
    29bc:	86 52       	subi	r24, 0x26	; 38
    29be:	9f 4f       	sbci	r25, 0xFF	; 255
    29c0:	9a 83       	std	Y+2, r25	; 0x02
    29c2:	89 83       	std	Y+1, r24	; 0x01
    29c4:	e9 81       	ldd	r30, Y+1	; 0x01
    29c6:	fa 81       	ldd	r31, Y+2	; 0x02
    29c8:	01 80       	ldd	r0, Z+1	; 0x01
    29ca:	f2 81       	ldd	r31, Z+2	; 0x02
    29cc:	e0 2d       	mov	r30, r0
    29ce:	82 81       	ldd	r24, Z+2	; 0x02
    29d0:	93 81       	ldd	r25, Z+3	; 0x03
    29d2:	e9 81       	ldd	r30, Y+1	; 0x01
    29d4:	fa 81       	ldd	r31, Y+2	; 0x02
    29d6:	92 83       	std	Z+2, r25	; 0x02
    29d8:	81 83       	std	Z+1, r24	; 0x01
    29da:	e9 81       	ldd	r30, Y+1	; 0x01
    29dc:	fa 81       	ldd	r31, Y+2	; 0x02
    29de:	21 81       	ldd	r18, Z+1	; 0x01
    29e0:	32 81       	ldd	r19, Z+2	; 0x02
    29e2:	89 81       	ldd	r24, Y+1	; 0x01
    29e4:	9a 81       	ldd	r25, Y+2	; 0x02
    29e6:	03 96       	adiw	r24, 0x03	; 3
    29e8:	28 17       	cp	r18, r24
    29ea:	39 07       	cpc	r19, r25
    29ec:	59 f4       	brne	.+22     	; 0x2a04 <vCoRoutineSchedule+0xb0>
    29ee:	e9 81       	ldd	r30, Y+1	; 0x01
    29f0:	fa 81       	ldd	r31, Y+2	; 0x02
    29f2:	01 80       	ldd	r0, Z+1	; 0x01
    29f4:	f2 81       	ldd	r31, Z+2	; 0x02
    29f6:	e0 2d       	mov	r30, r0
    29f8:	82 81       	ldd	r24, Z+2	; 0x02
    29fa:	93 81       	ldd	r25, Z+3	; 0x03
    29fc:	e9 81       	ldd	r30, Y+1	; 0x01
    29fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2a00:	92 83       	std	Z+2, r25	; 0x02
    2a02:	81 83       	std	Z+1, r24	; 0x01
    2a04:	e9 81       	ldd	r30, Y+1	; 0x01
    2a06:	fa 81       	ldd	r31, Y+2	; 0x02
    2a08:	01 80       	ldd	r0, Z+1	; 0x01
    2a0a:	f2 81       	ldd	r31, Z+2	; 0x02
    2a0c:	e0 2d       	mov	r30, r0
    2a0e:	86 81       	ldd	r24, Z+6	; 0x06
    2a10:	97 81       	ldd	r25, Z+7	; 0x07
    2a12:	90 93 d2 00 	sts	0x00D2, r25
    2a16:	80 93 d1 00 	sts	0x00D1, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2a1a:	e0 91 d1 00 	lds	r30, 0x00D1
    2a1e:	f0 91 d2 00 	lds	r31, 0x00D2
    2a22:	40 81       	ld	r20, Z
    2a24:	51 81       	ldd	r21, Z+1	; 0x01
    2a26:	80 91 d1 00 	lds	r24, 0x00D1
    2a2a:	90 91 d2 00 	lds	r25, 0x00D2
    2a2e:	e0 91 d1 00 	lds	r30, 0x00D1
    2a32:	f0 91 d2 00 	lds	r31, 0x00D2
    2a36:	27 89       	ldd	r18, Z+23	; 0x17
    2a38:	62 2f       	mov	r22, r18
    2a3a:	fa 01       	movw	r30, r20
    2a3c:	09 95       	icall

	return;
}
    2a3e:	0f 90       	pop	r0
    2a40:	0f 90       	pop	r0
    2a42:	cf 91       	pop	r28
    2a44:	df 91       	pop	r29
    2a46:	08 95       	ret

00002a48 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2a48:	df 93       	push	r29
    2a4a:	cf 93       	push	r28
    2a4c:	0f 92       	push	r0
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a52:	19 82       	std	Y+1, r1	; 0x01
    2a54:	13 c0       	rjmp	.+38     	; 0x2a7c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2a56:	89 81       	ldd	r24, Y+1	; 0x01
    2a58:	28 2f       	mov	r18, r24
    2a5a:	30 e0       	ldi	r19, 0x00	; 0
    2a5c:	c9 01       	movw	r24, r18
    2a5e:	88 0f       	add	r24, r24
    2a60:	99 1f       	adc	r25, r25
    2a62:	88 0f       	add	r24, r24
    2a64:	99 1f       	adc	r25, r25
    2a66:	88 0f       	add	r24, r24
    2a68:	99 1f       	adc	r25, r25
    2a6a:	82 0f       	add	r24, r18
    2a6c:	93 1f       	adc	r25, r19
    2a6e:	86 52       	subi	r24, 0x26	; 38
    2a70:	9f 4f       	sbci	r25, 0xFF	; 255
    2a72:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2a76:	89 81       	ldd	r24, Y+1	; 0x01
    2a78:	8f 5f       	subi	r24, 0xFF	; 255
    2a7a:	89 83       	std	Y+1, r24	; 0x01
    2a7c:	89 81       	ldd	r24, Y+1	; 0x01
    2a7e:	82 30       	cpi	r24, 0x02	; 2
    2a80:	50 f3       	brcs	.-44     	; 0x2a56 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    2a82:	8c ee       	ldi	r24, 0xEC	; 236
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    2a8a:	85 ef       	ldi	r24, 0xF5	; 245
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    2a92:	82 e0       	ldi	r24, 0x02	; 2
    2a94:	91 e0       	ldi	r25, 0x01	; 1
    2a96:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2a9a:	8c ee       	ldi	r24, 0xEC	; 236
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	90 93 ff 00 	sts	0x00FF, r25
    2aa2:	80 93 fe 00 	sts	0x00FE, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2aa6:	85 ef       	ldi	r24, 0xF5	; 245
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	90 93 01 01 	sts	0x0101, r25
    2aae:	80 93 00 01 	sts	0x0100, r24
}
    2ab2:	0f 90       	pop	r0
    2ab4:	cf 91       	pop	r28
    2ab6:	df 91       	pop	r29
    2ab8:	08 95       	ret

00002aba <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    2aba:	df 93       	push	r29
    2abc:	cf 93       	push	r28
    2abe:	00 d0       	rcall	.+0      	; 0x2ac0 <xCoRoutineRemoveFromEventList+0x6>
    2ac0:	00 d0       	rcall	.+0      	; 0x2ac2 <xCoRoutineRemoveFromEventList+0x8>
    2ac2:	0f 92       	push	r0
    2ac4:	cd b7       	in	r28, 0x3d	; 61
    2ac6:	de b7       	in	r29, 0x3e	; 62
    2ac8:	9d 83       	std	Y+5, r25	; 0x05
    2aca:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2acc:	ec 81       	ldd	r30, Y+4	; 0x04
    2ace:	fd 81       	ldd	r31, Y+5	; 0x05
    2ad0:	05 80       	ldd	r0, Z+5	; 0x05
    2ad2:	f6 81       	ldd	r31, Z+6	; 0x06
    2ad4:	e0 2d       	mov	r30, r0
    2ad6:	86 81       	ldd	r24, Z+6	; 0x06
    2ad8:	97 81       	ldd	r25, Z+7	; 0x07
    2ada:	9b 83       	std	Y+3, r25	; 0x03
    2adc:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2ade:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae2:	0c 96       	adiw	r24, 0x0c	; 12
    2ae4:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aea:	9b 81       	ldd	r25, Y+3	; 0x03
    2aec:	9c 01       	movw	r18, r24
    2aee:	24 5f       	subi	r18, 0xF4	; 244
    2af0:	3f 4f       	sbci	r19, 0xFF	; 255
    2af2:	82 e0       	ldi	r24, 0x02	; 2
    2af4:	91 e0       	ldi	r25, 0x01	; 1
    2af6:	b9 01       	movw	r22, r18
    2af8:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2afc:	ea 81       	ldd	r30, Y+2	; 0x02
    2afe:	fb 81       	ldd	r31, Y+3	; 0x03
    2b00:	96 89       	ldd	r25, Z+22	; 0x16
    2b02:	e0 91 d1 00 	lds	r30, 0x00D1
    2b06:	f0 91 d2 00 	lds	r31, 0x00D2
    2b0a:	86 89       	ldd	r24, Z+22	; 0x16
    2b0c:	98 17       	cp	r25, r24
    2b0e:	18 f0       	brcs	.+6      	; 0x2b16 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	89 83       	std	Y+1, r24	; 0x01
    2b14:	01 c0       	rjmp	.+2      	; 0x2b18 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2b16:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b18:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b1a:	0f 90       	pop	r0
    2b1c:	0f 90       	pop	r0
    2b1e:	0f 90       	pop	r0
    2b20:	0f 90       	pop	r0
    2b22:	0f 90       	pop	r0
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	08 95       	ret

00002b2a <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	00 d0       	rcall	.+0      	; 0x2b30 <xEventGroupCreate+0x6>
    2b30:	cd b7       	in	r28, 0x3d	; 61
    2b32:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    2b34:	8c e0       	ldi	r24, 0x0C	; 12
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    2b3c:	9a 83       	std	Y+2, r25	; 0x02
    2b3e:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
    2b40:	89 81       	ldd	r24, Y+1	; 0x01
    2b42:	9a 81       	ldd	r25, Y+2	; 0x02
    2b44:	00 97       	sbiw	r24, 0x00	; 0
    2b46:	49 f0       	breq	.+18     	; 0x2b5a <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
    2b48:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4c:	11 82       	std	Z+1, r1	; 0x01
    2b4e:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2b50:	89 81       	ldd	r24, Y+1	; 0x01
    2b52:	9a 81       	ldd	r25, Y+2	; 0x02
    2b54:	02 96       	adiw	r24, 0x02	; 2
    2b56:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    2b5a:	89 81       	ldd	r24, Y+1	; 0x01
    2b5c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b5e:	0f 90       	pop	r0
    2b60:	0f 90       	pop	r0
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62
    2b70:	60 97       	sbiw	r28, 0x10	; 16
    2b72:	0f b6       	in	r0, 0x3f	; 63
    2b74:	f8 94       	cli
    2b76:	de bf       	out	0x3e, r29	; 62
    2b78:	0f be       	out	0x3f, r0	; 63
    2b7a:	cd bf       	out	0x3d, r28	; 61
    2b7c:	9a 87       	std	Y+10, r25	; 0x0a
    2b7e:	89 87       	std	Y+9, r24	; 0x09
    2b80:	7c 87       	std	Y+12, r23	; 0x0c
    2b82:	6b 87       	std	Y+11, r22	; 0x0b
    2b84:	5e 87       	std	Y+14, r21	; 0x0e
    2b86:	4d 87       	std	Y+13, r20	; 0x0d
    2b88:	38 8b       	std	Y+16, r19	; 0x10
    2b8a:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2b8c:	89 85       	ldd	r24, Y+9	; 0x09
    2b8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b90:	9c 83       	std	Y+4, r25	; 0x04
    2b92:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2b94:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2b96:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9e:	80 81       	ld	r24, Z
    2ba0:	91 81       	ldd	r25, Z+1	; 0x01
    2ba2:	98 87       	std	Y+8, r25	; 0x08
    2ba4:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2ba6:	89 85       	ldd	r24, Y+9	; 0x09
    2ba8:	9a 85       	ldd	r25, Y+10	; 0x0a
    2baa:	2b 85       	ldd	r18, Y+11	; 0x0b
    2bac:	3c 85       	ldd	r19, Y+12	; 0x0c
    2bae:	b9 01       	movw	r22, r18
    2bb0:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2bb4:	2f 81       	ldd	r18, Y+7	; 0x07
    2bb6:	38 85       	ldd	r19, Y+8	; 0x08
    2bb8:	8b 85       	ldd	r24, Y+11	; 0x0b
    2bba:	9c 85       	ldd	r25, Y+12	; 0x0c
    2bbc:	28 2b       	or	r18, r24
    2bbe:	39 2b       	or	r19, r25
    2bc0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bc2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bc4:	28 23       	and	r18, r24
    2bc6:	39 23       	and	r19, r25
    2bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bca:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bcc:	28 17       	cp	r18, r24
    2bce:	39 07       	cpc	r19, r25
    2bd0:	c9 f4       	brne	.+50     	; 0x2c04 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2bd2:	2f 81       	ldd	r18, Y+7	; 0x07
    2bd4:	38 85       	ldd	r19, Y+8	; 0x08
    2bd6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2bd8:	9c 85       	ldd	r25, Y+12	; 0x0c
    2bda:	82 2b       	or	r24, r18
    2bdc:	93 2b       	or	r25, r19
    2bde:	9e 83       	std	Y+6, r25	; 0x06
    2be0:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2be2:	eb 81       	ldd	r30, Y+3	; 0x03
    2be4:	fc 81       	ldd	r31, Y+4	; 0x04
    2be6:	20 81       	ld	r18, Z
    2be8:	31 81       	ldd	r19, Z+1	; 0x01
    2bea:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bec:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bee:	80 95       	com	r24
    2bf0:	90 95       	com	r25
    2bf2:	82 23       	and	r24, r18
    2bf4:	93 23       	and	r25, r19
    2bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfa:	91 83       	std	Z+1, r25	; 0x01
    2bfc:	80 83       	st	Z, r24

			xTicksToWait = 0;
    2bfe:	18 8a       	std	Y+16, r1	; 0x10
    2c00:	1f 86       	std	Y+15, r1	; 0x0f
    2c02:	1c c0       	rjmp	.+56     	; 0x2c3c <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2c04:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c06:	98 89       	ldd	r25, Y+16	; 0x10
    2c08:	00 97       	sbiw	r24, 0x00	; 0
    2c0a:	91 f0       	breq	.+36     	; 0x2c30 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c10:	bc 01       	movw	r22, r24
    2c12:	6e 5f       	subi	r22, 0xFE	; 254
    2c14:	7f 4f       	sbci	r23, 0xFF	; 255
    2c16:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c18:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c1a:	9c 01       	movw	r18, r24
    2c1c:	35 60       	ori	r19, 0x05	; 5
    2c1e:	4f 85       	ldd	r20, Y+15	; 0x0f
    2c20:	58 89       	ldd	r21, Y+16	; 0x10
    2c22:	cb 01       	movw	r24, r22
    2c24:	b9 01       	movw	r22, r18
    2c26:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    2c2a:	1e 82       	std	Y+6, r1	; 0x06
    2c2c:	1d 82       	std	Y+5, r1	; 0x05
    2c2e:	06 c0       	rjmp	.+12     	; 0x2c3c <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2c30:	eb 81       	ldd	r30, Y+3	; 0x03
    2c32:	fc 81       	ldd	r31, Y+4	; 0x04
    2c34:	80 81       	ld	r24, Z
    2c36:	91 81       	ldd	r25, Z+1	; 0x01
    2c38:	9e 83       	std	Y+6, r25	; 0x06
    2c3a:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2c3c:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    2c40:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2c42:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c44:	98 89       	ldd	r25, Y+16	; 0x10
    2c46:	00 97       	sbiw	r24, 0x00	; 0
    2c48:	09 f4       	brne	.+2      	; 0x2c4c <xEventGroupSync+0xe4>
    2c4a:	3a c0       	rjmp	.+116    	; 0x2cc0 <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    2c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4e:	88 23       	and	r24, r24
    2c50:	11 f4       	brne	.+4      	; 0x2c56 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    2c52:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2c56:	0e 94 23 35 	call	0x6a46	; 0x6a46 <uxTaskResetEventItemValue>
    2c5a:	9e 83       	std	Y+6, r25	; 0x06
    2c5c:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2c5e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c60:	9e 81       	ldd	r25, Y+6	; 0x06
    2c62:	80 70       	andi	r24, 0x00	; 0
    2c64:	92 70       	andi	r25, 0x02	; 2
    2c66:	00 97       	sbiw	r24, 0x00	; 0
    2c68:	31 f5       	brne	.+76     	; 0x2cb6 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2c6a:	0f b6       	in	r0, 0x3f	; 63
    2c6c:	f8 94       	cli
    2c6e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2c70:	eb 81       	ldd	r30, Y+3	; 0x03
    2c72:	fc 81       	ldd	r31, Y+4	; 0x04
    2c74:	80 81       	ld	r24, Z
    2c76:	91 81       	ldd	r25, Z+1	; 0x01
    2c78:	9e 83       	std	Y+6, r25	; 0x06
    2c7a:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2c7c:	2d 81       	ldd	r18, Y+5	; 0x05
    2c7e:	3e 81       	ldd	r19, Y+6	; 0x06
    2c80:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c82:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c84:	28 23       	and	r18, r24
    2c86:	39 23       	and	r19, r25
    2c88:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c8c:	28 17       	cp	r18, r24
    2c8e:	39 07       	cpc	r19, r25
    2c90:	71 f4       	brne	.+28     	; 0x2cae <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2c92:	eb 81       	ldd	r30, Y+3	; 0x03
    2c94:	fc 81       	ldd	r31, Y+4	; 0x04
    2c96:	20 81       	ld	r18, Z
    2c98:	31 81       	ldd	r19, Z+1	; 0x01
    2c9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c9e:	80 95       	com	r24
    2ca0:	90 95       	com	r25
    2ca2:	82 23       	and	r24, r18
    2ca4:	93 23       	and	r25, r19
    2ca6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca8:	fc 81       	ldd	r31, Y+4	; 0x04
    2caa:	91 83       	std	Z+1, r25	; 0x01
    2cac:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2cae:	0f 90       	pop	r0
    2cb0:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2cb2:	81 e0       	ldi	r24, 0x01	; 1
    2cb4:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2cb6:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb8:	9e 81       	ldd	r25, Y+6	; 0x06
    2cba:	90 70       	andi	r25, 0x00	; 0
    2cbc:	9e 83       	std	Y+6, r25	; 0x06
    2cbe:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2cc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2cc2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2cc4:	60 96       	adiw	r28, 0x10	; 16
    2cc6:	0f b6       	in	r0, 0x3f	; 63
    2cc8:	f8 94       	cli
    2cca:	de bf       	out	0x3e, r29	; 62
    2ccc:	0f be       	out	0x3f, r0	; 63
    2cce:	cd bf       	out	0x3d, r28	; 61
    2cd0:	cf 91       	pop	r28
    2cd2:	df 91       	pop	r29
    2cd4:	08 95       	ret

00002cd6 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2cd6:	0f 93       	push	r16
    2cd8:	1f 93       	push	r17
    2cda:	df 93       	push	r29
    2cdc:	cf 93       	push	r28
    2cde:	cd b7       	in	r28, 0x3d	; 61
    2ce0:	de b7       	in	r29, 0x3e	; 62
    2ce2:	63 97       	sbiw	r28, 0x13	; 19
    2ce4:	0f b6       	in	r0, 0x3f	; 63
    2ce6:	f8 94       	cli
    2ce8:	de bf       	out	0x3e, r29	; 62
    2cea:	0f be       	out	0x3f, r0	; 63
    2cec:	cd bf       	out	0x3d, r28	; 61
    2cee:	9d 87       	std	Y+13, r25	; 0x0d
    2cf0:	8c 87       	std	Y+12, r24	; 0x0c
    2cf2:	7f 87       	std	Y+15, r23	; 0x0f
    2cf4:	6e 87       	std	Y+14, r22	; 0x0e
    2cf6:	48 8b       	std	Y+16, r20	; 0x10
    2cf8:	29 8b       	std	Y+17, r18	; 0x11
    2cfa:	1b 8b       	std	Y+19, r17	; 0x13
    2cfc:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2cfe:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d00:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d02:	9b 87       	std	Y+11, r25	; 0x0b
    2d04:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    2d06:	1f 82       	std	Y+7, r1	; 0x07
    2d08:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2d0a:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2d0c:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2d10:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d12:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d14:	80 81       	ld	r24, Z
    2d16:	91 81       	ldd	r25, Z+1	; 0x01
    2d18:	9a 83       	std	Y+2, r25	; 0x02
    2d1a:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2d1c:	89 81       	ldd	r24, Y+1	; 0x01
    2d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d20:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d22:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d24:	b9 01       	movw	r22, r18
    2d26:	49 89       	ldd	r20, Y+17	; 0x11
    2d28:	0e 94 a3 18 	call	0x3146	; 0x3146 <prvTestWaitCondition>
    2d2c:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2d2e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d30:	88 23       	and	r24, r24
    2d32:	c1 f0       	breq	.+48     	; 0x2d64 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2d34:	89 81       	ldd	r24, Y+1	; 0x01
    2d36:	9a 81       	ldd	r25, Y+2	; 0x02
    2d38:	99 87       	std	Y+9, r25	; 0x09
    2d3a:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2d3c:	1b 8a       	std	Y+19, r1	; 0x13
    2d3e:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2d40:	88 89       	ldd	r24, Y+16	; 0x10
    2d42:	88 23       	and	r24, r24
    2d44:	d9 f1       	breq	.+118    	; 0x2dbc <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2d46:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d48:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d4a:	20 81       	ld	r18, Z
    2d4c:	31 81       	ldd	r19, Z+1	; 0x01
    2d4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d50:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d52:	80 95       	com	r24
    2d54:	90 95       	com	r25
    2d56:	82 23       	and	r24, r18
    2d58:	93 23       	and	r25, r19
    2d5a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d5c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d5e:	91 83       	std	Z+1, r25	; 0x01
    2d60:	80 83       	st	Z, r24
    2d62:	2c c0       	rjmp	.+88     	; 0x2dbc <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2d64:	8a 89       	ldd	r24, Y+18	; 0x12
    2d66:	9b 89       	ldd	r25, Y+19	; 0x13
    2d68:	00 97       	sbiw	r24, 0x00	; 0
    2d6a:	29 f4       	brne	.+10     	; 0x2d76 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d70:	99 87       	std	Y+9, r25	; 0x09
    2d72:	88 87       	std	Y+8, r24	; 0x08
    2d74:	23 c0       	rjmp	.+70     	; 0x2dbc <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2d76:	88 89       	ldd	r24, Y+16	; 0x10
    2d78:	88 23       	and	r24, r24
    2d7a:	29 f0       	breq	.+10     	; 0x2d86 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2d7c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d7e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d80:	91 60       	ori	r25, 0x01	; 1
    2d82:	9f 83       	std	Y+7, r25	; 0x07
    2d84:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2d86:	89 89       	ldd	r24, Y+17	; 0x11
    2d88:	88 23       	and	r24, r24
    2d8a:	29 f0       	breq	.+10     	; 0x2d96 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2d8c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d8e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d90:	94 60       	ori	r25, 0x04	; 4
    2d92:	9f 83       	std	Y+7, r25	; 0x07
    2d94:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2d96:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d98:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d9a:	bc 01       	movw	r22, r24
    2d9c:	6e 5f       	subi	r22, 0xFE	; 254
    2d9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2da0:	2e 85       	ldd	r18, Y+14	; 0x0e
    2da2:	3f 85       	ldd	r19, Y+15	; 0x0f
    2da4:	8e 81       	ldd	r24, Y+6	; 0x06
    2da6:	9f 81       	ldd	r25, Y+7	; 0x07
    2da8:	28 2b       	or	r18, r24
    2daa:	39 2b       	or	r19, r25
    2dac:	4a 89       	ldd	r20, Y+18	; 0x12
    2dae:	5b 89       	ldd	r21, Y+19	; 0x13
    2db0:	cb 01       	movw	r24, r22
    2db2:	b9 01       	movw	r22, r18
    2db4:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2db8:	19 86       	std	Y+9, r1	; 0x09
    2dba:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2dbc:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    2dc0:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    2dc2:	8a 89       	ldd	r24, Y+18	; 0x12
    2dc4:	9b 89       	ldd	r25, Y+19	; 0x13
    2dc6:	00 97       	sbiw	r24, 0x00	; 0
    2dc8:	09 f4       	brne	.+2      	; 0x2dcc <xEventGroupWaitBits+0xf6>
    2dca:	3b c0       	rjmp	.+118    	; 0x2e42 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    2dcc:	8c 81       	ldd	r24, Y+4	; 0x04
    2dce:	88 23       	and	r24, r24
    2dd0:	11 f4       	brne	.+4      	; 0x2dd6 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    2dd2:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2dd6:	0e 94 23 35 	call	0x6a46	; 0x6a46 <uxTaskResetEventItemValue>
    2dda:	99 87       	std	Y+9, r25	; 0x09
    2ddc:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2dde:	88 85       	ldd	r24, Y+8	; 0x08
    2de0:	99 85       	ldd	r25, Y+9	; 0x09
    2de2:	80 70       	andi	r24, 0x00	; 0
    2de4:	92 70       	andi	r25, 0x02	; 2
    2de6:	00 97       	sbiw	r24, 0x00	; 0
    2de8:	39 f5       	brne	.+78     	; 0x2e38 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    2dea:	0f b6       	in	r0, 0x3f	; 63
    2dec:	f8 94       	cli
    2dee:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2df0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2df2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2df4:	80 81       	ld	r24, Z
    2df6:	91 81       	ldd	r25, Z+1	; 0x01
    2df8:	99 87       	std	Y+9, r25	; 0x09
    2dfa:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2dfc:	88 85       	ldd	r24, Y+8	; 0x08
    2dfe:	99 85       	ldd	r25, Y+9	; 0x09
    2e00:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e02:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e04:	b9 01       	movw	r22, r18
    2e06:	49 89       	ldd	r20, Y+17	; 0x11
    2e08:	0e 94 a3 18 	call	0x3146	; 0x3146 <prvTestWaitCondition>
    2e0c:	88 23       	and	r24, r24
    2e0e:	89 f0       	breq	.+34     	; 0x2e32 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    2e10:	88 89       	ldd	r24, Y+16	; 0x10
    2e12:	88 23       	and	r24, r24
    2e14:	71 f0       	breq	.+28     	; 0x2e32 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2e16:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e18:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e1a:	20 81       	ld	r18, Z
    2e1c:	31 81       	ldd	r19, Z+1	; 0x01
    2e1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e20:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e22:	80 95       	com	r24
    2e24:	90 95       	com	r25
    2e26:	82 23       	and	r24, r18
    2e28:	93 23       	and	r25, r19
    2e2a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e2c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e2e:	91 83       	std	Z+1, r25	; 0x01
    2e30:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2e32:	0f 90       	pop	r0
    2e34:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    2e36:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2e38:	88 85       	ldd	r24, Y+8	; 0x08
    2e3a:	99 85       	ldd	r25, Y+9	; 0x09
    2e3c:	90 70       	andi	r25, 0x00	; 0
    2e3e:	99 87       	std	Y+9, r25	; 0x09
    2e40:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    2e42:	88 85       	ldd	r24, Y+8	; 0x08
    2e44:	99 85       	ldd	r25, Y+9	; 0x09
}
    2e46:	63 96       	adiw	r28, 0x13	; 19
    2e48:	0f b6       	in	r0, 0x3f	; 63
    2e4a:	f8 94       	cli
    2e4c:	de bf       	out	0x3e, r29	; 62
    2e4e:	0f be       	out	0x3f, r0	; 63
    2e50:	cd bf       	out	0x3d, r28	; 61
    2e52:	cf 91       	pop	r28
    2e54:	df 91       	pop	r29
    2e56:	1f 91       	pop	r17
    2e58:	0f 91       	pop	r16
    2e5a:	08 95       	ret

00002e5c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2e5c:	df 93       	push	r29
    2e5e:	cf 93       	push	r28
    2e60:	cd b7       	in	r28, 0x3d	; 61
    2e62:	de b7       	in	r29, 0x3e	; 62
    2e64:	28 97       	sbiw	r28, 0x08	; 8
    2e66:	0f b6       	in	r0, 0x3f	; 63
    2e68:	f8 94       	cli
    2e6a:	de bf       	out	0x3e, r29	; 62
    2e6c:	0f be       	out	0x3f, r0	; 63
    2e6e:	cd bf       	out	0x3d, r28	; 61
    2e70:	9e 83       	std	Y+6, r25	; 0x06
    2e72:	8d 83       	std	Y+5, r24	; 0x05
    2e74:	78 87       	std	Y+8, r23	; 0x08
    2e76:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2e78:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7c:	9c 83       	std	Y+4, r25	; 0x04
    2e7e:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2e80:	0f b6       	in	r0, 0x3f	; 63
    2e82:	f8 94       	cli
    2e84:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2e86:	eb 81       	ldd	r30, Y+3	; 0x03
    2e88:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8a:	80 81       	ld	r24, Z
    2e8c:	91 81       	ldd	r25, Z+1	; 0x01
    2e8e:	9a 83       	std	Y+2, r25	; 0x02
    2e90:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2e92:	eb 81       	ldd	r30, Y+3	; 0x03
    2e94:	fc 81       	ldd	r31, Y+4	; 0x04
    2e96:	20 81       	ld	r18, Z
    2e98:	31 81       	ldd	r19, Z+1	; 0x01
    2e9a:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9c:	98 85       	ldd	r25, Y+8	; 0x08
    2e9e:	80 95       	com	r24
    2ea0:	90 95       	com	r25
    2ea2:	82 23       	and	r24, r18
    2ea4:	93 23       	and	r25, r19
    2ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eaa:	91 83       	std	Z+1, r25	; 0x01
    2eac:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    2eae:	0f 90       	pop	r0
    2eb0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2eb2:	89 81       	ldd	r24, Y+1	; 0x01
    2eb4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2eb6:	28 96       	adiw	r28, 0x08	; 8
    2eb8:	0f b6       	in	r0, 0x3f	; 63
    2eba:	f8 94       	cli
    2ebc:	de bf       	out	0x3e, r29	; 62
    2ebe:	0f be       	out	0x3f, r0	; 63
    2ec0:	cd bf       	out	0x3d, r28	; 61
    2ec2:	cf 91       	pop	r28
    2ec4:	df 91       	pop	r29
    2ec6:	08 95       	ret

00002ec8 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2ec8:	df 93       	push	r29
    2eca:	cf 93       	push	r28
    2ecc:	cd b7       	in	r28, 0x3d	; 61
    2ece:	de b7       	in	r29, 0x3e	; 62
    2ed0:	27 97       	sbiw	r28, 0x07	; 7
    2ed2:	0f b6       	in	r0, 0x3f	; 63
    2ed4:	f8 94       	cli
    2ed6:	de bf       	out	0x3e, r29	; 62
    2ed8:	0f be       	out	0x3f, r0	; 63
    2eda:	cd bf       	out	0x3d, r28	; 61
    2edc:	9f 83       	std	Y+7, r25	; 0x07
    2ede:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2ee0:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee2:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee4:	9c 83       	std	Y+4, r25	; 0x04
    2ee6:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2ee8:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    2eea:	eb 81       	ldd	r30, Y+3	; 0x03
    2eec:	fc 81       	ldd	r31, Y+4	; 0x04
    2eee:	80 81       	ld	r24, Z
    2ef0:	91 81       	ldd	r25, Z+1	; 0x01
    2ef2:	9a 83       	std	Y+2, r25	; 0x02
    2ef4:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2ef6:	89 81       	ldd	r24, Y+1	; 0x01
    2ef8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2efa:	27 96       	adiw	r28, 0x07	; 7
    2efc:	0f b6       	in	r0, 0x3f	; 63
    2efe:	f8 94       	cli
    2f00:	de bf       	out	0x3e, r29	; 62
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	cd bf       	out	0x3d, r28	; 61
    2f06:	cf 91       	pop	r28
    2f08:	df 91       	pop	r29
    2f0a:	08 95       	ret

00002f0c <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2f0c:	df 93       	push	r29
    2f0e:	cf 93       	push	r28
    2f10:	cd b7       	in	r28, 0x3d	; 61
    2f12:	de b7       	in	r29, 0x3e	; 62
    2f14:	65 97       	sbiw	r28, 0x15	; 21
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	de bf       	out	0x3e, r29	; 62
    2f1c:	0f be       	out	0x3f, r0	; 63
    2f1e:	cd bf       	out	0x3d, r28	; 61
    2f20:	9b 8b       	std	Y+19, r25	; 0x13
    2f22:	8a 8b       	std	Y+18, r24	; 0x12
    2f24:	7d 8b       	std	Y+21, r23	; 0x15
    2f26:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2f28:	19 86       	std	Y+9, r1	; 0x09
    2f2a:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    2f2c:	8a 89       	ldd	r24, Y+18	; 0x12
    2f2e:	9b 89       	ldd	r25, Y+19	; 0x13
    2f30:	9b 83       	std	Y+3, r25	; 0x03
    2f32:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    2f34:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2f36:	8a 81       	ldd	r24, Y+2	; 0x02
    2f38:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3a:	02 96       	adiw	r24, 0x02	; 2
    2f3c:	9b 87       	std	Y+11, r25	; 0x0b
    2f3e:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2f40:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f42:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f44:	03 96       	adiw	r24, 0x03	; 3
    2f46:	9d 87       	std	Y+13, r25	; 0x0d
    2f48:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    2f4a:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2f4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f50:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f52:	85 81       	ldd	r24, Z+5	; 0x05
    2f54:	96 81       	ldd	r25, Z+6	; 0x06
    2f56:	99 8b       	std	Y+17, r25	; 0x11
    2f58:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f5e:	20 81       	ld	r18, Z
    2f60:	31 81       	ldd	r19, Z+1	; 0x01
    2f62:	8c 89       	ldd	r24, Y+20	; 0x14
    2f64:	9d 89       	ldd	r25, Y+21	; 0x15
    2f66:	82 2b       	or	r24, r18
    2f68:	93 2b       	or	r25, r19
    2f6a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f6c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f6e:	91 83       	std	Z+1, r25	; 0x01
    2f70:	80 83       	st	Z, r24
    2f72:	59 c0       	rjmp	.+178    	; 0x3026 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    2f74:	e8 89       	ldd	r30, Y+16	; 0x10
    2f76:	f9 89       	ldd	r31, Y+17	; 0x11
    2f78:	82 81       	ldd	r24, Z+2	; 0x02
    2f7a:	93 81       	ldd	r25, Z+3	; 0x03
    2f7c:	9f 87       	std	Y+15, r25	; 0x0f
    2f7e:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2f80:	e8 89       	ldd	r30, Y+16	; 0x10
    2f82:	f9 89       	ldd	r31, Y+17	; 0x11
    2f84:	80 81       	ld	r24, Z
    2f86:	91 81       	ldd	r25, Z+1	; 0x01
    2f88:	9f 83       	std	Y+7, r25	; 0x07
    2f8a:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2f8c:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2f8e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f90:	9f 81       	ldd	r25, Y+7	; 0x07
    2f92:	80 70       	andi	r24, 0x00	; 0
    2f94:	9d 83       	std	Y+5, r25	; 0x05
    2f96:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2f98:	8e 81       	ldd	r24, Y+6	; 0x06
    2f9a:	9f 81       	ldd	r25, Y+7	; 0x07
    2f9c:	90 70       	andi	r25, 0x00	; 0
    2f9e:	9f 83       	std	Y+7, r25	; 0x07
    2fa0:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2fa2:	8c 81       	ldd	r24, Y+4	; 0x04
    2fa4:	9d 81       	ldd	r25, Y+5	; 0x05
    2fa6:	80 70       	andi	r24, 0x00	; 0
    2fa8:	94 70       	andi	r25, 0x04	; 4
    2faa:	00 97       	sbiw	r24, 0x00	; 0
    2fac:	69 f4       	brne	.+26     	; 0x2fc8 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2fae:	ea 81       	ldd	r30, Y+2	; 0x02
    2fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    2fb2:	20 81       	ld	r18, Z
    2fb4:	31 81       	ldd	r19, Z+1	; 0x01
    2fb6:	8e 81       	ldd	r24, Y+6	; 0x06
    2fb8:	9f 81       	ldd	r25, Y+7	; 0x07
    2fba:	82 23       	and	r24, r18
    2fbc:	93 23       	and	r25, r19
    2fbe:	00 97       	sbiw	r24, 0x00	; 0
    2fc0:	91 f0       	breq	.+36     	; 0x2fe6 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    2fc2:	81 e0       	ldi	r24, 0x01	; 1
    2fc4:	89 83       	std	Y+1, r24	; 0x01
    2fc6:	0f c0       	rjmp	.+30     	; 0x2fe6 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2fc8:	ea 81       	ldd	r30, Y+2	; 0x02
    2fca:	fb 81       	ldd	r31, Y+3	; 0x03
    2fcc:	20 81       	ld	r18, Z
    2fce:	31 81       	ldd	r19, Z+1	; 0x01
    2fd0:	8e 81       	ldd	r24, Y+6	; 0x06
    2fd2:	9f 81       	ldd	r25, Y+7	; 0x07
    2fd4:	28 23       	and	r18, r24
    2fd6:	39 23       	and	r19, r25
    2fd8:	8e 81       	ldd	r24, Y+6	; 0x06
    2fda:	9f 81       	ldd	r25, Y+7	; 0x07
    2fdc:	28 17       	cp	r18, r24
    2fde:	39 07       	cpc	r19, r25
    2fe0:	11 f4       	brne	.+4      	; 0x2fe6 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    2fe6:	89 81       	ldd	r24, Y+1	; 0x01
    2fe8:	88 23       	and	r24, r24
    2fea:	c9 f0       	breq	.+50     	; 0x301e <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2fec:	8c 81       	ldd	r24, Y+4	; 0x04
    2fee:	9d 81       	ldd	r25, Y+5	; 0x05
    2ff0:	80 70       	andi	r24, 0x00	; 0
    2ff2:	91 70       	andi	r25, 0x01	; 1
    2ff4:	00 97       	sbiw	r24, 0x00	; 0
    2ff6:	41 f0       	breq	.+16     	; 0x3008 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2ff8:	88 85       	ldd	r24, Y+8	; 0x08
    2ffa:	99 85       	ldd	r25, Y+9	; 0x09
    2ffc:	2e 81       	ldd	r18, Y+6	; 0x06
    2ffe:	3f 81       	ldd	r19, Y+7	; 0x07
    3000:	82 2b       	or	r24, r18
    3002:	93 2b       	or	r25, r19
    3004:	99 87       	std	Y+9, r25	; 0x09
    3006:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    3008:	ea 81       	ldd	r30, Y+2	; 0x02
    300a:	fb 81       	ldd	r31, Y+3	; 0x03
    300c:	80 81       	ld	r24, Z
    300e:	91 81       	ldd	r25, Z+1	; 0x01
    3010:	9c 01       	movw	r18, r24
    3012:	32 60       	ori	r19, 0x02	; 2
    3014:	88 89       	ldd	r24, Y+16	; 0x10
    3016:	99 89       	ldd	r25, Y+17	; 0x11
    3018:	b9 01       	movw	r22, r18
    301a:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    301e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3020:	9f 85       	ldd	r25, Y+15	; 0x0f
    3022:	99 8b       	std	Y+17, r25	; 0x11
    3024:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    3026:	28 89       	ldd	r18, Y+16	; 0x10
    3028:	39 89       	ldd	r19, Y+17	; 0x11
    302a:	8c 85       	ldd	r24, Y+12	; 0x0c
    302c:	9d 85       	ldd	r25, Y+13	; 0x0d
    302e:	28 17       	cp	r18, r24
    3030:	39 07       	cpc	r19, r25
    3032:	09 f0       	breq	.+2      	; 0x3036 <xEventGroupSetBits+0x12a>
    3034:	9f cf       	rjmp	.-194    	; 0x2f74 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    3036:	ea 81       	ldd	r30, Y+2	; 0x02
    3038:	fb 81       	ldd	r31, Y+3	; 0x03
    303a:	20 81       	ld	r18, Z
    303c:	31 81       	ldd	r19, Z+1	; 0x01
    303e:	88 85       	ldd	r24, Y+8	; 0x08
    3040:	99 85       	ldd	r25, Y+9	; 0x09
    3042:	80 95       	com	r24
    3044:	90 95       	com	r25
    3046:	82 23       	and	r24, r18
    3048:	93 23       	and	r25, r19
    304a:	ea 81       	ldd	r30, Y+2	; 0x02
    304c:	fb 81       	ldd	r31, Y+3	; 0x03
    304e:	91 83       	std	Z+1, r25	; 0x01
    3050:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    3052:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    3056:	ea 81       	ldd	r30, Y+2	; 0x02
    3058:	fb 81       	ldd	r31, Y+3	; 0x03
    305a:	80 81       	ld	r24, Z
    305c:	91 81       	ldd	r25, Z+1	; 0x01
}
    305e:	65 96       	adiw	r28, 0x15	; 21
    3060:	0f b6       	in	r0, 0x3f	; 63
    3062:	f8 94       	cli
    3064:	de bf       	out	0x3e, r29	; 62
    3066:	0f be       	out	0x3f, r0	; 63
    3068:	cd bf       	out	0x3d, r28	; 61
    306a:	cf 91       	pop	r28
    306c:	df 91       	pop	r29
    306e:	08 95       	ret

00003070 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    3070:	df 93       	push	r29
    3072:	cf 93       	push	r28
    3074:	00 d0       	rcall	.+0      	; 0x3076 <vEventGroupDelete+0x6>
    3076:	00 d0       	rcall	.+0      	; 0x3078 <vEventGroupDelete+0x8>
    3078:	00 d0       	rcall	.+0      	; 0x307a <vEventGroupDelete+0xa>
    307a:	cd b7       	in	r28, 0x3d	; 61
    307c:	de b7       	in	r29, 0x3e	; 62
    307e:	9e 83       	std	Y+6, r25	; 0x06
    3080:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    3082:	8d 81       	ldd	r24, Y+5	; 0x05
    3084:	9e 81       	ldd	r25, Y+6	; 0x06
    3086:	9c 83       	std	Y+4, r25	; 0x04
    3088:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    308a:	8b 81       	ldd	r24, Y+3	; 0x03
    308c:	9c 81       	ldd	r25, Y+4	; 0x04
    308e:	02 96       	adiw	r24, 0x02	; 2
    3090:	9a 83       	std	Y+2, r25	; 0x02
    3092:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    3094:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
    3098:	08 c0       	rjmp	.+16     	; 0x30aa <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    309a:	e9 81       	ldd	r30, Y+1	; 0x01
    309c:	fa 81       	ldd	r31, Y+2	; 0x02
    309e:	85 81       	ldd	r24, Z+5	; 0x05
    30a0:	96 81       	ldd	r25, Z+6	; 0x06
    30a2:	60 e0       	ldi	r22, 0x00	; 0
    30a4:	72 e0       	ldi	r23, 0x02	; 2
    30a6:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    30aa:	e9 81       	ldd	r30, Y+1	; 0x01
    30ac:	fa 81       	ldd	r31, Y+2	; 0x02
    30ae:	80 81       	ld	r24, Z
    30b0:	88 23       	and	r24, r24
    30b2:	99 f7       	brne	.-26     	; 0x309a <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    30b4:	8b 81       	ldd	r24, Y+3	; 0x03
    30b6:	9c 81       	ldd	r25, Y+4	; 0x04
    30b8:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
	}
	( void ) xTaskResumeAll();
    30bc:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
}
    30c0:	26 96       	adiw	r28, 0x06	; 6
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	cf 91       	pop	r28
    30ce:	df 91       	pop	r29
    30d0:	08 95       	ret

000030d2 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    30d2:	df 93       	push	r29
    30d4:	cf 93       	push	r28
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <vEventGroupSetBitsCallback+0x6>
    30d8:	00 d0       	rcall	.+0      	; 0x30da <vEventGroupSetBitsCallback+0x8>
    30da:	00 d0       	rcall	.+0      	; 0x30dc <vEventGroupSetBitsCallback+0xa>
    30dc:	cd b7       	in	r28, 0x3d	; 61
    30de:	de b7       	in	r29, 0x3e	; 62
    30e0:	9a 83       	std	Y+2, r25	; 0x02
    30e2:	89 83       	std	Y+1, r24	; 0x01
    30e4:	4b 83       	std	Y+3, r20	; 0x03
    30e6:	5c 83       	std	Y+4, r21	; 0x04
    30e8:	6d 83       	std	Y+5, r22	; 0x05
    30ea:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    30ec:	2b 81       	ldd	r18, Y+3	; 0x03
    30ee:	3c 81       	ldd	r19, Y+4	; 0x04
    30f0:	89 81       	ldd	r24, Y+1	; 0x01
    30f2:	9a 81       	ldd	r25, Y+2	; 0x02
    30f4:	b9 01       	movw	r22, r18
    30f6:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <xEventGroupSetBits>
}
    30fa:	26 96       	adiw	r28, 0x06	; 6
    30fc:	0f b6       	in	r0, 0x3f	; 63
    30fe:	f8 94       	cli
    3100:	de bf       	out	0x3e, r29	; 62
    3102:	0f be       	out	0x3f, r0	; 63
    3104:	cd bf       	out	0x3d, r28	; 61
    3106:	cf 91       	pop	r28
    3108:	df 91       	pop	r29
    310a:	08 95       	ret

0000310c <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	00 d0       	rcall	.+0      	; 0x3112 <vEventGroupClearBitsCallback+0x6>
    3112:	00 d0       	rcall	.+0      	; 0x3114 <vEventGroupClearBitsCallback+0x8>
    3114:	00 d0       	rcall	.+0      	; 0x3116 <vEventGroupClearBitsCallback+0xa>
    3116:	cd b7       	in	r28, 0x3d	; 61
    3118:	de b7       	in	r29, 0x3e	; 62
    311a:	9a 83       	std	Y+2, r25	; 0x02
    311c:	89 83       	std	Y+1, r24	; 0x01
    311e:	4b 83       	std	Y+3, r20	; 0x03
    3120:	5c 83       	std	Y+4, r21	; 0x04
    3122:	6d 83       	std	Y+5, r22	; 0x05
    3124:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    3126:	2b 81       	ldd	r18, Y+3	; 0x03
    3128:	3c 81       	ldd	r19, Y+4	; 0x04
    312a:	89 81       	ldd	r24, Y+1	; 0x01
    312c:	9a 81       	ldd	r25, Y+2	; 0x02
    312e:	b9 01       	movw	r22, r18
    3130:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <xEventGroupClearBits>
}
    3134:	26 96       	adiw	r28, 0x06	; 6
    3136:	0f b6       	in	r0, 0x3f	; 63
    3138:	f8 94       	cli
    313a:	de bf       	out	0x3e, r29	; 62
    313c:	0f be       	out	0x3f, r0	; 63
    313e:	cd bf       	out	0x3d, r28	; 61
    3140:	cf 91       	pop	r28
    3142:	df 91       	pop	r29
    3144:	08 95       	ret

00003146 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    3146:	df 93       	push	r29
    3148:	cf 93       	push	r28
    314a:	00 d0       	rcall	.+0      	; 0x314c <prvTestWaitCondition+0x6>
    314c:	00 d0       	rcall	.+0      	; 0x314e <prvTestWaitCondition+0x8>
    314e:	00 d0       	rcall	.+0      	; 0x3150 <prvTestWaitCondition+0xa>
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	9b 83       	std	Y+3, r25	; 0x03
    3156:	8a 83       	std	Y+2, r24	; 0x02
    3158:	7d 83       	std	Y+5, r23	; 0x05
    315a:	6c 83       	std	Y+4, r22	; 0x04
    315c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    315e:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    3160:	8e 81       	ldd	r24, Y+6	; 0x06
    3162:	88 23       	and	r24, r24
    3164:	59 f4       	brne	.+22     	; 0x317c <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    3166:	8a 81       	ldd	r24, Y+2	; 0x02
    3168:	9b 81       	ldd	r25, Y+3	; 0x03
    316a:	2c 81       	ldd	r18, Y+4	; 0x04
    316c:	3d 81       	ldd	r19, Y+5	; 0x05
    316e:	82 23       	and	r24, r18
    3170:	93 23       	and	r25, r19
    3172:	00 97       	sbiw	r24, 0x00	; 0
    3174:	81 f0       	breq	.+32     	; 0x3196 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    3176:	81 e0       	ldi	r24, 0x01	; 1
    3178:	89 83       	std	Y+1, r24	; 0x01
    317a:	0d c0       	rjmp	.+26     	; 0x3196 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    317c:	2a 81       	ldd	r18, Y+2	; 0x02
    317e:	3b 81       	ldd	r19, Y+3	; 0x03
    3180:	8c 81       	ldd	r24, Y+4	; 0x04
    3182:	9d 81       	ldd	r25, Y+5	; 0x05
    3184:	28 23       	and	r18, r24
    3186:	39 23       	and	r19, r25
    3188:	8c 81       	ldd	r24, Y+4	; 0x04
    318a:	9d 81       	ldd	r25, Y+5	; 0x05
    318c:	28 17       	cp	r18, r24
    318e:	39 07       	cpc	r19, r25
    3190:	11 f4       	brne	.+4      	; 0x3196 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    3192:	81 e0       	ldi	r24, 0x01	; 1
    3194:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    3196:	89 81       	ldd	r24, Y+1	; 0x01
}
    3198:	26 96       	adiw	r28, 0x06	; 6
    319a:	0f b6       	in	r0, 0x3f	; 63
    319c:	f8 94       	cli
    319e:	de bf       	out	0x3e, r29	; 62
    31a0:	0f be       	out	0x3f, r0	; 63
    31a2:	cd bf       	out	0x3d, r28	; 61
    31a4:	cf 91       	pop	r28
    31a6:	df 91       	pop	r29
    31a8:	08 95       	ret

000031aa <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
	{
    31aa:	df 93       	push	r29
    31ac:	cf 93       	push	r28
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <uxEventGroupGetNumber+0x6>
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <uxEventGroupGetNumber+0x8>
    31b2:	0f 92       	push	r0
    31b4:	cd b7       	in	r28, 0x3d	; 61
    31b6:	de b7       	in	r29, 0x3e	; 62
    31b8:	9d 83       	std	Y+5, r25	; 0x05
    31ba:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t xReturn;
	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    31bc:	8c 81       	ldd	r24, Y+4	; 0x04
    31be:	9d 81       	ldd	r25, Y+5	; 0x05
    31c0:	9a 83       	std	Y+2, r25	; 0x02
    31c2:	89 83       	std	Y+1, r24	; 0x01

		if( xEventGroup == NULL )
    31c4:	8c 81       	ldd	r24, Y+4	; 0x04
    31c6:	9d 81       	ldd	r25, Y+5	; 0x05
    31c8:	00 97       	sbiw	r24, 0x00	; 0
    31ca:	11 f4       	brne	.+4      	; 0x31d0 <uxEventGroupGetNumber+0x26>
		{
			xReturn = 0;
    31cc:	1b 82       	std	Y+3, r1	; 0x03
    31ce:	04 c0       	rjmp	.+8      	; 0x31d8 <uxEventGroupGetNumber+0x2e>
		}
		else
		{
			xReturn = pxEventBits->uxEventGroupNumber;
    31d0:	e9 81       	ldd	r30, Y+1	; 0x01
    31d2:	fa 81       	ldd	r31, Y+2	; 0x02
    31d4:	83 85       	ldd	r24, Z+11	; 0x0b
    31d6:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    31d8:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    31da:	0f 90       	pop	r0
    31dc:	0f 90       	pop	r0
    31de:	0f 90       	pop	r0
    31e0:	0f 90       	pop	r0
    31e2:	0f 90       	pop	r0
    31e4:	cf 91       	pop	r28
    31e6:	df 91       	pop	r29
    31e8:	08 95       	ret

000031ea <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    31ea:	df 93       	push	r29
    31ec:	cf 93       	push	r28
    31ee:	00 d0       	rcall	.+0      	; 0x31f0 <pvPortMalloc+0x6>
    31f0:	00 d0       	rcall	.+0      	; 0x31f2 <pvPortMalloc+0x8>
    31f2:	cd b7       	in	r28, 0x3d	; 61
    31f4:	de b7       	in	r29, 0x3e	; 62
    31f6:	9c 83       	std	Y+4, r25	; 0x04
    31f8:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    31fa:	1a 82       	std	Y+2, r1	; 0x02
    31fc:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    31fe:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    3202:	80 91 0d 01 	lds	r24, 0x010D
    3206:	90 91 0e 01 	lds	r25, 0x010E
    320a:	00 97       	sbiw	r24, 0x00	; 0
    320c:	31 f4       	brne	.+12     	; 0x321a <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    320e:	80 e1       	ldi	r24, 0x10	; 16
    3210:	91 e0       	ldi	r25, 0x01	; 1
    3212:	90 93 0e 01 	sts	0x010E, r25
    3216:	80 93 0d 01 	sts	0x010D, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    321a:	80 91 0b 01 	lds	r24, 0x010B
    321e:	90 91 0c 01 	lds	r25, 0x010C
    3222:	2b 81       	ldd	r18, Y+3	; 0x03
    3224:	3c 81       	ldd	r19, Y+4	; 0x04
    3226:	82 0f       	add	r24, r18
    3228:	93 1f       	adc	r25, r19
    322a:	25 e0       	ldi	r18, 0x05	; 5
    322c:	8b 3d       	cpi	r24, 0xDB	; 219
    322e:	92 07       	cpc	r25, r18
    3230:	38 f5       	brcc	.+78     	; 0x3280 <pvPortMalloc+0x96>
    3232:	20 91 0b 01 	lds	r18, 0x010B
    3236:	30 91 0c 01 	lds	r19, 0x010C
    323a:	8b 81       	ldd	r24, Y+3	; 0x03
    323c:	9c 81       	ldd	r25, Y+4	; 0x04
    323e:	28 0f       	add	r18, r24
    3240:	39 1f       	adc	r19, r25
    3242:	80 91 0b 01 	lds	r24, 0x010B
    3246:	90 91 0c 01 	lds	r25, 0x010C
    324a:	82 17       	cp	r24, r18
    324c:	93 07       	cpc	r25, r19
    324e:	c0 f4       	brcc	.+48     	; 0x3280 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3250:	20 91 0d 01 	lds	r18, 0x010D
    3254:	30 91 0e 01 	lds	r19, 0x010E
    3258:	80 91 0b 01 	lds	r24, 0x010B
    325c:	90 91 0c 01 	lds	r25, 0x010C
    3260:	82 0f       	add	r24, r18
    3262:	93 1f       	adc	r25, r19
    3264:	9a 83       	std	Y+2, r25	; 0x02
    3266:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    3268:	20 91 0b 01 	lds	r18, 0x010B
    326c:	30 91 0c 01 	lds	r19, 0x010C
    3270:	8b 81       	ldd	r24, Y+3	; 0x03
    3272:	9c 81       	ldd	r25, Y+4	; 0x04
    3274:	82 0f       	add	r24, r18
    3276:	93 1f       	adc	r25, r19
    3278:	90 93 0c 01 	sts	0x010C, r25
    327c:	80 93 0b 01 	sts	0x010B, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3280:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    3284:	89 81       	ldd	r24, Y+1	; 0x01
    3286:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3288:	0f 90       	pop	r0
    328a:	0f 90       	pop	r0
    328c:	0f 90       	pop	r0
    328e:	0f 90       	pop	r0
    3290:	cf 91       	pop	r28
    3292:	df 91       	pop	r29
    3294:	08 95       	ret

00003296 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3296:	df 93       	push	r29
    3298:	cf 93       	push	r28
    329a:	00 d0       	rcall	.+0      	; 0x329c <vPortFree+0x6>
    329c:	cd b7       	in	r28, 0x3d	; 61
    329e:	de b7       	in	r29, 0x3e	; 62
    32a0:	9a 83       	std	Y+2, r25	; 0x02
    32a2:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    32a4:	0f 90       	pop	r0
    32a6:	0f 90       	pop	r0
    32a8:	cf 91       	pop	r28
    32aa:	df 91       	pop	r29
    32ac:	08 95       	ret

000032ae <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    32ae:	df 93       	push	r29
    32b0:	cf 93       	push	r28
    32b2:	cd b7       	in	r28, 0x3d	; 61
    32b4:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    32b6:	10 92 0c 01 	sts	0x010C, r1
    32ba:	10 92 0b 01 	sts	0x010B, r1
}
    32be:	cf 91       	pop	r28
    32c0:	df 91       	pop	r29
    32c2:	08 95       	ret

000032c4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    32c4:	df 93       	push	r29
    32c6:	cf 93       	push	r28
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    32cc:	20 91 0b 01 	lds	r18, 0x010B
    32d0:	30 91 0c 01 	lds	r19, 0x010C
    32d4:	8b ed       	ldi	r24, 0xDB	; 219
    32d6:	95 e0       	ldi	r25, 0x05	; 5
    32d8:	82 1b       	sub	r24, r18
    32da:	93 0b       	sbc	r25, r19
}
    32dc:	cf 91       	pop	r28
    32de:	df 91       	pop	r29
    32e0:	08 95       	ret

000032e2 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    32e2:	af 92       	push	r10
    32e4:	bf 92       	push	r11
    32e6:	cf 92       	push	r12
    32e8:	df 92       	push	r13
    32ea:	ef 92       	push	r14
    32ec:	ff 92       	push	r15
    32ee:	0f 93       	push	r16
    32f0:	df 93       	push	r29
    32f2:	cf 93       	push	r28
    32f4:	00 d0       	rcall	.+0      	; 0x32f6 <vStartIntegerMathTasks+0x14>
    32f6:	0f 92       	push	r0
    32f8:	cd b7       	in	r28, 0x3d	; 61
    32fa:	de b7       	in	r29, 0x3e	; 62
    32fc:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    32fe:	1a 82       	std	Y+2, r1	; 0x02
    3300:	19 82       	std	Y+1, r1	; 0x01
    3302:	1b c0       	rjmp	.+54     	; 0x333a <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    3304:	89 81       	ldd	r24, Y+1	; 0x01
    3306:	9a 81       	ldd	r25, Y+2	; 0x02
    3308:	fc 01       	movw	r30, r24
    330a:	e5 51       	subi	r30, 0x15	; 21
    330c:	f9 4f       	sbci	r31, 0xF9	; 249
    330e:	8f ea       	ldi	r24, 0xAF	; 175
    3310:	99 e1       	ldi	r25, 0x19	; 25
    3312:	25 e8       	ldi	r18, 0x85	; 133
    3314:	30 e0       	ldi	r19, 0x00	; 0
    3316:	b9 01       	movw	r22, r18
    3318:	45 e5       	ldi	r20, 0x55	; 85
    331a:	50 e0       	ldi	r21, 0x00	; 0
    331c:	9f 01       	movw	r18, r30
    331e:	0b 81       	ldd	r16, Y+3	; 0x03
    3320:	ee 24       	eor	r14, r14
    3322:	ff 24       	eor	r15, r15
    3324:	cc 24       	eor	r12, r12
    3326:	dd 24       	eor	r13, r13
    3328:	aa 24       	eor	r10, r10
    332a:	bb 24       	eor	r11, r11
    332c:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3330:	89 81       	ldd	r24, Y+1	; 0x01
    3332:	9a 81       	ldd	r25, Y+2	; 0x02
    3334:	01 96       	adiw	r24, 0x01	; 1
    3336:	9a 83       	std	Y+2, r25	; 0x02
    3338:	89 83       	std	Y+1, r24	; 0x01
    333a:	89 81       	ldd	r24, Y+1	; 0x01
    333c:	9a 81       	ldd	r25, Y+2	; 0x02
    333e:	18 16       	cp	r1, r24
    3340:	19 06       	cpc	r1, r25
    3342:	04 f7       	brge	.-64     	; 0x3304 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
    3344:	0f 90       	pop	r0
    3346:	0f 90       	pop	r0
    3348:	0f 90       	pop	r0
    334a:	cf 91       	pop	r28
    334c:	df 91       	pop	r29
    334e:	0f 91       	pop	r16
    3350:	ff 90       	pop	r15
    3352:	ef 90       	pop	r14
    3354:	df 90       	pop	r13
    3356:	cf 90       	pop	r12
    3358:	bf 90       	pop	r11
    335a:	af 90       	pop	r10
    335c:	08 95       	ret

0000335e <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    335e:	df 93       	push	r29
    3360:	cf 93       	push	r28
    3362:	cd b7       	in	r28, 0x3d	; 61
    3364:	de b7       	in	r29, 0x3e	; 62
    3366:	2a 97       	sbiw	r28, 0x0a	; 10
    3368:	0f b6       	in	r0, 0x3f	; 63
    336a:	f8 94       	cli
    336c:	de bf       	out	0x3e, r29	; 62
    336e:	0f be       	out	0x3f, r0	; 63
    3370:	cd bf       	out	0x3d, r28	; 61
    3372:	9a 87       	std	Y+10, r25	; 0x0a
    3374:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    3376:	1c 82       	std	Y+4, r1	; 0x04
    3378:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    337a:	89 85       	ldd	r24, Y+9	; 0x09
    337c:	9a 85       	ldd	r25, Y+10	; 0x0a
    337e:	9a 83       	std	Y+2, r25	; 0x02
    3380:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    3382:	8b e7       	ldi	r24, 0x7B	; 123
    3384:	90 e0       	ldi	r25, 0x00	; 0
    3386:	a0 e0       	ldi	r26, 0x00	; 0
    3388:	b0 e0       	ldi	r27, 0x00	; 0
    338a:	8d 83       	std	Y+5, r24	; 0x05
    338c:	9e 83       	std	Y+6, r25	; 0x06
    338e:	af 83       	std	Y+7, r26	; 0x07
    3390:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    3392:	8d 81       	ldd	r24, Y+5	; 0x05
    3394:	9e 81       	ldd	r25, Y+6	; 0x06
    3396:	af 81       	ldd	r26, Y+7	; 0x07
    3398:	b8 85       	ldd	r27, Y+8	; 0x08
    339a:	89 5b       	subi	r24, 0xB9	; 185
    339c:	9b 46       	sbci	r25, 0x6B	; 107
    339e:	ac 4f       	sbci	r26, 0xFC	; 252
    33a0:	bf 4f       	sbci	r27, 0xFF	; 255
    33a2:	8d 83       	std	Y+5, r24	; 0x05
    33a4:	9e 83       	std	Y+6, r25	; 0x06
    33a6:	af 83       	std	Y+7, r26	; 0x07
    33a8:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    33aa:	8d 81       	ldd	r24, Y+5	; 0x05
    33ac:	9e 81       	ldd	r25, Y+6	; 0x06
    33ae:	af 81       	ldd	r26, Y+7	; 0x07
    33b0:	b8 85       	ldd	r27, Y+8	; 0x08
    33b2:	2d ef       	ldi	r18, 0xFD	; 253
    33b4:	3f ef       	ldi	r19, 0xFF	; 255
    33b6:	4f ef       	ldi	r20, 0xFF	; 255
    33b8:	5f ef       	ldi	r21, 0xFF	; 255
    33ba:	bc 01       	movw	r22, r24
    33bc:	cd 01       	movw	r24, r26
    33be:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <__mulsi3>
    33c2:	dc 01       	movw	r26, r24
    33c4:	cb 01       	movw	r24, r22
    33c6:	8d 83       	std	Y+5, r24	; 0x05
    33c8:	9e 83       	std	Y+6, r25	; 0x06
    33ca:	af 83       	std	Y+7, r26	; 0x07
    33cc:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    33ce:	8d 81       	ldd	r24, Y+5	; 0x05
    33d0:	9e 81       	ldd	r25, Y+6	; 0x06
    33d2:	af 81       	ldd	r26, Y+7	; 0x07
    33d4:	b8 85       	ldd	r27, Y+8	; 0x08
    33d6:	27 e0       	ldi	r18, 0x07	; 7
    33d8:	30 e0       	ldi	r19, 0x00	; 0
    33da:	40 e0       	ldi	r20, 0x00	; 0
    33dc:	50 e0       	ldi	r21, 0x00	; 0
    33de:	bc 01       	movw	r22, r24
    33e0:	cd 01       	movw	r24, r26
    33e2:	0e 94 8d 35 	call	0x6b1a	; 0x6b1a <__divmodsi4>
    33e6:	da 01       	movw	r26, r20
    33e8:	c9 01       	movw	r24, r18
    33ea:	8d 83       	std	Y+5, r24	; 0x05
    33ec:	9e 83       	std	Y+6, r25	; 0x06
    33ee:	af 83       	std	Y+7, r26	; 0x07
    33f0:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    33f2:	8d 81       	ldd	r24, Y+5	; 0x05
    33f4:	9e 81       	ldd	r25, Y+6	; 0x06
    33f6:	af 81       	ldd	r26, Y+7	; 0x07
    33f8:	b8 85       	ldd	r27, Y+8	; 0x08
    33fa:	8b 31       	cpi	r24, 0x1B	; 27
    33fc:	27 e7       	ldi	r18, 0x77	; 119
    33fe:	92 07       	cpc	r25, r18
    3400:	2e ef       	ldi	r18, 0xFE	; 254
    3402:	a2 07       	cpc	r26, r18
    3404:	2f ef       	ldi	r18, 0xFF	; 255
    3406:	b2 07       	cpc	r27, r18
    3408:	21 f0       	breq	.+8      	; 0x3412 <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    340a:	81 e0       	ldi	r24, 0x01	; 1
    340c:	90 e0       	ldi	r25, 0x00	; 0
    340e:	9c 83       	std	Y+4, r25	; 0x04
    3410:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    3412:	8b 81       	ldd	r24, Y+3	; 0x03
    3414:	9c 81       	ldd	r25, Y+4	; 0x04
    3416:	00 97       	sbiw	r24, 0x00	; 0
    3418:	09 f0       	breq	.+2      	; 0x341c <vCompeteingIntMathTask+0xbe>
    341a:	b3 cf       	rjmp	.-154    	; 0x3382 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    341c:	0f b6       	in	r0, 0x3f	; 63
    341e:	f8 94       	cli
    3420:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    3422:	e9 81       	ldd	r30, Y+1	; 0x01
    3424:	fa 81       	ldd	r31, Y+2	; 0x02
    3426:	81 e0       	ldi	r24, 0x01	; 1
    3428:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    342a:	0f 90       	pop	r0
    342c:	0f be       	out	0x3f, r0	; 63
    342e:	a9 cf       	rjmp	.-174    	; 0x3382 <vCompeteingIntMathTask+0x24>

00003430 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    3430:	df 93       	push	r29
    3432:	cf 93       	push	r28
    3434:	00 d0       	rcall	.+0      	; 0x3436 <xAreIntegerMathsTaskStillRunning+0x6>
    3436:	0f 92       	push	r0
    3438:	cd b7       	in	r28, 0x3d	; 61
    343a:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    343c:	81 e0       	ldi	r24, 0x01	; 1
    343e:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3440:	1a 82       	std	Y+2, r1	; 0x02
    3442:	19 82       	std	Y+1, r1	; 0x01
    3444:	14 c0       	rjmp	.+40     	; 0x346e <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    3446:	89 81       	ldd	r24, Y+1	; 0x01
    3448:	9a 81       	ldd	r25, Y+2	; 0x02
    344a:	fc 01       	movw	r30, r24
    344c:	e5 51       	subi	r30, 0x15	; 21
    344e:	f9 4f       	sbci	r31, 0xF9	; 249
    3450:	80 81       	ld	r24, Z
    3452:	88 23       	and	r24, r24
    3454:	09 f4       	brne	.+2      	; 0x3458 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    3456:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    3458:	89 81       	ldd	r24, Y+1	; 0x01
    345a:	9a 81       	ldd	r25, Y+2	; 0x02
    345c:	fc 01       	movw	r30, r24
    345e:	e5 51       	subi	r30, 0x15	; 21
    3460:	f9 4f       	sbci	r31, 0xF9	; 249
    3462:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	9a 81       	ldd	r25, Y+2	; 0x02
    3468:	01 96       	adiw	r24, 0x01	; 1
    346a:	9a 83       	std	Y+2, r25	; 0x02
    346c:	89 83       	std	Y+1, r24	; 0x01
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	18 16       	cp	r1, r24
    3474:	19 06       	cpc	r1, r25
    3476:	3c f7       	brge	.-50     	; 0x3446 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    3478:	8b 81       	ldd	r24, Y+3	; 0x03
}
    347a:	0f 90       	pop	r0
    347c:	0f 90       	pop	r0
    347e:	0f 90       	pop	r0
    3480:	cf 91       	pop	r28
    3482:	df 91       	pop	r29
    3484:	08 95       	ret

00003486 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3486:	df 93       	push	r29
    3488:	cf 93       	push	r28
    348a:	00 d0       	rcall	.+0      	; 0x348c <vListInitialise+0x6>
    348c:	cd b7       	in	r28, 0x3d	; 61
    348e:	de b7       	in	r29, 0x3e	; 62
    3490:	9a 83       	std	Y+2, r25	; 0x02
    3492:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3494:	89 81       	ldd	r24, Y+1	; 0x01
    3496:	9a 81       	ldd	r25, Y+2	; 0x02
    3498:	03 96       	adiw	r24, 0x03	; 3
    349a:	e9 81       	ldd	r30, Y+1	; 0x01
    349c:	fa 81       	ldd	r31, Y+2	; 0x02
    349e:	92 83       	std	Z+2, r25	; 0x02
    34a0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    34a2:	e9 81       	ldd	r30, Y+1	; 0x01
    34a4:	fa 81       	ldd	r31, Y+2	; 0x02
    34a6:	8f ef       	ldi	r24, 0xFF	; 255
    34a8:	9f ef       	ldi	r25, 0xFF	; 255
    34aa:	94 83       	std	Z+4, r25	; 0x04
    34ac:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    34ae:	89 81       	ldd	r24, Y+1	; 0x01
    34b0:	9a 81       	ldd	r25, Y+2	; 0x02
    34b2:	03 96       	adiw	r24, 0x03	; 3
    34b4:	e9 81       	ldd	r30, Y+1	; 0x01
    34b6:	fa 81       	ldd	r31, Y+2	; 0x02
    34b8:	96 83       	std	Z+6, r25	; 0x06
    34ba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
    34c0:	03 96       	adiw	r24, 0x03	; 3
    34c2:	e9 81       	ldd	r30, Y+1	; 0x01
    34c4:	fa 81       	ldd	r31, Y+2	; 0x02
    34c6:	90 87       	std	Z+8, r25	; 0x08
    34c8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    34ca:	e9 81       	ldd	r30, Y+1	; 0x01
    34cc:	fa 81       	ldd	r31, Y+2	; 0x02
    34ce:	10 82       	st	Z, r1
}
    34d0:	0f 90       	pop	r0
    34d2:	0f 90       	pop	r0
    34d4:	cf 91       	pop	r28
    34d6:	df 91       	pop	r29
    34d8:	08 95       	ret

000034da <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    34da:	df 93       	push	r29
    34dc:	cf 93       	push	r28
    34de:	00 d0       	rcall	.+0      	; 0x34e0 <vListInitialiseItem+0x6>
    34e0:	cd b7       	in	r28, 0x3d	; 61
    34e2:	de b7       	in	r29, 0x3e	; 62
    34e4:	9a 83       	std	Y+2, r25	; 0x02
    34e6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    34e8:	e9 81       	ldd	r30, Y+1	; 0x01
    34ea:	fa 81       	ldd	r31, Y+2	; 0x02
    34ec:	11 86       	std	Z+9, r1	; 0x09
    34ee:	10 86       	std	Z+8, r1	; 0x08
}
    34f0:	0f 90       	pop	r0
    34f2:	0f 90       	pop	r0
    34f4:	cf 91       	pop	r28
    34f6:	df 91       	pop	r29
    34f8:	08 95       	ret

000034fa <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    34fa:	df 93       	push	r29
    34fc:	cf 93       	push	r28
    34fe:	00 d0       	rcall	.+0      	; 0x3500 <vListInsertEnd+0x6>
    3500:	00 d0       	rcall	.+0      	; 0x3502 <vListInsertEnd+0x8>
    3502:	00 d0       	rcall	.+0      	; 0x3504 <vListInsertEnd+0xa>
    3504:	cd b7       	in	r28, 0x3d	; 61
    3506:	de b7       	in	r29, 0x3e	; 62
    3508:	9c 83       	std	Y+4, r25	; 0x04
    350a:	8b 83       	std	Y+3, r24	; 0x03
    350c:	7e 83       	std	Y+6, r23	; 0x06
    350e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    3510:	eb 81       	ldd	r30, Y+3	; 0x03
    3512:	fc 81       	ldd	r31, Y+4	; 0x04
    3514:	81 81       	ldd	r24, Z+1	; 0x01
    3516:	92 81       	ldd	r25, Z+2	; 0x02
    3518:	9a 83       	std	Y+2, r25	; 0x02
    351a:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    351c:	ed 81       	ldd	r30, Y+5	; 0x05
    351e:	fe 81       	ldd	r31, Y+6	; 0x06
    3520:	89 81       	ldd	r24, Y+1	; 0x01
    3522:	9a 81       	ldd	r25, Y+2	; 0x02
    3524:	93 83       	std	Z+3, r25	; 0x03
    3526:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3528:	e9 81       	ldd	r30, Y+1	; 0x01
    352a:	fa 81       	ldd	r31, Y+2	; 0x02
    352c:	84 81       	ldd	r24, Z+4	; 0x04
    352e:	95 81       	ldd	r25, Z+5	; 0x05
    3530:	ed 81       	ldd	r30, Y+5	; 0x05
    3532:	fe 81       	ldd	r31, Y+6	; 0x06
    3534:	95 83       	std	Z+5, r25	; 0x05
    3536:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    3538:	e9 81       	ldd	r30, Y+1	; 0x01
    353a:	fa 81       	ldd	r31, Y+2	; 0x02
    353c:	04 80       	ldd	r0, Z+4	; 0x04
    353e:	f5 81       	ldd	r31, Z+5	; 0x05
    3540:	e0 2d       	mov	r30, r0
    3542:	8d 81       	ldd	r24, Y+5	; 0x05
    3544:	9e 81       	ldd	r25, Y+6	; 0x06
    3546:	93 83       	std	Z+3, r25	; 0x03
    3548:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    354a:	e9 81       	ldd	r30, Y+1	; 0x01
    354c:	fa 81       	ldd	r31, Y+2	; 0x02
    354e:	8d 81       	ldd	r24, Y+5	; 0x05
    3550:	9e 81       	ldd	r25, Y+6	; 0x06
    3552:	95 83       	std	Z+5, r25	; 0x05
    3554:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3556:	ed 81       	ldd	r30, Y+5	; 0x05
    3558:	fe 81       	ldd	r31, Y+6	; 0x06
    355a:	8b 81       	ldd	r24, Y+3	; 0x03
    355c:	9c 81       	ldd	r25, Y+4	; 0x04
    355e:	91 87       	std	Z+9, r25	; 0x09
    3560:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3562:	eb 81       	ldd	r30, Y+3	; 0x03
    3564:	fc 81       	ldd	r31, Y+4	; 0x04
    3566:	80 81       	ld	r24, Z
    3568:	8f 5f       	subi	r24, 0xFF	; 255
    356a:	eb 81       	ldd	r30, Y+3	; 0x03
    356c:	fc 81       	ldd	r31, Y+4	; 0x04
    356e:	80 83       	st	Z, r24
}
    3570:	26 96       	adiw	r28, 0x06	; 6
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	de bf       	out	0x3e, r29	; 62
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	cd bf       	out	0x3d, r28	; 61
    357c:	cf 91       	pop	r28
    357e:	df 91       	pop	r29
    3580:	08 95       	ret

00003582 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3582:	df 93       	push	r29
    3584:	cf 93       	push	r28
    3586:	cd b7       	in	r28, 0x3d	; 61
    3588:	de b7       	in	r29, 0x3e	; 62
    358a:	28 97       	sbiw	r28, 0x08	; 8
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	cd bf       	out	0x3d, r28	; 61
    3596:	9e 83       	std	Y+6, r25	; 0x06
    3598:	8d 83       	std	Y+5, r24	; 0x05
    359a:	78 87       	std	Y+8, r23	; 0x08
    359c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    359e:	ef 81       	ldd	r30, Y+7	; 0x07
    35a0:	f8 85       	ldd	r31, Y+8	; 0x08
    35a2:	80 81       	ld	r24, Z
    35a4:	91 81       	ldd	r25, Z+1	; 0x01
    35a6:	9a 83       	std	Y+2, r25	; 0x02
    35a8:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    35aa:	89 81       	ldd	r24, Y+1	; 0x01
    35ac:	9a 81       	ldd	r25, Y+2	; 0x02
    35ae:	2f ef       	ldi	r18, 0xFF	; 255
    35b0:	8f 3f       	cpi	r24, 0xFF	; 255
    35b2:	92 07       	cpc	r25, r18
    35b4:	39 f4       	brne	.+14     	; 0x35c4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    35b6:	ed 81       	ldd	r30, Y+5	; 0x05
    35b8:	fe 81       	ldd	r31, Y+6	; 0x06
    35ba:	87 81       	ldd	r24, Z+7	; 0x07
    35bc:	90 85       	ldd	r25, Z+8	; 0x08
    35be:	9c 83       	std	Y+4, r25	; 0x04
    35c0:	8b 83       	std	Y+3, r24	; 0x03
    35c2:	18 c0       	rjmp	.+48     	; 0x35f4 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    35c4:	8d 81       	ldd	r24, Y+5	; 0x05
    35c6:	9e 81       	ldd	r25, Y+6	; 0x06
    35c8:	03 96       	adiw	r24, 0x03	; 3
    35ca:	9c 83       	std	Y+4, r25	; 0x04
    35cc:	8b 83       	std	Y+3, r24	; 0x03
    35ce:	06 c0       	rjmp	.+12     	; 0x35dc <vListInsert+0x5a>
    35d0:	eb 81       	ldd	r30, Y+3	; 0x03
    35d2:	fc 81       	ldd	r31, Y+4	; 0x04
    35d4:	82 81       	ldd	r24, Z+2	; 0x02
    35d6:	93 81       	ldd	r25, Z+3	; 0x03
    35d8:	9c 83       	std	Y+4, r25	; 0x04
    35da:	8b 83       	std	Y+3, r24	; 0x03
    35dc:	eb 81       	ldd	r30, Y+3	; 0x03
    35de:	fc 81       	ldd	r31, Y+4	; 0x04
    35e0:	02 80       	ldd	r0, Z+2	; 0x02
    35e2:	f3 81       	ldd	r31, Z+3	; 0x03
    35e4:	e0 2d       	mov	r30, r0
    35e6:	20 81       	ld	r18, Z
    35e8:	31 81       	ldd	r19, Z+1	; 0x01
    35ea:	89 81       	ldd	r24, Y+1	; 0x01
    35ec:	9a 81       	ldd	r25, Y+2	; 0x02
    35ee:	82 17       	cp	r24, r18
    35f0:	93 07       	cpc	r25, r19
    35f2:	70 f7       	brcc	.-36     	; 0x35d0 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    35f4:	eb 81       	ldd	r30, Y+3	; 0x03
    35f6:	fc 81       	ldd	r31, Y+4	; 0x04
    35f8:	82 81       	ldd	r24, Z+2	; 0x02
    35fa:	93 81       	ldd	r25, Z+3	; 0x03
    35fc:	ef 81       	ldd	r30, Y+7	; 0x07
    35fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3600:	93 83       	std	Z+3, r25	; 0x03
    3602:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3604:	ef 81       	ldd	r30, Y+7	; 0x07
    3606:	f8 85       	ldd	r31, Y+8	; 0x08
    3608:	02 80       	ldd	r0, Z+2	; 0x02
    360a:	f3 81       	ldd	r31, Z+3	; 0x03
    360c:	e0 2d       	mov	r30, r0
    360e:	8f 81       	ldd	r24, Y+7	; 0x07
    3610:	98 85       	ldd	r25, Y+8	; 0x08
    3612:	95 83       	std	Z+5, r25	; 0x05
    3614:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3616:	ef 81       	ldd	r30, Y+7	; 0x07
    3618:	f8 85       	ldd	r31, Y+8	; 0x08
    361a:	8b 81       	ldd	r24, Y+3	; 0x03
    361c:	9c 81       	ldd	r25, Y+4	; 0x04
    361e:	95 83       	std	Z+5, r25	; 0x05
    3620:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    3622:	eb 81       	ldd	r30, Y+3	; 0x03
    3624:	fc 81       	ldd	r31, Y+4	; 0x04
    3626:	8f 81       	ldd	r24, Y+7	; 0x07
    3628:	98 85       	ldd	r25, Y+8	; 0x08
    362a:	93 83       	std	Z+3, r25	; 0x03
    362c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    362e:	ef 81       	ldd	r30, Y+7	; 0x07
    3630:	f8 85       	ldd	r31, Y+8	; 0x08
    3632:	8d 81       	ldd	r24, Y+5	; 0x05
    3634:	9e 81       	ldd	r25, Y+6	; 0x06
    3636:	91 87       	std	Z+9, r25	; 0x09
    3638:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    363a:	ed 81       	ldd	r30, Y+5	; 0x05
    363c:	fe 81       	ldd	r31, Y+6	; 0x06
    363e:	80 81       	ld	r24, Z
    3640:	8f 5f       	subi	r24, 0xFF	; 255
    3642:	ed 81       	ldd	r30, Y+5	; 0x05
    3644:	fe 81       	ldd	r31, Y+6	; 0x06
    3646:	80 83       	st	Z, r24
}
    3648:	28 96       	adiw	r28, 0x08	; 8
    364a:	0f b6       	in	r0, 0x3f	; 63
    364c:	f8 94       	cli
    364e:	de bf       	out	0x3e, r29	; 62
    3650:	0f be       	out	0x3f, r0	; 63
    3652:	cd bf       	out	0x3d, r28	; 61
    3654:	cf 91       	pop	r28
    3656:	df 91       	pop	r29
    3658:	08 95       	ret

0000365a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    365a:	df 93       	push	r29
    365c:	cf 93       	push	r28
    365e:	00 d0       	rcall	.+0      	; 0x3660 <uxListRemove+0x6>
    3660:	00 d0       	rcall	.+0      	; 0x3662 <uxListRemove+0x8>
    3662:	cd b7       	in	r28, 0x3d	; 61
    3664:	de b7       	in	r29, 0x3e	; 62
    3666:	9c 83       	std	Y+4, r25	; 0x04
    3668:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    366a:	eb 81       	ldd	r30, Y+3	; 0x03
    366c:	fc 81       	ldd	r31, Y+4	; 0x04
    366e:	80 85       	ldd	r24, Z+8	; 0x08
    3670:	91 85       	ldd	r25, Z+9	; 0x09
    3672:	9a 83       	std	Y+2, r25	; 0x02
    3674:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3676:	eb 81       	ldd	r30, Y+3	; 0x03
    3678:	fc 81       	ldd	r31, Y+4	; 0x04
    367a:	a2 81       	ldd	r26, Z+2	; 0x02
    367c:	b3 81       	ldd	r27, Z+3	; 0x03
    367e:	eb 81       	ldd	r30, Y+3	; 0x03
    3680:	fc 81       	ldd	r31, Y+4	; 0x04
    3682:	84 81       	ldd	r24, Z+4	; 0x04
    3684:	95 81       	ldd	r25, Z+5	; 0x05
    3686:	15 96       	adiw	r26, 0x05	; 5
    3688:	9c 93       	st	X, r25
    368a:	8e 93       	st	-X, r24
    368c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    368e:	eb 81       	ldd	r30, Y+3	; 0x03
    3690:	fc 81       	ldd	r31, Y+4	; 0x04
    3692:	a4 81       	ldd	r26, Z+4	; 0x04
    3694:	b5 81       	ldd	r27, Z+5	; 0x05
    3696:	eb 81       	ldd	r30, Y+3	; 0x03
    3698:	fc 81       	ldd	r31, Y+4	; 0x04
    369a:	82 81       	ldd	r24, Z+2	; 0x02
    369c:	93 81       	ldd	r25, Z+3	; 0x03
    369e:	13 96       	adiw	r26, 0x03	; 3
    36a0:	9c 93       	st	X, r25
    36a2:	8e 93       	st	-X, r24
    36a4:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    36a6:	e9 81       	ldd	r30, Y+1	; 0x01
    36a8:	fa 81       	ldd	r31, Y+2	; 0x02
    36aa:	21 81       	ldd	r18, Z+1	; 0x01
    36ac:	32 81       	ldd	r19, Z+2	; 0x02
    36ae:	8b 81       	ldd	r24, Y+3	; 0x03
    36b0:	9c 81       	ldd	r25, Y+4	; 0x04
    36b2:	28 17       	cp	r18, r24
    36b4:	39 07       	cpc	r19, r25
    36b6:	41 f4       	brne	.+16     	; 0x36c8 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    36b8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ba:	fc 81       	ldd	r31, Y+4	; 0x04
    36bc:	84 81       	ldd	r24, Z+4	; 0x04
    36be:	95 81       	ldd	r25, Z+5	; 0x05
    36c0:	e9 81       	ldd	r30, Y+1	; 0x01
    36c2:	fa 81       	ldd	r31, Y+2	; 0x02
    36c4:	92 83       	std	Z+2, r25	; 0x02
    36c6:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    36c8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ca:	fc 81       	ldd	r31, Y+4	; 0x04
    36cc:	11 86       	std	Z+9, r1	; 0x09
    36ce:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    36d0:	e9 81       	ldd	r30, Y+1	; 0x01
    36d2:	fa 81       	ldd	r31, Y+2	; 0x02
    36d4:	80 81       	ld	r24, Z
    36d6:	81 50       	subi	r24, 0x01	; 1
    36d8:	e9 81       	ldd	r30, Y+1	; 0x01
    36da:	fa 81       	ldd	r31, Y+2	; 0x02
    36dc:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    36de:	e9 81       	ldd	r30, Y+1	; 0x01
    36e0:	fa 81       	ldd	r31, Y+2	; 0x02
    36e2:	80 81       	ld	r24, Z
}
    36e4:	0f 90       	pop	r0
    36e6:	0f 90       	pop	r0
    36e8:	0f 90       	pop	r0
    36ea:	0f 90       	pop	r0
    36ec:	cf 91       	pop	r28
    36ee:	df 91       	pop	r29
    36f0:	08 95       	ret

000036f2 <main>:
#include "MCAL/UART/UART_int.h"
#include "MCAL/SPI/SPI_int.h"

int
main(int argc, char const *argv[])
{
    36f2:	af 92       	push	r10
    36f4:	bf 92       	push	r11
    36f6:	cf 92       	push	r12
    36f8:	df 92       	push	r13
    36fa:	ef 92       	push	r14
    36fc:	ff 92       	push	r15
    36fe:	0f 93       	push	r16
    3700:	df 93       	push	r29
    3702:	cf 93       	push	r28
    3704:	00 d0       	rcall	.+0      	; 0x3706 <main+0x14>
    3706:	00 d0       	rcall	.+0      	; 0x3708 <main+0x16>
    3708:	cd b7       	in	r28, 0x3d	; 61
    370a:	de b7       	in	r29, 0x3e	; 62
    370c:	9a 83       	std	Y+2, r25	; 0x02
    370e:	89 83       	std	Y+1, r24	; 0x01
    3710:	7c 83       	std	Y+4, r23	; 0x04
    3712:	6b 83       	std	Y+3, r22	; 0x03
	Project_vidInit();
    3714:	0e 94 65 0e 	call	0x1cca	; 0x1cca <Project_vidInit>

	xTaskCreate(Project_vidDisplayTask, NULL,110,NULL,5,NULL);
    3718:	8a ea       	ldi	r24, 0xAA	; 170
    371a:	9e e0       	ldi	r25, 0x0E	; 14
    371c:	60 e0       	ldi	r22, 0x00	; 0
    371e:	70 e0       	ldi	r23, 0x00	; 0
    3720:	4e e6       	ldi	r20, 0x6E	; 110
    3722:	50 e0       	ldi	r21, 0x00	; 0
    3724:	20 e0       	ldi	r18, 0x00	; 0
    3726:	30 e0       	ldi	r19, 0x00	; 0
    3728:	05 e0       	ldi	r16, 0x05	; 5
    372a:	ee 24       	eor	r14, r14
    372c:	ff 24       	eor	r15, r15
    372e:	cc 24       	eor	r12, r12
    3730:	dd 24       	eor	r13, r13
    3732:	aa 24       	eor	r10, r10
    3734:	bb 24       	eor	r11, r11
    3736:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
	xTaskCreate(Project_vidUpdateByUART, NULL,80,NULL,4,NULL);
    373a:	8a e3       	ldi	r24, 0x3A	; 58
    373c:	9f e0       	ldi	r25, 0x0F	; 15
    373e:	60 e0       	ldi	r22, 0x00	; 0
    3740:	70 e0       	ldi	r23, 0x00	; 0
    3742:	40 e5       	ldi	r20, 0x50	; 80
    3744:	50 e0       	ldi	r21, 0x00	; 0
    3746:	20 e0       	ldi	r18, 0x00	; 0
    3748:	30 e0       	ldi	r19, 0x00	; 0
    374a:	04 e0       	ldi	r16, 0x04	; 4
    374c:	ee 24       	eor	r14, r14
    374e:	ff 24       	eor	r15, r15
    3750:	cc 24       	eor	r12, r12
    3752:	dd 24       	eor	r13, r13
    3754:	aa 24       	eor	r10, r10
    3756:	bb 24       	eor	r11, r11
    3758:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
	xTaskCreate(Project_vidLight   , NULL,80,NULL,3,NULL);
    375c:	88 eb       	ldi	r24, 0xB8	; 184
    375e:	9e e0       	ldi	r25, 0x0E	; 14
    3760:	60 e0       	ldi	r22, 0x00	; 0
    3762:	70 e0       	ldi	r23, 0x00	; 0
    3764:	40 e5       	ldi	r20, 0x50	; 80
    3766:	50 e0       	ldi	r21, 0x00	; 0
    3768:	20 e0       	ldi	r18, 0x00	; 0
    376a:	30 e0       	ldi	r19, 0x00	; 0
    376c:	03 e0       	ldi	r16, 0x03	; 3
    376e:	ee 24       	eor	r14, r14
    3770:	ff 24       	eor	r15, r15
    3772:	cc 24       	eor	r12, r12
    3774:	dd 24       	eor	r13, r13
    3776:	aa 24       	eor	r10, r10
    3778:	bb 24       	eor	r11, r11
    377a:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
	xTaskCreate(Project_vidIncrease, NULL,180,NULL,2,NULL);
    377e:	86 ec       	ldi	r24, 0xC6	; 198
    3780:	9e e0       	ldi	r25, 0x0E	; 14
    3782:	60 e0       	ldi	r22, 0x00	; 0
    3784:	70 e0       	ldi	r23, 0x00	; 0
    3786:	44 eb       	ldi	r20, 0xB4	; 180
    3788:	50 e0       	ldi	r21, 0x00	; 0
    378a:	20 e0       	ldi	r18, 0x00	; 0
    378c:	30 e0       	ldi	r19, 0x00	; 0
    378e:	02 e0       	ldi	r16, 0x02	; 2
    3790:	ee 24       	eor	r14, r14
    3792:	ff 24       	eor	r15, r15
    3794:	cc 24       	eor	r12, r12
    3796:	dd 24       	eor	r13, r13
    3798:	aa 24       	eor	r10, r10
    379a:	bb 24       	eor	r11, r11
    379c:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
	xTaskCreate(Project_vidDecrease, NULL,180,NULL,2,NULL);
    37a0:	8c ef       	ldi	r24, 0xFC	; 252
    37a2:	9e e0       	ldi	r25, 0x0E	; 14
    37a4:	60 e0       	ldi	r22, 0x00	; 0
    37a6:	70 e0       	ldi	r23, 0x00	; 0
    37a8:	44 eb       	ldi	r20, 0xB4	; 180
    37aa:	50 e0       	ldi	r21, 0x00	; 0
    37ac:	20 e0       	ldi	r18, 0x00	; 0
    37ae:	30 e0       	ldi	r19, 0x00	; 0
    37b0:	02 e0       	ldi	r16, 0x02	; 2
    37b2:	ee 24       	eor	r14, r14
    37b4:	ff 24       	eor	r15, r15
    37b6:	cc 24       	eor	r12, r12
    37b8:	dd 24       	eor	r13, r13
    37ba:	aa 24       	eor	r10, r10
    37bc:	bb 24       	eor	r11, r11
    37be:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>

	vTaskStartScheduler();
    37c2:	0e 94 02 2b 	call	0x5604	; 0x5604 <vTaskStartScheduler>

	return 0;
    37c6:	80 e0       	ldi	r24, 0x00	; 0
    37c8:	90 e0       	ldi	r25, 0x00	; 0
}
    37ca:	0f 90       	pop	r0
    37cc:	0f 90       	pop	r0
    37ce:	0f 90       	pop	r0
    37d0:	0f 90       	pop	r0
    37d2:	cf 91       	pop	r28
    37d4:	df 91       	pop	r29
    37d6:	0f 91       	pop	r16
    37d8:	ff 90       	pop	r15
    37da:	ef 90       	pop	r14
    37dc:	df 90       	pop	r13
    37de:	cf 90       	pop	r12
    37e0:	bf 90       	pop	r11
    37e2:	af 90       	pop	r10
    37e4:	08 95       	ret

000037e6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    37e6:	df 93       	push	r29
    37e8:	cf 93       	push	r28
    37ea:	cd b7       	in	r28, 0x3d	; 61
    37ec:	de b7       	in	r29, 0x3e	; 62
    37ee:	28 97       	sbiw	r28, 0x08	; 8
    37f0:	0f b6       	in	r0, 0x3f	; 63
    37f2:	f8 94       	cli
    37f4:	de bf       	out	0x3e, r29	; 62
    37f6:	0f be       	out	0x3f, r0	; 63
    37f8:	cd bf       	out	0x3d, r28	; 61
    37fa:	9c 83       	std	Y+4, r25	; 0x04
    37fc:	8b 83       	std	Y+3, r24	; 0x03
    37fe:	7e 83       	std	Y+6, r23	; 0x06
    3800:	6d 83       	std	Y+5, r22	; 0x05
    3802:	58 87       	std	Y+8, r21	; 0x08
    3804:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3806:	eb 81       	ldd	r30, Y+3	; 0x03
    3808:	fc 81       	ldd	r31, Y+4	; 0x04
    380a:	81 e1       	ldi	r24, 0x11	; 17
    380c:	80 83       	st	Z, r24
	pxTopOfStack--;
    380e:	8b 81       	ldd	r24, Y+3	; 0x03
    3810:	9c 81       	ldd	r25, Y+4	; 0x04
    3812:	01 97       	sbiw	r24, 0x01	; 1
    3814:	9c 83       	std	Y+4, r25	; 0x04
    3816:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3818:	eb 81       	ldd	r30, Y+3	; 0x03
    381a:	fc 81       	ldd	r31, Y+4	; 0x04
    381c:	82 e2       	ldi	r24, 0x22	; 34
    381e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3820:	8b 81       	ldd	r24, Y+3	; 0x03
    3822:	9c 81       	ldd	r25, Y+4	; 0x04
    3824:	01 97       	sbiw	r24, 0x01	; 1
    3826:	9c 83       	std	Y+4, r25	; 0x04
    3828:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    382a:	eb 81       	ldd	r30, Y+3	; 0x03
    382c:	fc 81       	ldd	r31, Y+4	; 0x04
    382e:	83 e3       	ldi	r24, 0x33	; 51
    3830:	80 83       	st	Z, r24
	pxTopOfStack--;
    3832:	8b 81       	ldd	r24, Y+3	; 0x03
    3834:	9c 81       	ldd	r25, Y+4	; 0x04
    3836:	01 97       	sbiw	r24, 0x01	; 1
    3838:	9c 83       	std	Y+4, r25	; 0x04
    383a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    383c:	8d 81       	ldd	r24, Y+5	; 0x05
    383e:	9e 81       	ldd	r25, Y+6	; 0x06
    3840:	9a 83       	std	Y+2, r25	; 0x02
    3842:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3844:	89 81       	ldd	r24, Y+1	; 0x01
    3846:	eb 81       	ldd	r30, Y+3	; 0x03
    3848:	fc 81       	ldd	r31, Y+4	; 0x04
    384a:	80 83       	st	Z, r24
	pxTopOfStack--;
    384c:	8b 81       	ldd	r24, Y+3	; 0x03
    384e:	9c 81       	ldd	r25, Y+4	; 0x04
    3850:	01 97       	sbiw	r24, 0x01	; 1
    3852:	9c 83       	std	Y+4, r25	; 0x04
    3854:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3856:	89 81       	ldd	r24, Y+1	; 0x01
    3858:	9a 81       	ldd	r25, Y+2	; 0x02
    385a:	89 2f       	mov	r24, r25
    385c:	99 27       	eor	r25, r25
    385e:	9a 83       	std	Y+2, r25	; 0x02
    3860:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3862:	89 81       	ldd	r24, Y+1	; 0x01
    3864:	eb 81       	ldd	r30, Y+3	; 0x03
    3866:	fc 81       	ldd	r31, Y+4	; 0x04
    3868:	80 83       	st	Z, r24
	pxTopOfStack--;
    386a:	8b 81       	ldd	r24, Y+3	; 0x03
    386c:	9c 81       	ldd	r25, Y+4	; 0x04
    386e:	01 97       	sbiw	r24, 0x01	; 1
    3870:	9c 83       	std	Y+4, r25	; 0x04
    3872:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3874:	eb 81       	ldd	r30, Y+3	; 0x03
    3876:	fc 81       	ldd	r31, Y+4	; 0x04
    3878:	10 82       	st	Z, r1
	pxTopOfStack--;
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	01 97       	sbiw	r24, 0x01	; 1
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3884:	eb 81       	ldd	r30, Y+3	; 0x03
    3886:	fc 81       	ldd	r31, Y+4	; 0x04
    3888:	80 e8       	ldi	r24, 0x80	; 128
    388a:	80 83       	st	Z, r24
	pxTopOfStack--;
    388c:	8b 81       	ldd	r24, Y+3	; 0x03
    388e:	9c 81       	ldd	r25, Y+4	; 0x04
    3890:	01 97       	sbiw	r24, 0x01	; 1
    3892:	9c 83       	std	Y+4, r25	; 0x04
    3894:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3896:	eb 81       	ldd	r30, Y+3	; 0x03
    3898:	fc 81       	ldd	r31, Y+4	; 0x04
    389a:	10 82       	st	Z, r1
	pxTopOfStack--;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	9c 83       	std	Y+4, r25	; 0x04
    38a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    38a6:	eb 81       	ldd	r30, Y+3	; 0x03
    38a8:	fc 81       	ldd	r31, Y+4	; 0x04
    38aa:	82 e0       	ldi	r24, 0x02	; 2
    38ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	9c 81       	ldd	r25, Y+4	; 0x04
    38b2:	01 97       	sbiw	r24, 0x01	; 1
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    38b8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ba:	fc 81       	ldd	r31, Y+4	; 0x04
    38bc:	83 e0       	ldi	r24, 0x03	; 3
    38be:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	01 97       	sbiw	r24, 0x01	; 1
    38c6:	9c 83       	std	Y+4, r25	; 0x04
    38c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    38ca:	eb 81       	ldd	r30, Y+3	; 0x03
    38cc:	fc 81       	ldd	r31, Y+4	; 0x04
    38ce:	84 e0       	ldi	r24, 0x04	; 4
    38d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    38d2:	8b 81       	ldd	r24, Y+3	; 0x03
    38d4:	9c 81       	ldd	r25, Y+4	; 0x04
    38d6:	01 97       	sbiw	r24, 0x01	; 1
    38d8:	9c 83       	std	Y+4, r25	; 0x04
    38da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	85 e0       	ldi	r24, 0x05	; 5
    38e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    38e4:	8b 81       	ldd	r24, Y+3	; 0x03
    38e6:	9c 81       	ldd	r25, Y+4	; 0x04
    38e8:	01 97       	sbiw	r24, 0x01	; 1
    38ea:	9c 83       	std	Y+4, r25	; 0x04
    38ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    38ee:	eb 81       	ldd	r30, Y+3	; 0x03
    38f0:	fc 81       	ldd	r31, Y+4	; 0x04
    38f2:	86 e0       	ldi	r24, 0x06	; 6
    38f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38f6:	8b 81       	ldd	r24, Y+3	; 0x03
    38f8:	9c 81       	ldd	r25, Y+4	; 0x04
    38fa:	01 97       	sbiw	r24, 0x01	; 1
    38fc:	9c 83       	std	Y+4, r25	; 0x04
    38fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	87 e0       	ldi	r24, 0x07	; 7
    3906:	80 83       	st	Z, r24
	pxTopOfStack--;
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	9c 83       	std	Y+4, r25	; 0x04
    3910:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3912:	eb 81       	ldd	r30, Y+3	; 0x03
    3914:	fc 81       	ldd	r31, Y+4	; 0x04
    3916:	88 e0       	ldi	r24, 0x08	; 8
    3918:	80 83       	st	Z, r24
	pxTopOfStack--;
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	9c 81       	ldd	r25, Y+4	; 0x04
    391e:	01 97       	sbiw	r24, 0x01	; 1
    3920:	9c 83       	std	Y+4, r25	; 0x04
    3922:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3924:	eb 81       	ldd	r30, Y+3	; 0x03
    3926:	fc 81       	ldd	r31, Y+4	; 0x04
    3928:	89 e0       	ldi	r24, 0x09	; 9
    392a:	80 83       	st	Z, r24
	pxTopOfStack--;
    392c:	8b 81       	ldd	r24, Y+3	; 0x03
    392e:	9c 81       	ldd	r25, Y+4	; 0x04
    3930:	01 97       	sbiw	r24, 0x01	; 1
    3932:	9c 83       	std	Y+4, r25	; 0x04
    3934:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3936:	eb 81       	ldd	r30, Y+3	; 0x03
    3938:	fc 81       	ldd	r31, Y+4	; 0x04
    393a:	80 e1       	ldi	r24, 0x10	; 16
    393c:	80 83       	st	Z, r24
	pxTopOfStack--;
    393e:	8b 81       	ldd	r24, Y+3	; 0x03
    3940:	9c 81       	ldd	r25, Y+4	; 0x04
    3942:	01 97       	sbiw	r24, 0x01	; 1
    3944:	9c 83       	std	Y+4, r25	; 0x04
    3946:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3948:	eb 81       	ldd	r30, Y+3	; 0x03
    394a:	fc 81       	ldd	r31, Y+4	; 0x04
    394c:	81 e1       	ldi	r24, 0x11	; 17
    394e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3950:	8b 81       	ldd	r24, Y+3	; 0x03
    3952:	9c 81       	ldd	r25, Y+4	; 0x04
    3954:	01 97       	sbiw	r24, 0x01	; 1
    3956:	9c 83       	std	Y+4, r25	; 0x04
    3958:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    395a:	eb 81       	ldd	r30, Y+3	; 0x03
    395c:	fc 81       	ldd	r31, Y+4	; 0x04
    395e:	82 e1       	ldi	r24, 0x12	; 18
    3960:	80 83       	st	Z, r24
	pxTopOfStack--;
    3962:	8b 81       	ldd	r24, Y+3	; 0x03
    3964:	9c 81       	ldd	r25, Y+4	; 0x04
    3966:	01 97       	sbiw	r24, 0x01	; 1
    3968:	9c 83       	std	Y+4, r25	; 0x04
    396a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    396c:	eb 81       	ldd	r30, Y+3	; 0x03
    396e:	fc 81       	ldd	r31, Y+4	; 0x04
    3970:	83 e1       	ldi	r24, 0x13	; 19
    3972:	80 83       	st	Z, r24
	pxTopOfStack--;
    3974:	8b 81       	ldd	r24, Y+3	; 0x03
    3976:	9c 81       	ldd	r25, Y+4	; 0x04
    3978:	01 97       	sbiw	r24, 0x01	; 1
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    397e:	eb 81       	ldd	r30, Y+3	; 0x03
    3980:	fc 81       	ldd	r31, Y+4	; 0x04
    3982:	84 e1       	ldi	r24, 0x14	; 20
    3984:	80 83       	st	Z, r24
	pxTopOfStack--;
    3986:	8b 81       	ldd	r24, Y+3	; 0x03
    3988:	9c 81       	ldd	r25, Y+4	; 0x04
    398a:	01 97       	sbiw	r24, 0x01	; 1
    398c:	9c 83       	std	Y+4, r25	; 0x04
    398e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3990:	eb 81       	ldd	r30, Y+3	; 0x03
    3992:	fc 81       	ldd	r31, Y+4	; 0x04
    3994:	85 e1       	ldi	r24, 0x15	; 21
    3996:	80 83       	st	Z, r24
	pxTopOfStack--;
    3998:	8b 81       	ldd	r24, Y+3	; 0x03
    399a:	9c 81       	ldd	r25, Y+4	; 0x04
    399c:	01 97       	sbiw	r24, 0x01	; 1
    399e:	9c 83       	std	Y+4, r25	; 0x04
    39a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	86 e1       	ldi	r24, 0x16	; 22
    39a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39aa:	8b 81       	ldd	r24, Y+3	; 0x03
    39ac:	9c 81       	ldd	r25, Y+4	; 0x04
    39ae:	01 97       	sbiw	r24, 0x01	; 1
    39b0:	9c 83       	std	Y+4, r25	; 0x04
    39b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    39b4:	eb 81       	ldd	r30, Y+3	; 0x03
    39b6:	fc 81       	ldd	r31, Y+4	; 0x04
    39b8:	87 e1       	ldi	r24, 0x17	; 23
    39ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	9c 81       	ldd	r25, Y+4	; 0x04
    39c0:	01 97       	sbiw	r24, 0x01	; 1
    39c2:	9c 83       	std	Y+4, r25	; 0x04
    39c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    39c6:	eb 81       	ldd	r30, Y+3	; 0x03
    39c8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ca:	88 e1       	ldi	r24, 0x18	; 24
    39cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	9c 81       	ldd	r25, Y+4	; 0x04
    39d2:	01 97       	sbiw	r24, 0x01	; 1
    39d4:	9c 83       	std	Y+4, r25	; 0x04
    39d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    39d8:	eb 81       	ldd	r30, Y+3	; 0x03
    39da:	fc 81       	ldd	r31, Y+4	; 0x04
    39dc:	89 e1       	ldi	r24, 0x19	; 25
    39de:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e0:	8b 81       	ldd	r24, Y+3	; 0x03
    39e2:	9c 81       	ldd	r25, Y+4	; 0x04
    39e4:	01 97       	sbiw	r24, 0x01	; 1
    39e6:	9c 83       	std	Y+4, r25	; 0x04
    39e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    39ea:	eb 81       	ldd	r30, Y+3	; 0x03
    39ec:	fc 81       	ldd	r31, Y+4	; 0x04
    39ee:	80 e2       	ldi	r24, 0x20	; 32
    39f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    39f2:	8b 81       	ldd	r24, Y+3	; 0x03
    39f4:	9c 81       	ldd	r25, Y+4	; 0x04
    39f6:	01 97       	sbiw	r24, 0x01	; 1
    39f8:	9c 83       	std	Y+4, r25	; 0x04
    39fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    39fc:	eb 81       	ldd	r30, Y+3	; 0x03
    39fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3a00:	81 e2       	ldi	r24, 0x21	; 33
    3a02:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
    3a08:	01 97       	sbiw	r24, 0x01	; 1
    3a0a:	9c 83       	std	Y+4, r25	; 0x04
    3a0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a10:	fc 81       	ldd	r31, Y+4	; 0x04
    3a12:	82 e2       	ldi	r24, 0x22	; 34
    3a14:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a16:	8b 81       	ldd	r24, Y+3	; 0x03
    3a18:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1a:	01 97       	sbiw	r24, 0x01	; 1
    3a1c:	9c 83       	std	Y+4, r25	; 0x04
    3a1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3a20:	eb 81       	ldd	r30, Y+3	; 0x03
    3a22:	fc 81       	ldd	r31, Y+4	; 0x04
    3a24:	83 e2       	ldi	r24, 0x23	; 35
    3a26:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a28:	8b 81       	ldd	r24, Y+3	; 0x03
    3a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a2c:	01 97       	sbiw	r24, 0x01	; 1
    3a2e:	9c 83       	std	Y+4, r25	; 0x04
    3a30:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    3a32:	8f 81       	ldd	r24, Y+7	; 0x07
    3a34:	98 85       	ldd	r25, Y+8	; 0x08
    3a36:	9a 83       	std	Y+2, r25	; 0x02
    3a38:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a3a:	89 81       	ldd	r24, Y+1	; 0x01
    3a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a40:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a42:	8b 81       	ldd	r24, Y+3	; 0x03
    3a44:	9c 81       	ldd	r25, Y+4	; 0x04
    3a46:	01 97       	sbiw	r24, 0x01	; 1
    3a48:	9c 83       	std	Y+4, r25	; 0x04
    3a4a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3a4c:	89 81       	ldd	r24, Y+1	; 0x01
    3a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a50:	89 2f       	mov	r24, r25
    3a52:	99 27       	eor	r25, r25
    3a54:	9a 83       	std	Y+2, r25	; 0x02
    3a56:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a58:	89 81       	ldd	r24, Y+1	; 0x01
    3a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a60:	8b 81       	ldd	r24, Y+3	; 0x03
    3a62:	9c 81       	ldd	r25, Y+4	; 0x04
    3a64:	01 97       	sbiw	r24, 0x01	; 1
    3a66:	9c 83       	std	Y+4, r25	; 0x04
    3a68:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a6e:	86 e2       	ldi	r24, 0x26	; 38
    3a70:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a72:	8b 81       	ldd	r24, Y+3	; 0x03
    3a74:	9c 81       	ldd	r25, Y+4	; 0x04
    3a76:	01 97       	sbiw	r24, 0x01	; 1
    3a78:	9c 83       	std	Y+4, r25	; 0x04
    3a7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a80:	87 e2       	ldi	r24, 0x27	; 39
    3a82:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a84:	8b 81       	ldd	r24, Y+3	; 0x03
    3a86:	9c 81       	ldd	r25, Y+4	; 0x04
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	9c 83       	std	Y+4, r25	; 0x04
    3a8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a90:	fc 81       	ldd	r31, Y+4	; 0x04
    3a92:	88 e2       	ldi	r24, 0x28	; 40
    3a94:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a96:	8b 81       	ldd	r24, Y+3	; 0x03
    3a98:	9c 81       	ldd	r25, Y+4	; 0x04
    3a9a:	01 97       	sbiw	r24, 0x01	; 1
    3a9c:	9c 83       	std	Y+4, r25	; 0x04
    3a9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    3aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    3aa4:	89 e2       	ldi	r24, 0x29	; 41
    3aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    3aac:	01 97       	sbiw	r24, 0x01	; 1
    3aae:	9c 83       	std	Y+4, r25	; 0x04
    3ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ab6:	80 e3       	ldi	r24, 0x30	; 48
    3ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aba:	8b 81       	ldd	r24, Y+3	; 0x03
    3abc:	9c 81       	ldd	r25, Y+4	; 0x04
    3abe:	01 97       	sbiw	r24, 0x01	; 1
    3ac0:	9c 83       	std	Y+4, r25	; 0x04
    3ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ac8:	81 e3       	ldi	r24, 0x31	; 49
    3aca:	80 83       	st	Z, r24
	pxTopOfStack--;
    3acc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ace:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad0:	01 97       	sbiw	r24, 0x01	; 1
    3ad2:	9c 83       	std	Y+4, r25	; 0x04
    3ad4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3ada:	28 96       	adiw	r28, 0x08	; 8
    3adc:	0f b6       	in	r0, 0x3f	; 63
    3ade:	f8 94       	cli
    3ae0:	de bf       	out	0x3e, r29	; 62
    3ae2:	0f be       	out	0x3f, r0	; 63
    3ae4:	cd bf       	out	0x3d, r28	; 61
    3ae6:	cf 91       	pop	r28
    3ae8:	df 91       	pop	r29
    3aea:	08 95       	ret

00003aec <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3aec:	df 93       	push	r29
    3aee:	cf 93       	push	r28
    3af0:	cd b7       	in	r28, 0x3d	; 61
    3af2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3af4:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3af8:	a0 91 ec 06 	lds	r26, 0x06EC
    3afc:	b0 91 ed 06 	lds	r27, 0x06ED
    3b00:	cd 91       	ld	r28, X+
    3b02:	cd bf       	out	0x3d, r28	; 61
    3b04:	dd 91       	ld	r29, X+
    3b06:	de bf       	out	0x3e, r29	; 62
    3b08:	ff 91       	pop	r31
    3b0a:	ef 91       	pop	r30
    3b0c:	df 91       	pop	r29
    3b0e:	cf 91       	pop	r28
    3b10:	bf 91       	pop	r27
    3b12:	af 91       	pop	r26
    3b14:	9f 91       	pop	r25
    3b16:	8f 91       	pop	r24
    3b18:	7f 91       	pop	r23
    3b1a:	6f 91       	pop	r22
    3b1c:	5f 91       	pop	r21
    3b1e:	4f 91       	pop	r20
    3b20:	3f 91       	pop	r19
    3b22:	2f 91       	pop	r18
    3b24:	1f 91       	pop	r17
    3b26:	0f 91       	pop	r16
    3b28:	ff 90       	pop	r15
    3b2a:	ef 90       	pop	r14
    3b2c:	df 90       	pop	r13
    3b2e:	cf 90       	pop	r12
    3b30:	bf 90       	pop	r11
    3b32:	af 90       	pop	r10
    3b34:	9f 90       	pop	r9
    3b36:	8f 90       	pop	r8
    3b38:	7f 90       	pop	r7
    3b3a:	6f 90       	pop	r6
    3b3c:	5f 90       	pop	r5
    3b3e:	4f 90       	pop	r4
    3b40:	3f 90       	pop	r3
    3b42:	2f 90       	pop	r2
    3b44:	1f 90       	pop	r1
    3b46:	0f 90       	pop	r0
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3b4c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3b4e:	81 e0       	ldi	r24, 0x01	; 1
}
    3b50:	cf 91       	pop	r28
    3b52:	df 91       	pop	r29
    3b54:	08 95       	ret

00003b56 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3b56:	df 93       	push	r29
    3b58:	cf 93       	push	r28
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3b5e:	cf 91       	pop	r28
    3b60:	df 91       	pop	r29
    3b62:	08 95       	ret

00003b64 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3b64:	0f 92       	push	r0
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	f8 94       	cli
    3b6a:	0f 92       	push	r0
    3b6c:	1f 92       	push	r1
    3b6e:	11 24       	eor	r1, r1
    3b70:	2f 92       	push	r2
    3b72:	3f 92       	push	r3
    3b74:	4f 92       	push	r4
    3b76:	5f 92       	push	r5
    3b78:	6f 92       	push	r6
    3b7a:	7f 92       	push	r7
    3b7c:	8f 92       	push	r8
    3b7e:	9f 92       	push	r9
    3b80:	af 92       	push	r10
    3b82:	bf 92       	push	r11
    3b84:	cf 92       	push	r12
    3b86:	df 92       	push	r13
    3b88:	ef 92       	push	r14
    3b8a:	ff 92       	push	r15
    3b8c:	0f 93       	push	r16
    3b8e:	1f 93       	push	r17
    3b90:	2f 93       	push	r18
    3b92:	3f 93       	push	r19
    3b94:	4f 93       	push	r20
    3b96:	5f 93       	push	r21
    3b98:	6f 93       	push	r22
    3b9a:	7f 93       	push	r23
    3b9c:	8f 93       	push	r24
    3b9e:	9f 93       	push	r25
    3ba0:	af 93       	push	r26
    3ba2:	bf 93       	push	r27
    3ba4:	cf 93       	push	r28
    3ba6:	df 93       	push	r29
    3ba8:	ef 93       	push	r30
    3baa:	ff 93       	push	r31
    3bac:	a0 91 ec 06 	lds	r26, 0x06EC
    3bb0:	b0 91 ed 06 	lds	r27, 0x06ED
    3bb4:	0d b6       	in	r0, 0x3d	; 61
    3bb6:	0d 92       	st	X+, r0
    3bb8:	0e b6       	in	r0, 0x3e	; 62
    3bba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3bbc:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3bc0:	a0 91 ec 06 	lds	r26, 0x06EC
    3bc4:	b0 91 ed 06 	lds	r27, 0x06ED
    3bc8:	cd 91       	ld	r28, X+
    3bca:	cd bf       	out	0x3d, r28	; 61
    3bcc:	dd 91       	ld	r29, X+
    3bce:	de bf       	out	0x3e, r29	; 62
    3bd0:	ff 91       	pop	r31
    3bd2:	ef 91       	pop	r30
    3bd4:	df 91       	pop	r29
    3bd6:	cf 91       	pop	r28
    3bd8:	bf 91       	pop	r27
    3bda:	af 91       	pop	r26
    3bdc:	9f 91       	pop	r25
    3bde:	8f 91       	pop	r24
    3be0:	7f 91       	pop	r23
    3be2:	6f 91       	pop	r22
    3be4:	5f 91       	pop	r21
    3be6:	4f 91       	pop	r20
    3be8:	3f 91       	pop	r19
    3bea:	2f 91       	pop	r18
    3bec:	1f 91       	pop	r17
    3bee:	0f 91       	pop	r16
    3bf0:	ff 90       	pop	r15
    3bf2:	ef 90       	pop	r14
    3bf4:	df 90       	pop	r13
    3bf6:	cf 90       	pop	r12
    3bf8:	bf 90       	pop	r11
    3bfa:	af 90       	pop	r10
    3bfc:	9f 90       	pop	r9
    3bfe:	8f 90       	pop	r8
    3c00:	7f 90       	pop	r7
    3c02:	6f 90       	pop	r6
    3c04:	5f 90       	pop	r5
    3c06:	4f 90       	pop	r4
    3c08:	3f 90       	pop	r3
    3c0a:	2f 90       	pop	r2
    3c0c:	1f 90       	pop	r1
    3c0e:	0f 90       	pop	r0
    3c10:	0f be       	out	0x3f, r0	; 63
    3c12:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3c14:	08 95       	ret

00003c16 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3c16:	0f 92       	push	r0
    3c18:	0f b6       	in	r0, 0x3f	; 63
    3c1a:	f8 94       	cli
    3c1c:	0f 92       	push	r0
    3c1e:	1f 92       	push	r1
    3c20:	11 24       	eor	r1, r1
    3c22:	2f 92       	push	r2
    3c24:	3f 92       	push	r3
    3c26:	4f 92       	push	r4
    3c28:	5f 92       	push	r5
    3c2a:	6f 92       	push	r6
    3c2c:	7f 92       	push	r7
    3c2e:	8f 92       	push	r8
    3c30:	9f 92       	push	r9
    3c32:	af 92       	push	r10
    3c34:	bf 92       	push	r11
    3c36:	cf 92       	push	r12
    3c38:	df 92       	push	r13
    3c3a:	ef 92       	push	r14
    3c3c:	ff 92       	push	r15
    3c3e:	0f 93       	push	r16
    3c40:	1f 93       	push	r17
    3c42:	2f 93       	push	r18
    3c44:	3f 93       	push	r19
    3c46:	4f 93       	push	r20
    3c48:	5f 93       	push	r21
    3c4a:	6f 93       	push	r22
    3c4c:	7f 93       	push	r23
    3c4e:	8f 93       	push	r24
    3c50:	9f 93       	push	r25
    3c52:	af 93       	push	r26
    3c54:	bf 93       	push	r27
    3c56:	cf 93       	push	r28
    3c58:	df 93       	push	r29
    3c5a:	ef 93       	push	r30
    3c5c:	ff 93       	push	r31
    3c5e:	a0 91 ec 06 	lds	r26, 0x06EC
    3c62:	b0 91 ed 06 	lds	r27, 0x06ED
    3c66:	0d b6       	in	r0, 0x3d	; 61
    3c68:	0d 92       	st	X+, r0
    3c6a:	0e b6       	in	r0, 0x3e	; 62
    3c6c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3c6e:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <xTaskIncrementTick>
    3c72:	88 23       	and	r24, r24
    3c74:	11 f0       	breq	.+4      	; 0x3c7a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3c76:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3c7a:	a0 91 ec 06 	lds	r26, 0x06EC
    3c7e:	b0 91 ed 06 	lds	r27, 0x06ED
    3c82:	cd 91       	ld	r28, X+
    3c84:	cd bf       	out	0x3d, r28	; 61
    3c86:	dd 91       	ld	r29, X+
    3c88:	de bf       	out	0x3e, r29	; 62
    3c8a:	ff 91       	pop	r31
    3c8c:	ef 91       	pop	r30
    3c8e:	df 91       	pop	r29
    3c90:	cf 91       	pop	r28
    3c92:	bf 91       	pop	r27
    3c94:	af 91       	pop	r26
    3c96:	9f 91       	pop	r25
    3c98:	8f 91       	pop	r24
    3c9a:	7f 91       	pop	r23
    3c9c:	6f 91       	pop	r22
    3c9e:	5f 91       	pop	r21
    3ca0:	4f 91       	pop	r20
    3ca2:	3f 91       	pop	r19
    3ca4:	2f 91       	pop	r18
    3ca6:	1f 91       	pop	r17
    3ca8:	0f 91       	pop	r16
    3caa:	ff 90       	pop	r15
    3cac:	ef 90       	pop	r14
    3cae:	df 90       	pop	r13
    3cb0:	cf 90       	pop	r12
    3cb2:	bf 90       	pop	r11
    3cb4:	af 90       	pop	r10
    3cb6:	9f 90       	pop	r9
    3cb8:	8f 90       	pop	r8
    3cba:	7f 90       	pop	r7
    3cbc:	6f 90       	pop	r6
    3cbe:	5f 90       	pop	r5
    3cc0:	4f 90       	pop	r4
    3cc2:	3f 90       	pop	r3
    3cc4:	2f 90       	pop	r2
    3cc6:	1f 90       	pop	r1
    3cc8:	0f 90       	pop	r0
    3cca:	0f be       	out	0x3f, r0	; 63
    3ccc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3cce:	08 95       	ret

00003cd0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3cd0:	df 93       	push	r29
    3cd2:	cf 93       	push	r28
    3cd4:	00 d0       	rcall	.+0      	; 0x3cd6 <prvSetupTimerInterrupt+0x6>
    3cd6:	00 d0       	rcall	.+0      	; 0x3cd8 <prvSetupTimerInterrupt+0x8>
    3cd8:	00 d0       	rcall	.+0      	; 0x3cda <prvSetupTimerInterrupt+0xa>
    3cda:	cd b7       	in	r28, 0x3d	; 61
    3cdc:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3cde:	80 e8       	ldi	r24, 0x80	; 128
    3ce0:	98 e3       	ldi	r25, 0x38	; 56
    3ce2:	a1 e0       	ldi	r26, 0x01	; 1
    3ce4:	b0 e0       	ldi	r27, 0x00	; 0
    3ce6:	8b 83       	std	Y+3, r24	; 0x03
    3ce8:	9c 83       	std	Y+4, r25	; 0x04
    3cea:	ad 83       	std	Y+5, r26	; 0x05
    3cec:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3cee:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf0:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf2:	ad 81       	ldd	r26, Y+5	; 0x05
    3cf4:	be 81       	ldd	r27, Y+6	; 0x06
    3cf6:	68 94       	set
    3cf8:	15 f8       	bld	r1, 5
    3cfa:	b6 95       	lsr	r27
    3cfc:	a7 95       	ror	r26
    3cfe:	97 95       	ror	r25
    3d00:	87 95       	ror	r24
    3d02:	16 94       	lsr	r1
    3d04:	d1 f7       	brne	.-12     	; 0x3cfa <prvSetupTimerInterrupt+0x2a>
    3d06:	8b 83       	std	Y+3, r24	; 0x03
    3d08:	9c 83       	std	Y+4, r25	; 0x04
    3d0a:	ad 83       	std	Y+5, r26	; 0x05
    3d0c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d10:	9c 81       	ldd	r25, Y+4	; 0x04
    3d12:	ad 81       	ldd	r26, Y+5	; 0x05
    3d14:	be 81       	ldd	r27, Y+6	; 0x06
    3d16:	01 97       	sbiw	r24, 0x01	; 1
    3d18:	a1 09       	sbc	r26, r1
    3d1a:	b1 09       	sbc	r27, r1
    3d1c:	8b 83       	std	Y+3, r24	; 0x03
    3d1e:	9c 83       	std	Y+4, r25	; 0x04
    3d20:	ad 83       	std	Y+5, r26	; 0x05
    3d22:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3d24:	8b 81       	ldd	r24, Y+3	; 0x03
    3d26:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3d28:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2c:	ad 81       	ldd	r26, Y+5	; 0x05
    3d2e:	be 81       	ldd	r27, Y+6	; 0x06
    3d30:	89 2f       	mov	r24, r25
    3d32:	9a 2f       	mov	r25, r26
    3d34:	ab 2f       	mov	r26, r27
    3d36:	bb 27       	eor	r27, r27
    3d38:	8b 83       	std	Y+3, r24	; 0x03
    3d3a:	9c 83       	std	Y+4, r25	; 0x04
    3d3c:	ad 83       	std	Y+5, r26	; 0x05
    3d3e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3d40:	8b 81       	ldd	r24, Y+3	; 0x03
    3d42:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3d44:	eb e4       	ldi	r30, 0x4B	; 75
    3d46:	f0 e0       	ldi	r31, 0x00	; 0
    3d48:	8a 81       	ldd	r24, Y+2	; 0x02
    3d4a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3d4c:	ea e4       	ldi	r30, 0x4A	; 74
    3d4e:	f0 e0       	ldi	r31, 0x00	; 0
    3d50:	89 81       	ldd	r24, Y+1	; 0x01
    3d52:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3d54:	8b e0       	ldi	r24, 0x0B	; 11
    3d56:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3d58:	ee e4       	ldi	r30, 0x4E	; 78
    3d5a:	f0 e0       	ldi	r31, 0x00	; 0
    3d5c:	89 81       	ldd	r24, Y+1	; 0x01
    3d5e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3d60:	e9 e5       	ldi	r30, 0x59	; 89
    3d62:	f0 e0       	ldi	r31, 0x00	; 0
    3d64:	80 81       	ld	r24, Z
    3d66:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3d68:	89 81       	ldd	r24, Y+1	; 0x01
    3d6a:	80 61       	ori	r24, 0x10	; 16
    3d6c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3d6e:	e9 e5       	ldi	r30, 0x59	; 89
    3d70:	f0 e0       	ldi	r31, 0x00	; 0
    3d72:	89 81       	ldd	r24, Y+1	; 0x01
    3d74:	80 83       	st	Z, r24
}
    3d76:	26 96       	adiw	r28, 0x06	; 6
    3d78:	0f b6       	in	r0, 0x3f	; 63
    3d7a:	f8 94       	cli
    3d7c:	de bf       	out	0x3e, r29	; 62
    3d7e:	0f be       	out	0x3f, r0	; 63
    3d80:	cd bf       	out	0x3d, r28	; 61
    3d82:	cf 91       	pop	r28
    3d84:	df 91       	pop	r29
    3d86:	08 95       	ret

00003d88 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3d88:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3d8c:	18 95       	reti

00003d8e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3d8e:	df 93       	push	r29
    3d90:	cf 93       	push	r28
    3d92:	00 d0       	rcall	.+0      	; 0x3d94 <xQueueGenericReset+0x6>
    3d94:	00 d0       	rcall	.+0      	; 0x3d96 <xQueueGenericReset+0x8>
    3d96:	0f 92       	push	r0
    3d98:	cd b7       	in	r28, 0x3d	; 61
    3d9a:	de b7       	in	r29, 0x3e	; 62
    3d9c:	9c 83       	std	Y+4, r25	; 0x04
    3d9e:	8b 83       	std	Y+3, r24	; 0x03
    3da0:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3da2:	8b 81       	ldd	r24, Y+3	; 0x03
    3da4:	9c 81       	ldd	r25, Y+4	; 0x04
    3da6:	9a 83       	std	Y+2, r25	; 0x02
    3da8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3daa:	0f b6       	in	r0, 0x3f	; 63
    3dac:	f8 94       	cli
    3dae:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3db0:	e9 81       	ldd	r30, Y+1	; 0x01
    3db2:	fa 81       	ldd	r31, Y+2	; 0x02
    3db4:	40 81       	ld	r20, Z
    3db6:	51 81       	ldd	r21, Z+1	; 0x01
    3db8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dba:	fa 81       	ldd	r31, Y+2	; 0x02
    3dbc:	83 8d       	ldd	r24, Z+27	; 0x1b
    3dbe:	28 2f       	mov	r18, r24
    3dc0:	30 e0       	ldi	r19, 0x00	; 0
    3dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3dc8:	88 2f       	mov	r24, r24
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	bc 01       	movw	r22, r24
    3dce:	26 9f       	mul	r18, r22
    3dd0:	c0 01       	movw	r24, r0
    3dd2:	27 9f       	mul	r18, r23
    3dd4:	90 0d       	add	r25, r0
    3dd6:	36 9f       	mul	r19, r22
    3dd8:	90 0d       	add	r25, r0
    3dda:	11 24       	eor	r1, r1
    3ddc:	84 0f       	add	r24, r20
    3dde:	95 1f       	adc	r25, r21
    3de0:	e9 81       	ldd	r30, Y+1	; 0x01
    3de2:	fa 81       	ldd	r31, Y+2	; 0x02
    3de4:	93 83       	std	Z+3, r25	; 0x03
    3de6:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3de8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dea:	fa 81       	ldd	r31, Y+2	; 0x02
    3dec:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3dee:	e9 81       	ldd	r30, Y+1	; 0x01
    3df0:	fa 81       	ldd	r31, Y+2	; 0x02
    3df2:	80 81       	ld	r24, Z
    3df4:	91 81       	ldd	r25, Z+1	; 0x01
    3df6:	e9 81       	ldd	r30, Y+1	; 0x01
    3df8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfa:	95 83       	std	Z+5, r25	; 0x05
    3dfc:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    3dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    3e00:	fa 81       	ldd	r31, Y+2	; 0x02
    3e02:	40 81       	ld	r20, Z
    3e04:	51 81       	ldd	r21, Z+1	; 0x01
    3e06:	e9 81       	ldd	r30, Y+1	; 0x01
    3e08:	fa 81       	ldd	r31, Y+2	; 0x02
    3e0a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3e0c:	88 2f       	mov	r24, r24
    3e0e:	90 e0       	ldi	r25, 0x00	; 0
    3e10:	9c 01       	movw	r18, r24
    3e12:	21 50       	subi	r18, 0x01	; 1
    3e14:	30 40       	sbci	r19, 0x00	; 0
    3e16:	e9 81       	ldd	r30, Y+1	; 0x01
    3e18:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e1c:	88 2f       	mov	r24, r24
    3e1e:	90 e0       	ldi	r25, 0x00	; 0
    3e20:	bc 01       	movw	r22, r24
    3e22:	26 9f       	mul	r18, r22
    3e24:	c0 01       	movw	r24, r0
    3e26:	27 9f       	mul	r18, r23
    3e28:	90 0d       	add	r25, r0
    3e2a:	36 9f       	mul	r19, r22
    3e2c:	90 0d       	add	r25, r0
    3e2e:	11 24       	eor	r1, r1
    3e30:	84 0f       	add	r24, r20
    3e32:	95 1f       	adc	r25, r21
    3e34:	e9 81       	ldd	r30, Y+1	; 0x01
    3e36:	fa 81       	ldd	r31, Y+2	; 0x02
    3e38:	97 83       	std	Z+7, r25	; 0x07
    3e3a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    3e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e40:	8f ef       	ldi	r24, 0xFF	; 255
    3e42:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    3e44:	e9 81       	ldd	r30, Y+1	; 0x01
    3e46:	fa 81       	ldd	r31, Y+2	; 0x02
    3e48:	8f ef       	ldi	r24, 0xFF	; 255
    3e4a:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3e4c:	8d 81       	ldd	r24, Y+5	; 0x05
    3e4e:	88 23       	and	r24, r24
    3e50:	79 f4       	brne	.+30     	; 0x3e70 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e52:	e9 81       	ldd	r30, Y+1	; 0x01
    3e54:	fa 81       	ldd	r31, Y+2	; 0x02
    3e56:	80 85       	ldd	r24, Z+8	; 0x08
    3e58:	88 23       	and	r24, r24
    3e5a:	a1 f0       	breq	.+40     	; 0x3e84 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e60:	08 96       	adiw	r24, 0x08	; 8
    3e62:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    3e66:	81 30       	cpi	r24, 0x01	; 1
    3e68:	69 f4       	brne	.+26     	; 0x3e84 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3e6a:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    3e6e:	0a c0       	rjmp	.+20     	; 0x3e84 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	08 96       	adiw	r24, 0x08	; 8
    3e76:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3e7a:	89 81       	ldd	r24, Y+1	; 0x01
    3e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e7e:	41 96       	adiw	r24, 0x11	; 17
    3e80:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3e84:	0f 90       	pop	r0
    3e86:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3e88:	81 e0       	ldi	r24, 0x01	; 1
}
    3e8a:	0f 90       	pop	r0
    3e8c:	0f 90       	pop	r0
    3e8e:	0f 90       	pop	r0
    3e90:	0f 90       	pop	r0
    3e92:	0f 90       	pop	r0
    3e94:	cf 91       	pop	r28
    3e96:	df 91       	pop	r29
    3e98:	08 95       	ret

00003e9a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    3e9a:	df 93       	push	r29
    3e9c:	cf 93       	push	r28
    3e9e:	cd b7       	in	r28, 0x3d	; 61
    3ea0:	de b7       	in	r29, 0x3e	; 62
    3ea2:	29 97       	sbiw	r28, 0x09	; 9
    3ea4:	0f b6       	in	r0, 0x3f	; 63
    3ea6:	f8 94       	cli
    3ea8:	de bf       	out	0x3e, r29	; 62
    3eaa:	0f be       	out	0x3f, r0	; 63
    3eac:	cd bf       	out	0x3d, r28	; 61
    3eae:	8f 83       	std	Y+7, r24	; 0x07
    3eb0:	68 87       	std	Y+8, r22	; 0x08
    3eb2:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    3eb4:	1a 82       	std	Y+2, r1	; 0x02
    3eb6:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    3eb8:	8f 81       	ldd	r24, Y+7	; 0x07
    3eba:	88 23       	and	r24, r24
    3ebc:	09 f4       	brne	.+2      	; 0x3ec0 <xQueueGenericCreate+0x26>
    3ebe:	43 c0       	rjmp	.+134    	; 0x3f46 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    3ec0:	81 e2       	ldi	r24, 0x21	; 33
    3ec2:	90 e0       	ldi	r25, 0x00	; 0
    3ec4:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    3ec8:	9e 83       	std	Y+6, r25	; 0x06
    3eca:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    3ece:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed0:	00 97       	sbiw	r24, 0x00	; 0
    3ed2:	c9 f1       	breq	.+114    	; 0x3f46 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3ed4:	8f 81       	ldd	r24, Y+7	; 0x07
    3ed6:	28 2f       	mov	r18, r24
    3ed8:	30 e0       	ldi	r19, 0x00	; 0
    3eda:	88 85       	ldd	r24, Y+8	; 0x08
    3edc:	88 2f       	mov	r24, r24
    3ede:	90 e0       	ldi	r25, 0x00	; 0
    3ee0:	ac 01       	movw	r20, r24
    3ee2:	24 9f       	mul	r18, r20
    3ee4:	c0 01       	movw	r24, r0
    3ee6:	25 9f       	mul	r18, r21
    3ee8:	90 0d       	add	r25, r0
    3eea:	34 9f       	mul	r19, r20
    3eec:	90 0d       	add	r25, r0
    3eee:	11 24       	eor	r1, r1
    3ef0:	01 96       	adiw	r24, 0x01	; 1
    3ef2:	9c 83       	std	Y+4, r25	; 0x04
    3ef4:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    3ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    3efa:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    3efe:	ed 81       	ldd	r30, Y+5	; 0x05
    3f00:	fe 81       	ldd	r31, Y+6	; 0x06
    3f02:	91 83       	std	Z+1, r25	; 0x01
    3f04:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3f06:	ed 81       	ldd	r30, Y+5	; 0x05
    3f08:	fe 81       	ldd	r31, Y+6	; 0x06
    3f0a:	80 81       	ld	r24, Z
    3f0c:	91 81       	ldd	r25, Z+1	; 0x01
    3f0e:	00 97       	sbiw	r24, 0x00	; 0
    3f10:	b1 f0       	breq	.+44     	; 0x3f3e <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    3f12:	ed 81       	ldd	r30, Y+5	; 0x05
    3f14:	fe 81       	ldd	r31, Y+6	; 0x06
    3f16:	8f 81       	ldd	r24, Y+7	; 0x07
    3f18:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3f1a:	ed 81       	ldd	r30, Y+5	; 0x05
    3f1c:	fe 81       	ldd	r31, Y+6	; 0x06
    3f1e:	88 85       	ldd	r24, Y+8	; 0x08
    3f20:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3f22:	8d 81       	ldd	r24, Y+5	; 0x05
    3f24:	9e 81       	ldd	r25, Y+6	; 0x06
    3f26:	61 e0       	ldi	r22, 0x01	; 1
    3f28:	0e 94 c7 1e 	call	0x3d8e	; 0x3d8e <xQueueGenericReset>

				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
    3f2c:	ed 81       	ldd	r30, Y+5	; 0x05
    3f2e:	fe 81       	ldd	r31, Y+6	; 0x06
    3f30:	89 85       	ldd	r24, Y+9	; 0x09
    3f32:	80 a3       	std	Z+32, r24	; 0x20
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3f34:	8d 81       	ldd	r24, Y+5	; 0x05
    3f36:	9e 81       	ldd	r25, Y+6	; 0x06
    3f38:	9a 83       	std	Y+2, r25	; 0x02
    3f3a:	89 83       	std	Y+1, r24	; 0x01
    3f3c:	04 c0       	rjmp	.+8      	; 0x3f46 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    3f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    3f40:	9e 81       	ldd	r25, Y+6	; 0x06
    3f42:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    3f46:	89 81       	ldd	r24, Y+1	; 0x01
    3f48:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3f4a:	29 96       	adiw	r28, 0x09	; 9
    3f4c:	0f b6       	in	r0, 0x3f	; 63
    3f4e:	f8 94       	cli
    3f50:	de bf       	out	0x3e, r29	; 62
    3f52:	0f be       	out	0x3f, r0	; 63
    3f54:	cd bf       	out	0x3d, r28	; 61
    3f56:	cf 91       	pop	r28
    3f58:	df 91       	pop	r29
    3f5a:	08 95       	ret

00003f5c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    3f5c:	df 93       	push	r29
    3f5e:	cf 93       	push	r28
    3f60:	00 d0       	rcall	.+0      	; 0x3f62 <xQueueCreateMutex+0x6>
    3f62:	0f 92       	push	r0
    3f64:	cd b7       	in	r28, 0x3d	; 61
    3f66:	de b7       	in	r29, 0x3e	; 62
    3f68:	8b 83       	std	Y+3, r24	; 0x03
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    3f6a:	81 e2       	ldi	r24, 0x21	; 33
    3f6c:	90 e0       	ldi	r25, 0x00	; 0
    3f6e:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    3f72:	9a 83       	std	Y+2, r25	; 0x02
    3f74:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    3f76:	89 81       	ldd	r24, Y+1	; 0x01
    3f78:	9a 81       	ldd	r25, Y+2	; 0x02
    3f7a:	00 97       	sbiw	r24, 0x00	; 0
    3f7c:	c9 f1       	breq	.+114    	; 0x3ff0 <xQueueCreateMutex+0x94>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    3f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f80:	fa 81       	ldd	r31, Y+2	; 0x02
    3f82:	13 82       	std	Z+3, r1	; 0x03
    3f84:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3f86:	e9 81       	ldd	r30, Y+1	; 0x01
    3f88:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8a:	11 82       	std	Z+1, r1	; 0x01
    3f8c:	10 82       	st	Z, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    3f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f90:	fa 81       	ldd	r31, Y+2	; 0x02
    3f92:	15 82       	std	Z+5, r1	; 0x05
    3f94:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    3f96:	e9 81       	ldd	r30, Y+1	; 0x01
    3f98:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9a:	17 82       	std	Z+7, r1	; 0x07
    3f9c:	16 82       	std	Z+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa2:	12 8e       	std	Z+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    3fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa8:	81 e0       	ldi	r24, 0x01	; 1
    3faa:	83 8f       	std	Z+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    3fac:	e9 81       	ldd	r30, Y+1	; 0x01
    3fae:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb0:	14 8e       	std	Z+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    3fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb6:	8f ef       	ldi	r24, 0xFF	; 255
    3fb8:	85 8f       	std	Z+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    3fba:	e9 81       	ldd	r30, Y+1	; 0x01
    3fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    3fbe:	8f ef       	ldi	r24, 0xFF	; 255
    3fc0:	86 8f       	std	Z+30, r24	; 0x1e

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
    3fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc8:	80 a3       	std	Z+32, r24	; 0x20
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3fca:	89 81       	ldd	r24, Y+1	; 0x01
    3fcc:	9a 81       	ldd	r25, Y+2	; 0x02
    3fce:	08 96       	adiw	r24, 0x08	; 8
    3fd0:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3fd4:	89 81       	ldd	r24, Y+1	; 0x01
    3fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd8:	41 96       	adiw	r24, 0x11	; 17
    3fda:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3fde:	89 81       	ldd	r24, Y+1	; 0x01
    3fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe2:	60 e0       	ldi	r22, 0x00	; 0
    3fe4:	70 e0       	ldi	r23, 0x00	; 0
    3fe6:	40 e0       	ldi	r20, 0x00	; 0
    3fe8:	50 e0       	ldi	r21, 0x00	; 0
    3fea:	20 e0       	ldi	r18, 0x00	; 0
    3fec:	0e 94 20 20 	call	0x4040	; 0x4040 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    3ff0:	89 81       	ldd	r24, Y+1	; 0x01
    3ff2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3ff4:	0f 90       	pop	r0
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	cf 91       	pop	r28
    3ffc:	df 91       	pop	r29
    3ffe:	08 95       	ret

00004000 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    4000:	df 93       	push	r29
    4002:	cf 93       	push	r28
    4004:	00 d0       	rcall	.+0      	; 0x4006 <xQueueCreateCountingSemaphore+0x6>
    4006:	00 d0       	rcall	.+0      	; 0x4008 <xQueueCreateCountingSemaphore+0x8>
    4008:	cd b7       	in	r28, 0x3d	; 61
    400a:	de b7       	in	r29, 0x3e	; 62
    400c:	8b 83       	std	Y+3, r24	; 0x03
    400e:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    4010:	8b 81       	ldd	r24, Y+3	; 0x03
    4012:	60 e0       	ldi	r22, 0x00	; 0
    4014:	42 e0       	ldi	r20, 0x02	; 2
    4016:	0e 94 4d 1f 	call	0x3e9a	; 0x3e9a <xQueueGenericCreate>
    401a:	9a 83       	std	Y+2, r25	; 0x02
    401c:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    401e:	89 81       	ldd	r24, Y+1	; 0x01
    4020:	9a 81       	ldd	r25, Y+2	; 0x02
    4022:	00 97       	sbiw	r24, 0x00	; 0
    4024:	21 f0       	breq	.+8      	; 0x402e <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    4026:	e9 81       	ldd	r30, Y+1	; 0x01
    4028:	fa 81       	ldd	r31, Y+2	; 0x02
    402a:	8c 81       	ldd	r24, Y+4	; 0x04
    402c:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    402e:	89 81       	ldd	r24, Y+1	; 0x01
    4030:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	0f 90       	pop	r0
    4038:	0f 90       	pop	r0
    403a:	cf 91       	pop	r28
    403c:	df 91       	pop	r29
    403e:	08 95       	ret

00004040 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    4040:	df 93       	push	r29
    4042:	cf 93       	push	r28
    4044:	cd b7       	in	r28, 0x3d	; 61
    4046:	de b7       	in	r29, 0x3e	; 62
    4048:	2f 97       	sbiw	r28, 0x0f	; 15
    404a:	0f b6       	in	r0, 0x3f	; 63
    404c:	f8 94       	cli
    404e:	de bf       	out	0x3e, r29	; 62
    4050:	0f be       	out	0x3f, r0	; 63
    4052:	cd bf       	out	0x3d, r28	; 61
    4054:	99 87       	std	Y+9, r25	; 0x09
    4056:	88 87       	std	Y+8, r24	; 0x08
    4058:	7b 87       	std	Y+11, r23	; 0x0b
    405a:	6a 87       	std	Y+10, r22	; 0x0a
    405c:	5d 87       	std	Y+13, r21	; 0x0d
    405e:	4c 87       	std	Y+12, r20	; 0x0c
    4060:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    4062:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4064:	88 85       	ldd	r24, Y+8	; 0x08
    4066:	99 85       	ldd	r25, Y+9	; 0x09
    4068:	9a 83       	std	Y+2, r25	; 0x02
    406a:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4072:	e9 81       	ldd	r30, Y+1	; 0x01
    4074:	fa 81       	ldd	r31, Y+2	; 0x02
    4076:	92 8d       	ldd	r25, Z+26	; 0x1a
    4078:	e9 81       	ldd	r30, Y+1	; 0x01
    407a:	fa 81       	ldd	r31, Y+2	; 0x02
    407c:	83 8d       	ldd	r24, Z+27	; 0x1b
    407e:	98 17       	cp	r25, r24
    4080:	18 f0       	brcs	.+6      	; 0x4088 <xQueueGenericSend+0x48>
    4082:	8e 85       	ldd	r24, Y+14	; 0x0e
    4084:	82 30       	cpi	r24, 0x02	; 2
    4086:	11 f5       	brne	.+68     	; 0x40cc <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4088:	89 81       	ldd	r24, Y+1	; 0x01
    408a:	9a 81       	ldd	r25, Y+2	; 0x02
    408c:	2a 85       	ldd	r18, Y+10	; 0x0a
    408e:	3b 85       	ldd	r19, Y+11	; 0x0b
    4090:	b9 01       	movw	r22, r18
    4092:	4e 85       	ldd	r20, Y+14	; 0x0e
    4094:	0e 94 43 23 	call	0x4686	; 0x4686 <prvCopyDataToQueue>
    4098:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    409a:	e9 81       	ldd	r30, Y+1	; 0x01
    409c:	fa 81       	ldd	r31, Y+2	; 0x02
    409e:	81 89       	ldd	r24, Z+17	; 0x11
    40a0:	88 23       	and	r24, r24
    40a2:	51 f0       	breq	.+20     	; 0x40b8 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    40a4:	89 81       	ldd	r24, Y+1	; 0x01
    40a6:	9a 81       	ldd	r25, Y+2	; 0x02
    40a8:	41 96       	adiw	r24, 0x11	; 17
    40aa:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    40ae:	81 30       	cpi	r24, 0x01	; 1
    40b0:	41 f4       	brne	.+16     	; 0x40c2 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    40b2:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    40b6:	05 c0       	rjmp	.+10     	; 0x40c2 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    40b8:	8b 81       	ldd	r24, Y+3	; 0x03
    40ba:	88 23       	and	r24, r24
    40bc:	11 f0       	breq	.+4      	; 0x40c2 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    40be:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    40c2:	0f 90       	pop	r0
    40c4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    40c6:	81 e0       	ldi	r24, 0x01	; 1
    40c8:	8f 87       	std	Y+15, r24	; 0x0f
    40ca:	5c c0       	rjmp	.+184    	; 0x4184 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    40cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    40ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    40d0:	00 97       	sbiw	r24, 0x00	; 0
    40d2:	21 f4       	brne	.+8      	; 0x40dc <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    40d4:	0f 90       	pop	r0
    40d6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    40d8:	1f 86       	std	Y+15, r1	; 0x0f
    40da:	54 c0       	rjmp	.+168    	; 0x4184 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    40dc:	8c 81       	ldd	r24, Y+4	; 0x04
    40de:	88 23       	and	r24, r24
    40e0:	31 f4       	brne	.+12     	; 0x40ee <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    40e2:	ce 01       	movw	r24, r28
    40e4:	05 96       	adiw	r24, 0x05	; 5
    40e6:	0e 94 b2 2f 	call	0x5f64	; 0x5f64 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    40ea:	81 e0       	ldi	r24, 0x01	; 1
    40ec:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    40ee:	0f 90       	pop	r0
    40f0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    40f2:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    40f6:	0f b6       	in	r0, 0x3f	; 63
    40f8:	f8 94       	cli
    40fa:	0f 92       	push	r0
    40fc:	e9 81       	ldd	r30, Y+1	; 0x01
    40fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4100:	85 8d       	ldd	r24, Z+29	; 0x1d
    4102:	8f 3f       	cpi	r24, 0xFF	; 255
    4104:	19 f4       	brne	.+6      	; 0x410c <xQueueGenericSend+0xcc>
    4106:	e9 81       	ldd	r30, Y+1	; 0x01
    4108:	fa 81       	ldd	r31, Y+2	; 0x02
    410a:	15 8e       	std	Z+29, r1	; 0x1d
    410c:	e9 81       	ldd	r30, Y+1	; 0x01
    410e:	fa 81       	ldd	r31, Y+2	; 0x02
    4110:	86 8d       	ldd	r24, Z+30	; 0x1e
    4112:	8f 3f       	cpi	r24, 0xFF	; 255
    4114:	19 f4       	brne	.+6      	; 0x411c <xQueueGenericSend+0xdc>
    4116:	e9 81       	ldd	r30, Y+1	; 0x01
    4118:	fa 81       	ldd	r31, Y+2	; 0x02
    411a:	16 8e       	std	Z+30, r1	; 0x1e
    411c:	0f 90       	pop	r0
    411e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4120:	ce 01       	movw	r24, r28
    4122:	05 96       	adiw	r24, 0x05	; 5
    4124:	9e 01       	movw	r18, r28
    4126:	24 5f       	subi	r18, 0xF4	; 244
    4128:	3f 4f       	sbci	r19, 0xFF	; 255
    412a:	b9 01       	movw	r22, r18
    412c:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <xTaskCheckForTimeOut>
    4130:	88 23       	and	r24, r24
    4132:	09 f5       	brne	.+66     	; 0x4176 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4134:	89 81       	ldd	r24, Y+1	; 0x01
    4136:	9a 81       	ldd	r25, Y+2	; 0x02
    4138:	0e 94 cc 24 	call	0x4998	; 0x4998 <prvIsQueueFull>
    413c:	88 23       	and	r24, r24
    413e:	a1 f0       	breq	.+40     	; 0x4168 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4140:	89 81       	ldd	r24, Y+1	; 0x01
    4142:	9a 81       	ldd	r25, Y+2	; 0x02
    4144:	08 96       	adiw	r24, 0x08	; 8
    4146:	2c 85       	ldd	r18, Y+12	; 0x0c
    4148:	3d 85       	ldd	r19, Y+13	; 0x0d
    414a:	b9 01       	movw	r22, r18
    414c:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4150:	89 81       	ldd	r24, Y+1	; 0x01
    4152:	9a 81       	ldd	r25, Y+2	; 0x02
    4154:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    4158:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    415c:	88 23       	and	r24, r24
    415e:	09 f0       	breq	.+2      	; 0x4162 <xQueueGenericSend+0x122>
    4160:	85 cf       	rjmp	.-246    	; 0x406c <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    4162:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    4166:	82 cf       	rjmp	.-252    	; 0x406c <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4168:	89 81       	ldd	r24, Y+1	; 0x01
    416a:	9a 81       	ldd	r25, Y+2	; 0x02
    416c:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4170:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    4174:	7b cf       	rjmp	.-266    	; 0x406c <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    4176:	89 81       	ldd	r24, Y+1	; 0x01
    4178:	9a 81       	ldd	r25, Y+2	; 0x02
    417a:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    417e:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4182:	1f 86       	std	Y+15, r1	; 0x0f
    4184:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    4186:	2f 96       	adiw	r28, 0x0f	; 15
    4188:	0f b6       	in	r0, 0x3f	; 63
    418a:	f8 94       	cli
    418c:	de bf       	out	0x3e, r29	; 62
    418e:	0f be       	out	0x3f, r0	; 63
    4190:	cd bf       	out	0x3d, r28	; 61
    4192:	cf 91       	pop	r28
    4194:	df 91       	pop	r29
    4196:	08 95       	ret

00004198 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    4198:	df 93       	push	r29
    419a:	cf 93       	push	r28
    419c:	cd b7       	in	r28, 0x3d	; 61
    419e:	de b7       	in	r29, 0x3e	; 62
    41a0:	2b 97       	sbiw	r28, 0x0b	; 11
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	de bf       	out	0x3e, r29	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	cd bf       	out	0x3d, r28	; 61
    41ac:	9e 83       	std	Y+6, r25	; 0x06
    41ae:	8d 83       	std	Y+5, r24	; 0x05
    41b0:	78 87       	std	Y+8, r23	; 0x08
    41b2:	6f 83       	std	Y+7, r22	; 0x07
    41b4:	5a 87       	std	Y+10, r21	; 0x0a
    41b6:	49 87       	std	Y+9, r20	; 0x09
    41b8:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    41ba:	8d 81       	ldd	r24, Y+5	; 0x05
    41bc:	9e 81       	ldd	r25, Y+6	; 0x06
    41be:	9a 83       	std	Y+2, r25	; 0x02
    41c0:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    41c2:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    41c4:	e9 81       	ldd	r30, Y+1	; 0x01
    41c6:	fa 81       	ldd	r31, Y+2	; 0x02
    41c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    41ca:	e9 81       	ldd	r30, Y+1	; 0x01
    41cc:	fa 81       	ldd	r31, Y+2	; 0x02
    41ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    41d0:	98 17       	cp	r25, r24
    41d2:	18 f0       	brcs	.+6      	; 0x41da <xQueueGenericSendFromISR+0x42>
    41d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    41d6:	82 30       	cpi	r24, 0x02	; 2
    41d8:	b1 f5       	brne	.+108    	; 0x4246 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    41da:	89 81       	ldd	r24, Y+1	; 0x01
    41dc:	9a 81       	ldd	r25, Y+2	; 0x02
    41de:	2f 81       	ldd	r18, Y+7	; 0x07
    41e0:	38 85       	ldd	r19, Y+8	; 0x08
    41e2:	b9 01       	movw	r22, r18
    41e4:	4b 85       	ldd	r20, Y+11	; 0x0b
    41e6:	0e 94 43 23 	call	0x4686	; 0x4686 <prvCopyDataToQueue>
    41ea:	88 23       	and	r24, r24
    41ec:	41 f0       	breq	.+16     	; 0x41fe <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    41ee:	89 85       	ldd	r24, Y+9	; 0x09
    41f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    41f2:	00 97       	sbiw	r24, 0x00	; 0
    41f4:	21 f0       	breq	.+8      	; 0x41fe <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    41f6:	e9 85       	ldd	r30, Y+9	; 0x09
    41f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    41fa:	81 e0       	ldi	r24, 0x01	; 1
    41fc:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    41fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4200:	fa 81       	ldd	r31, Y+2	; 0x02
    4202:	86 8d       	ldd	r24, Z+30	; 0x1e
    4204:	8f 3f       	cpi	r24, 0xFF	; 255
    4206:	a9 f4       	brne	.+42     	; 0x4232 <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4208:	e9 81       	ldd	r30, Y+1	; 0x01
    420a:	fa 81       	ldd	r31, Y+2	; 0x02
    420c:	81 89       	ldd	r24, Z+17	; 0x11
    420e:	88 23       	and	r24, r24
    4210:	b9 f0       	breq	.+46     	; 0x4240 <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	9a 81       	ldd	r25, Y+2	; 0x02
    4216:	41 96       	adiw	r24, 0x11	; 17
    4218:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    421c:	88 23       	and	r24, r24
    421e:	81 f0       	breq	.+32     	; 0x4240 <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    4220:	89 85       	ldd	r24, Y+9	; 0x09
    4222:	9a 85       	ldd	r25, Y+10	; 0x0a
    4224:	00 97       	sbiw	r24, 0x00	; 0
    4226:	61 f0       	breq	.+24     	; 0x4240 <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    4228:	e9 85       	ldd	r30, Y+9	; 0x09
    422a:	fa 85       	ldd	r31, Y+10	; 0x0a
    422c:	81 e0       	ldi	r24, 0x01	; 1
    422e:	80 83       	st	Z, r24
    4230:	07 c0       	rjmp	.+14     	; 0x4240 <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    4232:	e9 81       	ldd	r30, Y+1	; 0x01
    4234:	fa 81       	ldd	r31, Y+2	; 0x02
    4236:	86 8d       	ldd	r24, Z+30	; 0x1e
    4238:	8f 5f       	subi	r24, 0xFF	; 255
    423a:	e9 81       	ldd	r30, Y+1	; 0x01
    423c:	fa 81       	ldd	r31, Y+2	; 0x02
    423e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4240:	81 e0       	ldi	r24, 0x01	; 1
    4242:	8c 83       	std	Y+4, r24	; 0x04
    4244:	01 c0       	rjmp	.+2      	; 0x4248 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4246:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4248:	8c 81       	ldd	r24, Y+4	; 0x04
}
    424a:	2b 96       	adiw	r28, 0x0b	; 11
    424c:	0f b6       	in	r0, 0x3f	; 63
    424e:	f8 94       	cli
    4250:	de bf       	out	0x3e, r29	; 62
    4252:	0f be       	out	0x3f, r0	; 63
    4254:	cd bf       	out	0x3d, r28	; 61
    4256:	cf 91       	pop	r28
    4258:	df 91       	pop	r29
    425a:	08 95       	ret

0000425c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    425c:	df 93       	push	r29
    425e:	cf 93       	push	r28
    4260:	cd b7       	in	r28, 0x3d	; 61
    4262:	de b7       	in	r29, 0x3e	; 62
    4264:	60 97       	sbiw	r28, 0x10	; 16
    4266:	0f b6       	in	r0, 0x3f	; 63
    4268:	f8 94       	cli
    426a:	de bf       	out	0x3e, r29	; 62
    426c:	0f be       	out	0x3f, r0	; 63
    426e:	cd bf       	out	0x3d, r28	; 61
    4270:	9a 87       	std	Y+10, r25	; 0x0a
    4272:	89 87       	std	Y+9, r24	; 0x09
    4274:	7c 87       	std	Y+12, r23	; 0x0c
    4276:	6b 87       	std	Y+11, r22	; 0x0b
    4278:	5e 87       	std	Y+14, r21	; 0x0e
    427a:	4d 87       	std	Y+13, r20	; 0x0d
    427c:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    427e:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4280:	89 85       	ldd	r24, Y+9	; 0x09
    4282:	9a 85       	ldd	r25, Y+10	; 0x0a
    4284:	9a 83       	std	Y+2, r25	; 0x02
    4286:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4288:	0f b6       	in	r0, 0x3f	; 63
    428a:	f8 94       	cli
    428c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    428e:	e9 81       	ldd	r30, Y+1	; 0x01
    4290:	fa 81       	ldd	r31, Y+2	; 0x02
    4292:	82 8d       	ldd	r24, Z+26	; 0x1a
    4294:	88 23       	and	r24, r24
    4296:	09 f4       	brne	.+2      	; 0x429a <xQueueGenericReceive+0x3e>
    4298:	4b c0       	rjmp	.+150    	; 0x4330 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    429a:	e9 81       	ldd	r30, Y+1	; 0x01
    429c:	fa 81       	ldd	r31, Y+2	; 0x02
    429e:	86 81       	ldd	r24, Z+6	; 0x06
    42a0:	97 81       	ldd	r25, Z+7	; 0x07
    42a2:	9c 83       	std	Y+4, r25	; 0x04
    42a4:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    42a6:	89 81       	ldd	r24, Y+1	; 0x01
    42a8:	9a 81       	ldd	r25, Y+2	; 0x02
    42aa:	2b 85       	ldd	r18, Y+11	; 0x0b
    42ac:	3c 85       	ldd	r19, Y+12	; 0x0c
    42ae:	b9 01       	movw	r22, r18
    42b0:	0e 94 fc 23 	call	0x47f8	; 0x47f8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    42b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    42b6:	88 23       	and	r24, r24
    42b8:	11 f5       	brne	.+68     	; 0x42fe <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    42ba:	e9 81       	ldd	r30, Y+1	; 0x01
    42bc:	fa 81       	ldd	r31, Y+2	; 0x02
    42be:	82 8d       	ldd	r24, Z+26	; 0x1a
    42c0:	81 50       	subi	r24, 0x01	; 1
    42c2:	e9 81       	ldd	r30, Y+1	; 0x01
    42c4:	fa 81       	ldd	r31, Y+2	; 0x02
    42c6:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    42c8:	e9 81       	ldd	r30, Y+1	; 0x01
    42ca:	fa 81       	ldd	r31, Y+2	; 0x02
    42cc:	80 81       	ld	r24, Z
    42ce:	91 81       	ldd	r25, Z+1	; 0x01
    42d0:	00 97       	sbiw	r24, 0x00	; 0
    42d2:	31 f4       	brne	.+12     	; 0x42e0 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    42d4:	0e 94 4a 35 	call	0x6a94	; 0x6a94 <pvTaskIncrementMutexHeldCount>
    42d8:	e9 81       	ldd	r30, Y+1	; 0x01
    42da:	fa 81       	ldd	r31, Y+2	; 0x02
    42dc:	93 83       	std	Z+3, r25	; 0x03
    42de:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    42e0:	e9 81       	ldd	r30, Y+1	; 0x01
    42e2:	fa 81       	ldd	r31, Y+2	; 0x02
    42e4:	80 85       	ldd	r24, Z+8	; 0x08
    42e6:	88 23       	and	r24, r24
    42e8:	f1 f0       	breq	.+60     	; 0x4326 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    42ea:	89 81       	ldd	r24, Y+1	; 0x01
    42ec:	9a 81       	ldd	r25, Y+2	; 0x02
    42ee:	08 96       	adiw	r24, 0x08	; 8
    42f0:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    42f4:	81 30       	cpi	r24, 0x01	; 1
    42f6:	b9 f4       	brne	.+46     	; 0x4326 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    42f8:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    42fc:	14 c0       	rjmp	.+40     	; 0x4326 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    42fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4300:	fa 81       	ldd	r31, Y+2	; 0x02
    4302:	8b 81       	ldd	r24, Y+3	; 0x03
    4304:	9c 81       	ldd	r25, Y+4	; 0x04
    4306:	97 83       	std	Z+7, r25	; 0x07
    4308:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    430a:	e9 81       	ldd	r30, Y+1	; 0x01
    430c:	fa 81       	ldd	r31, Y+2	; 0x02
    430e:	81 89       	ldd	r24, Z+17	; 0x11
    4310:	88 23       	and	r24, r24
    4312:	49 f0       	breq	.+18     	; 0x4326 <xQueueGenericReceive+0xca>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4314:	89 81       	ldd	r24, Y+1	; 0x01
    4316:	9a 81       	ldd	r25, Y+2	; 0x02
    4318:	41 96       	adiw	r24, 0x11	; 17
    431a:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    431e:	88 23       	and	r24, r24
    4320:	11 f0       	breq	.+4      	; 0x4326 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    4322:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    4326:	0f 90       	pop	r0
    4328:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    432a:	81 e0       	ldi	r24, 0x01	; 1
    432c:	88 8b       	std	Y+16, r24	; 0x10
    432e:	6d c0       	rjmp	.+218    	; 0x440a <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4330:	8d 85       	ldd	r24, Y+13	; 0x0d
    4332:	9e 85       	ldd	r25, Y+14	; 0x0e
    4334:	00 97       	sbiw	r24, 0x00	; 0
    4336:	21 f4       	brne	.+8      	; 0x4340 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4338:	0f 90       	pop	r0
    433a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    433c:	18 8a       	std	Y+16, r1	; 0x10
    433e:	65 c0       	rjmp	.+202    	; 0x440a <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
    4340:	8d 81       	ldd	r24, Y+5	; 0x05
    4342:	88 23       	and	r24, r24
    4344:	31 f4       	brne	.+12     	; 0x4352 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4346:	ce 01       	movw	r24, r28
    4348:	06 96       	adiw	r24, 0x06	; 6
    434a:	0e 94 b2 2f 	call	0x5f64	; 0x5f64 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    434e:	81 e0       	ldi	r24, 0x01	; 1
    4350:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4352:	0f 90       	pop	r0
    4354:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4356:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    435a:	0f b6       	in	r0, 0x3f	; 63
    435c:	f8 94       	cli
    435e:	0f 92       	push	r0
    4360:	e9 81       	ldd	r30, Y+1	; 0x01
    4362:	fa 81       	ldd	r31, Y+2	; 0x02
    4364:	85 8d       	ldd	r24, Z+29	; 0x1d
    4366:	8f 3f       	cpi	r24, 0xFF	; 255
    4368:	19 f4       	brne	.+6      	; 0x4370 <xQueueGenericReceive+0x114>
    436a:	e9 81       	ldd	r30, Y+1	; 0x01
    436c:	fa 81       	ldd	r31, Y+2	; 0x02
    436e:	15 8e       	std	Z+29, r1	; 0x1d
    4370:	e9 81       	ldd	r30, Y+1	; 0x01
    4372:	fa 81       	ldd	r31, Y+2	; 0x02
    4374:	86 8d       	ldd	r24, Z+30	; 0x1e
    4376:	8f 3f       	cpi	r24, 0xFF	; 255
    4378:	19 f4       	brne	.+6      	; 0x4380 <xQueueGenericReceive+0x124>
    437a:	e9 81       	ldd	r30, Y+1	; 0x01
    437c:	fa 81       	ldd	r31, Y+2	; 0x02
    437e:	16 8e       	std	Z+30, r1	; 0x1e
    4380:	0f 90       	pop	r0
    4382:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4384:	ce 01       	movw	r24, r28
    4386:	06 96       	adiw	r24, 0x06	; 6
    4388:	9e 01       	movw	r18, r28
    438a:	23 5f       	subi	r18, 0xF3	; 243
    438c:	3f 4f       	sbci	r19, 0xFF	; 255
    438e:	b9 01       	movw	r22, r18
    4390:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <xTaskCheckForTimeOut>
    4394:	88 23       	and	r24, r24
    4396:	91 f5       	brne	.+100    	; 0x43fc <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4398:	89 81       	ldd	r24, Y+1	; 0x01
    439a:	9a 81       	ldd	r25, Y+2	; 0x02
    439c:	0e 94 97 24 	call	0x492e	; 0x492e <prvIsQueueEmpty>
    43a0:	88 23       	and	r24, r24
    43a2:	29 f1       	breq	.+74     	; 0x43ee <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    43a4:	e9 81       	ldd	r30, Y+1	; 0x01
    43a6:	fa 81       	ldd	r31, Y+2	; 0x02
    43a8:	80 81       	ld	r24, Z
    43aa:	91 81       	ldd	r25, Z+1	; 0x01
    43ac:	00 97       	sbiw	r24, 0x00	; 0
    43ae:	59 f4       	brne	.+22     	; 0x43c6 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    43b0:	0f b6       	in	r0, 0x3f	; 63
    43b2:	f8 94       	cli
    43b4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    43b6:	e9 81       	ldd	r30, Y+1	; 0x01
    43b8:	fa 81       	ldd	r31, Y+2	; 0x02
    43ba:	82 81       	ldd	r24, Z+2	; 0x02
    43bc:	93 81       	ldd	r25, Z+3	; 0x03
    43be:	0e 94 26 34 	call	0x684c	; 0x684c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    43c2:	0f 90       	pop	r0
    43c4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    43c6:	89 81       	ldd	r24, Y+1	; 0x01
    43c8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ca:	41 96       	adiw	r24, 0x11	; 17
    43cc:	2d 85       	ldd	r18, Y+13	; 0x0d
    43ce:	3e 85       	ldd	r19, Y+14	; 0x0e
    43d0:	b9 01       	movw	r22, r18
    43d2:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    43d6:	89 81       	ldd	r24, Y+1	; 0x01
    43d8:	9a 81       	ldd	r25, Y+2	; 0x02
    43da:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    43de:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    43e2:	88 23       	and	r24, r24
    43e4:	09 f0       	breq	.+2      	; 0x43e8 <xQueueGenericReceive+0x18c>
    43e6:	50 cf       	rjmp	.-352    	; 0x4288 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    43e8:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    43ec:	4d cf       	rjmp	.-358    	; 0x4288 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    43ee:	89 81       	ldd	r24, Y+1	; 0x01
    43f0:	9a 81       	ldd	r25, Y+2	; 0x02
    43f2:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    43f6:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    43fa:	46 cf       	rjmp	.-372    	; 0x4288 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    43fc:	89 81       	ldd	r24, Y+1	; 0x01
    43fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4400:	0e 94 43 24 	call	0x4886	; 0x4886 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4404:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4408:	18 8a       	std	Y+16, r1	; 0x10
    440a:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    440c:	60 96       	adiw	r28, 0x10	; 16
    440e:	0f b6       	in	r0, 0x3f	; 63
    4410:	f8 94       	cli
    4412:	de bf       	out	0x3e, r29	; 62
    4414:	0f be       	out	0x3f, r0	; 63
    4416:	cd bf       	out	0x3d, r28	; 61
    4418:	cf 91       	pop	r28
    441a:	df 91       	pop	r29
    441c:	08 95       	ret

0000441e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    441e:	df 93       	push	r29
    4420:	cf 93       	push	r28
    4422:	cd b7       	in	r28, 0x3d	; 61
    4424:	de b7       	in	r29, 0x3e	; 62
    4426:	2a 97       	sbiw	r28, 0x0a	; 10
    4428:	0f b6       	in	r0, 0x3f	; 63
    442a:	f8 94       	cli
    442c:	de bf       	out	0x3e, r29	; 62
    442e:	0f be       	out	0x3f, r0	; 63
    4430:	cd bf       	out	0x3d, r28	; 61
    4432:	9e 83       	std	Y+6, r25	; 0x06
    4434:	8d 83       	std	Y+5, r24	; 0x05
    4436:	78 87       	std	Y+8, r23	; 0x08
    4438:	6f 83       	std	Y+7, r22	; 0x07
    443a:	5a 87       	std	Y+10, r21	; 0x0a
    443c:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    443e:	8d 81       	ldd	r24, Y+5	; 0x05
    4440:	9e 81       	ldd	r25, Y+6	; 0x06
    4442:	9a 83       	std	Y+2, r25	; 0x02
    4444:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4446:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4448:	e9 81       	ldd	r30, Y+1	; 0x01
    444a:	fa 81       	ldd	r31, Y+2	; 0x02
    444c:	82 8d       	ldd	r24, Z+26	; 0x1a
    444e:	88 23       	and	r24, r24
    4450:	91 f1       	breq	.+100    	; 0x44b6 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4452:	89 81       	ldd	r24, Y+1	; 0x01
    4454:	9a 81       	ldd	r25, Y+2	; 0x02
    4456:	2f 81       	ldd	r18, Y+7	; 0x07
    4458:	38 85       	ldd	r19, Y+8	; 0x08
    445a:	b9 01       	movw	r22, r18
    445c:	0e 94 fc 23 	call	0x47f8	; 0x47f8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    4460:	e9 81       	ldd	r30, Y+1	; 0x01
    4462:	fa 81       	ldd	r31, Y+2	; 0x02
    4464:	82 8d       	ldd	r24, Z+26	; 0x1a
    4466:	81 50       	subi	r24, 0x01	; 1
    4468:	e9 81       	ldd	r30, Y+1	; 0x01
    446a:	fa 81       	ldd	r31, Y+2	; 0x02
    446c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    446e:	e9 81       	ldd	r30, Y+1	; 0x01
    4470:	fa 81       	ldd	r31, Y+2	; 0x02
    4472:	85 8d       	ldd	r24, Z+29	; 0x1d
    4474:	8f 3f       	cpi	r24, 0xFF	; 255
    4476:	a9 f4       	brne	.+42     	; 0x44a2 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4478:	e9 81       	ldd	r30, Y+1	; 0x01
    447a:	fa 81       	ldd	r31, Y+2	; 0x02
    447c:	80 85       	ldd	r24, Z+8	; 0x08
    447e:	88 23       	and	r24, r24
    4480:	b9 f0       	breq	.+46     	; 0x44b0 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4482:	89 81       	ldd	r24, Y+1	; 0x01
    4484:	9a 81       	ldd	r25, Y+2	; 0x02
    4486:	08 96       	adiw	r24, 0x08	; 8
    4488:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    448c:	88 23       	and	r24, r24
    448e:	81 f0       	breq	.+32     	; 0x44b0 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    4490:	89 85       	ldd	r24, Y+9	; 0x09
    4492:	9a 85       	ldd	r25, Y+10	; 0x0a
    4494:	00 97       	sbiw	r24, 0x00	; 0
    4496:	61 f0       	breq	.+24     	; 0x44b0 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    4498:	e9 85       	ldd	r30, Y+9	; 0x09
    449a:	fa 85       	ldd	r31, Y+10	; 0x0a
    449c:	81 e0       	ldi	r24, 0x01	; 1
    449e:	80 83       	st	Z, r24
    44a0:	07 c0       	rjmp	.+14     	; 0x44b0 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    44a2:	e9 81       	ldd	r30, Y+1	; 0x01
    44a4:	fa 81       	ldd	r31, Y+2	; 0x02
    44a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    44a8:	8f 5f       	subi	r24, 0xFF	; 255
    44aa:	e9 81       	ldd	r30, Y+1	; 0x01
    44ac:	fa 81       	ldd	r31, Y+2	; 0x02
    44ae:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    44b0:	81 e0       	ldi	r24, 0x01	; 1
    44b2:	8c 83       	std	Y+4, r24	; 0x04
    44b4:	01 c0       	rjmp	.+2      	; 0x44b8 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    44b6:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    44b8:	8c 81       	ldd	r24, Y+4	; 0x04
}
    44ba:	2a 96       	adiw	r28, 0x0a	; 10
    44bc:	0f b6       	in	r0, 0x3f	; 63
    44be:	f8 94       	cli
    44c0:	de bf       	out	0x3e, r29	; 62
    44c2:	0f be       	out	0x3f, r0	; 63
    44c4:	cd bf       	out	0x3d, r28	; 61
    44c6:	cf 91       	pop	r28
    44c8:	df 91       	pop	r29
    44ca:	08 95       	ret

000044cc <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    44cc:	df 93       	push	r29
    44ce:	cf 93       	push	r28
    44d0:	cd b7       	in	r28, 0x3d	; 61
    44d2:	de b7       	in	r29, 0x3e	; 62
    44d4:	2a 97       	sbiw	r28, 0x0a	; 10
    44d6:	0f b6       	in	r0, 0x3f	; 63
    44d8:	f8 94       	cli
    44da:	de bf       	out	0x3e, r29	; 62
    44dc:	0f be       	out	0x3f, r0	; 63
    44de:	cd bf       	out	0x3d, r28	; 61
    44e0:	98 87       	std	Y+8, r25	; 0x08
    44e2:	8f 83       	std	Y+7, r24	; 0x07
    44e4:	7a 87       	std	Y+10, r23	; 0x0a
    44e6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    44e8:	8f 81       	ldd	r24, Y+7	; 0x07
    44ea:	98 85       	ldd	r25, Y+8	; 0x08
    44ec:	9a 83       	std	Y+2, r25	; 0x02
    44ee:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    44f0:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    44f2:	e9 81       	ldd	r30, Y+1	; 0x01
    44f4:	fa 81       	ldd	r31, Y+2	; 0x02
    44f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    44f8:	88 23       	and	r24, r24
    44fa:	b1 f0       	breq	.+44     	; 0x4528 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    44fc:	e9 81       	ldd	r30, Y+1	; 0x01
    44fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4500:	86 81       	ldd	r24, Z+6	; 0x06
    4502:	97 81       	ldd	r25, Z+7	; 0x07
    4504:	9c 83       	std	Y+4, r25	; 0x04
    4506:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4508:	89 81       	ldd	r24, Y+1	; 0x01
    450a:	9a 81       	ldd	r25, Y+2	; 0x02
    450c:	29 85       	ldd	r18, Y+9	; 0x09
    450e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4510:	b9 01       	movw	r22, r18
    4512:	0e 94 fc 23 	call	0x47f8	; 0x47f8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4516:	e9 81       	ldd	r30, Y+1	; 0x01
    4518:	fa 81       	ldd	r31, Y+2	; 0x02
    451a:	8b 81       	ldd	r24, Y+3	; 0x03
    451c:	9c 81       	ldd	r25, Y+4	; 0x04
    451e:	97 83       	std	Z+7, r25	; 0x07
    4520:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    4522:	81 e0       	ldi	r24, 0x01	; 1
    4524:	8e 83       	std	Y+6, r24	; 0x06
    4526:	01 c0       	rjmp	.+2      	; 0x452a <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    4528:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    452a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    452c:	2a 96       	adiw	r28, 0x0a	; 10
    452e:	0f b6       	in	r0, 0x3f	; 63
    4530:	f8 94       	cli
    4532:	de bf       	out	0x3e, r29	; 62
    4534:	0f be       	out	0x3f, r0	; 63
    4536:	cd bf       	out	0x3d, r28	; 61
    4538:	cf 91       	pop	r28
    453a:	df 91       	pop	r29
    453c:	08 95       	ret

0000453e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    453e:	df 93       	push	r29
    4540:	cf 93       	push	r28
    4542:	00 d0       	rcall	.+0      	; 0x4544 <uxQueueMessagesWaiting+0x6>
    4544:	0f 92       	push	r0
    4546:	cd b7       	in	r28, 0x3d	; 61
    4548:	de b7       	in	r29, 0x3e	; 62
    454a:	9b 83       	std	Y+3, r25	; 0x03
    454c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    454e:	0f b6       	in	r0, 0x3f	; 63
    4550:	f8 94       	cli
    4552:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4554:	ea 81       	ldd	r30, Y+2	; 0x02
    4556:	fb 81       	ldd	r31, Y+3	; 0x03
    4558:	82 8d       	ldd	r24, Z+26	; 0x1a
    455a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    455c:	0f 90       	pop	r0
    455e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4560:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4562:	0f 90       	pop	r0
    4564:	0f 90       	pop	r0
    4566:	0f 90       	pop	r0
    4568:	cf 91       	pop	r28
    456a:	df 91       	pop	r29
    456c:	08 95       	ret

0000456e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    456e:	df 93       	push	r29
    4570:	cf 93       	push	r28
    4572:	00 d0       	rcall	.+0      	; 0x4574 <uxQueueSpacesAvailable+0x6>
    4574:	00 d0       	rcall	.+0      	; 0x4576 <uxQueueSpacesAvailable+0x8>
    4576:	0f 92       	push	r0
    4578:	cd b7       	in	r28, 0x3d	; 61
    457a:	de b7       	in	r29, 0x3e	; 62
    457c:	9d 83       	std	Y+5, r25	; 0x05
    457e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    4580:	8c 81       	ldd	r24, Y+4	; 0x04
    4582:	9d 81       	ldd	r25, Y+5	; 0x05
    4584:	9a 83       	std	Y+2, r25	; 0x02
    4586:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4588:	0f b6       	in	r0, 0x3f	; 63
    458a:	f8 94       	cli
    458c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    458e:	e9 81       	ldd	r30, Y+1	; 0x01
    4590:	fa 81       	ldd	r31, Y+2	; 0x02
    4592:	93 8d       	ldd	r25, Z+27	; 0x1b
    4594:	e9 81       	ldd	r30, Y+1	; 0x01
    4596:	fa 81       	ldd	r31, Y+2	; 0x02
    4598:	82 8d       	ldd	r24, Z+26	; 0x1a
    459a:	29 2f       	mov	r18, r25
    459c:	28 1b       	sub	r18, r24
    459e:	82 2f       	mov	r24, r18
    45a0:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    45a2:	0f 90       	pop	r0
    45a4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    45a6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    45a8:	0f 90       	pop	r0
    45aa:	0f 90       	pop	r0
    45ac:	0f 90       	pop	r0
    45ae:	0f 90       	pop	r0
    45b0:	0f 90       	pop	r0
    45b2:	cf 91       	pop	r28
    45b4:	df 91       	pop	r29
    45b6:	08 95       	ret

000045b8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    45b8:	df 93       	push	r29
    45ba:	cf 93       	push	r28
    45bc:	00 d0       	rcall	.+0      	; 0x45be <uxQueueMessagesWaitingFromISR+0x6>
    45be:	0f 92       	push	r0
    45c0:	cd b7       	in	r28, 0x3d	; 61
    45c2:	de b7       	in	r29, 0x3e	; 62
    45c4:	9b 83       	std	Y+3, r25	; 0x03
    45c6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    45c8:	ea 81       	ldd	r30, Y+2	; 0x02
    45ca:	fb 81       	ldd	r31, Y+3	; 0x03
    45cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    45ce:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    45d0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    45d2:	0f 90       	pop	r0
    45d4:	0f 90       	pop	r0
    45d6:	0f 90       	pop	r0
    45d8:	cf 91       	pop	r28
    45da:	df 91       	pop	r29
    45dc:	08 95       	ret

000045de <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    45de:	df 93       	push	r29
    45e0:	cf 93       	push	r28
    45e2:	00 d0       	rcall	.+0      	; 0x45e4 <vQueueDelete+0x6>
    45e4:	00 d0       	rcall	.+0      	; 0x45e6 <vQueueDelete+0x8>
    45e6:	cd b7       	in	r28, 0x3d	; 61
    45e8:	de b7       	in	r29, 0x3e	; 62
    45ea:	9c 83       	std	Y+4, r25	; 0x04
    45ec:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    45ee:	8b 81       	ldd	r24, Y+3	; 0x03
    45f0:	9c 81       	ldd	r25, Y+4	; 0x04
    45f2:	9a 83       	std	Y+2, r25	; 0x02
    45f4:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    45f6:	e9 81       	ldd	r30, Y+1	; 0x01
    45f8:	fa 81       	ldd	r31, Y+2	; 0x02
    45fa:	80 81       	ld	r24, Z
    45fc:	91 81       	ldd	r25, Z+1	; 0x01
    45fe:	00 97       	sbiw	r24, 0x00	; 0
    4600:	31 f0       	breq	.+12     	; 0x460e <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    4602:	e9 81       	ldd	r30, Y+1	; 0x01
    4604:	fa 81       	ldd	r31, Y+2	; 0x02
    4606:	80 81       	ld	r24, Z
    4608:	91 81       	ldd	r25, Z+1	; 0x01
    460a:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
	}
	vPortFree( pxQueue );
    460e:	89 81       	ldd	r24, Y+1	; 0x01
    4610:	9a 81       	ldd	r25, Y+2	; 0x02
    4612:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
}
    4616:	0f 90       	pop	r0
    4618:	0f 90       	pop	r0
    461a:	0f 90       	pop	r0
    461c:	0f 90       	pop	r0
    461e:	cf 91       	pop	r28
    4620:	df 91       	pop	r29
    4622:	08 95       	ret

00004624 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
    4624:	df 93       	push	r29
    4626:	cf 93       	push	r28
    4628:	00 d0       	rcall	.+0      	; 0x462a <uxQueueGetQueueNumber+0x6>
    462a:	cd b7       	in	r28, 0x3d	; 61
    462c:	de b7       	in	r29, 0x3e	; 62
    462e:	9a 83       	std	Y+2, r25	; 0x02
    4630:	89 83       	std	Y+1, r24	; 0x01
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    4632:	e9 81       	ldd	r30, Y+1	; 0x01
    4634:	fa 81       	ldd	r31, Y+2	; 0x02
    4636:	87 8d       	ldd	r24, Z+31	; 0x1f
	}
    4638:	0f 90       	pop	r0
    463a:	0f 90       	pop	r0
    463c:	cf 91       	pop	r28
    463e:	df 91       	pop	r29
    4640:	08 95       	ret

00004642 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
    4642:	df 93       	push	r29
    4644:	cf 93       	push	r28
    4646:	00 d0       	rcall	.+0      	; 0x4648 <vQueueSetQueueNumber+0x6>
    4648:	0f 92       	push	r0
    464a:	cd b7       	in	r28, 0x3d	; 61
    464c:	de b7       	in	r29, 0x3e	; 62
    464e:	9a 83       	std	Y+2, r25	; 0x02
    4650:	89 83       	std	Y+1, r24	; 0x01
    4652:	6b 83       	std	Y+3, r22	; 0x03
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    4654:	e9 81       	ldd	r30, Y+1	; 0x01
    4656:	fa 81       	ldd	r31, Y+2	; 0x02
    4658:	8b 81       	ldd	r24, Y+3	; 0x03
    465a:	87 8f       	std	Z+31, r24	; 0x1f
	}
    465c:	0f 90       	pop	r0
    465e:	0f 90       	pop	r0
    4660:	0f 90       	pop	r0
    4662:	cf 91       	pop	r28
    4664:	df 91       	pop	r29
    4666:	08 95       	ret

00004668 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
    4668:	df 93       	push	r29
    466a:	cf 93       	push	r28
    466c:	00 d0       	rcall	.+0      	; 0x466e <ucQueueGetQueueType+0x6>
    466e:	cd b7       	in	r28, 0x3d	; 61
    4670:	de b7       	in	r29, 0x3e	; 62
    4672:	9a 83       	std	Y+2, r25	; 0x02
    4674:	89 83       	std	Y+1, r24	; 0x01
		return ( ( Queue_t * ) xQueue )->ucQueueType;
    4676:	e9 81       	ldd	r30, Y+1	; 0x01
    4678:	fa 81       	ldd	r31, Y+2	; 0x02
    467a:	80 a1       	ldd	r24, Z+32	; 0x20
	}
    467c:	0f 90       	pop	r0
    467e:	0f 90       	pop	r0
    4680:	cf 91       	pop	r28
    4682:	df 91       	pop	r29
    4684:	08 95       	ret

00004686 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    4686:	df 93       	push	r29
    4688:	cf 93       	push	r28
    468a:	00 d0       	rcall	.+0      	; 0x468c <prvCopyDataToQueue+0x6>
    468c:	00 d0       	rcall	.+0      	; 0x468e <prvCopyDataToQueue+0x8>
    468e:	00 d0       	rcall	.+0      	; 0x4690 <prvCopyDataToQueue+0xa>
    4690:	cd b7       	in	r28, 0x3d	; 61
    4692:	de b7       	in	r29, 0x3e	; 62
    4694:	9b 83       	std	Y+3, r25	; 0x03
    4696:	8a 83       	std	Y+2, r24	; 0x02
    4698:	7d 83       	std	Y+5, r23	; 0x05
    469a:	6c 83       	std	Y+4, r22	; 0x04
    469c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    469e:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    46a0:	ea 81       	ldd	r30, Y+2	; 0x02
    46a2:	fb 81       	ldd	r31, Y+3	; 0x03
    46a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    46a6:	88 23       	and	r24, r24
    46a8:	99 f4       	brne	.+38     	; 0x46d0 <prvCopyDataToQueue+0x4a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    46aa:	ea 81       	ldd	r30, Y+2	; 0x02
    46ac:	fb 81       	ldd	r31, Y+3	; 0x03
    46ae:	80 81       	ld	r24, Z
    46b0:	91 81       	ldd	r25, Z+1	; 0x01
    46b2:	00 97       	sbiw	r24, 0x00	; 0
    46b4:	09 f0       	breq	.+2      	; 0x46b8 <prvCopyDataToQueue+0x32>
    46b6:	8f c0       	rjmp	.+286    	; 0x47d6 <prvCopyDataToQueue+0x150>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    46b8:	ea 81       	ldd	r30, Y+2	; 0x02
    46ba:	fb 81       	ldd	r31, Y+3	; 0x03
    46bc:	82 81       	ldd	r24, Z+2	; 0x02
    46be:	93 81       	ldd	r25, Z+3	; 0x03
    46c0:	0e 94 b1 34 	call	0x6962	; 0x6962 <xTaskPriorityDisinherit>
    46c4:	89 83       	std	Y+1, r24	; 0x01
				pxQueue->pxMutexHolder = NULL;
    46c6:	ea 81       	ldd	r30, Y+2	; 0x02
    46c8:	fb 81       	ldd	r31, Y+3	; 0x03
    46ca:	13 82       	std	Z+3, r1	; 0x03
    46cc:	12 82       	std	Z+2, r1	; 0x02
    46ce:	83 c0       	rjmp	.+262    	; 0x47d6 <prvCopyDataToQueue+0x150>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    46d0:	8e 81       	ldd	r24, Y+6	; 0x06
    46d2:	88 23       	and	r24, r24
    46d4:	99 f5       	brne	.+102    	; 0x473c <prvCopyDataToQueue+0xb6>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    46d6:	ea 81       	ldd	r30, Y+2	; 0x02
    46d8:	fb 81       	ldd	r31, Y+3	; 0x03
    46da:	64 81       	ldd	r22, Z+4	; 0x04
    46dc:	75 81       	ldd	r23, Z+5	; 0x05
    46de:	ea 81       	ldd	r30, Y+2	; 0x02
    46e0:	fb 81       	ldd	r31, Y+3	; 0x03
    46e2:	84 8d       	ldd	r24, Z+28	; 0x1c
    46e4:	48 2f       	mov	r20, r24
    46e6:	50 e0       	ldi	r21, 0x00	; 0
    46e8:	2c 81       	ldd	r18, Y+4	; 0x04
    46ea:	3d 81       	ldd	r19, Y+5	; 0x05
    46ec:	cb 01       	movw	r24, r22
    46ee:	b9 01       	movw	r22, r18
    46f0:	0e 94 01 36 	call	0x6c02	; 0x6c02 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    46f4:	ea 81       	ldd	r30, Y+2	; 0x02
    46f6:	fb 81       	ldd	r31, Y+3	; 0x03
    46f8:	24 81       	ldd	r18, Z+4	; 0x04
    46fa:	35 81       	ldd	r19, Z+5	; 0x05
    46fc:	ea 81       	ldd	r30, Y+2	; 0x02
    46fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4700:	84 8d       	ldd	r24, Z+28	; 0x1c
    4702:	88 2f       	mov	r24, r24
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	82 0f       	add	r24, r18
    4708:	93 1f       	adc	r25, r19
    470a:	ea 81       	ldd	r30, Y+2	; 0x02
    470c:	fb 81       	ldd	r31, Y+3	; 0x03
    470e:	95 83       	std	Z+5, r25	; 0x05
    4710:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4712:	ea 81       	ldd	r30, Y+2	; 0x02
    4714:	fb 81       	ldd	r31, Y+3	; 0x03
    4716:	24 81       	ldd	r18, Z+4	; 0x04
    4718:	35 81       	ldd	r19, Z+5	; 0x05
    471a:	ea 81       	ldd	r30, Y+2	; 0x02
    471c:	fb 81       	ldd	r31, Y+3	; 0x03
    471e:	82 81       	ldd	r24, Z+2	; 0x02
    4720:	93 81       	ldd	r25, Z+3	; 0x03
    4722:	28 17       	cp	r18, r24
    4724:	39 07       	cpc	r19, r25
    4726:	08 f4       	brcc	.+2      	; 0x472a <prvCopyDataToQueue+0xa4>
    4728:	56 c0       	rjmp	.+172    	; 0x47d6 <prvCopyDataToQueue+0x150>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    472a:	ea 81       	ldd	r30, Y+2	; 0x02
    472c:	fb 81       	ldd	r31, Y+3	; 0x03
    472e:	80 81       	ld	r24, Z
    4730:	91 81       	ldd	r25, Z+1	; 0x01
    4732:	ea 81       	ldd	r30, Y+2	; 0x02
    4734:	fb 81       	ldd	r31, Y+3	; 0x03
    4736:	95 83       	std	Z+5, r25	; 0x05
    4738:	84 83       	std	Z+4, r24	; 0x04
    473a:	4d c0       	rjmp	.+154    	; 0x47d6 <prvCopyDataToQueue+0x150>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    473c:	ea 81       	ldd	r30, Y+2	; 0x02
    473e:	fb 81       	ldd	r31, Y+3	; 0x03
    4740:	66 81       	ldd	r22, Z+6	; 0x06
    4742:	77 81       	ldd	r23, Z+7	; 0x07
    4744:	ea 81       	ldd	r30, Y+2	; 0x02
    4746:	fb 81       	ldd	r31, Y+3	; 0x03
    4748:	84 8d       	ldd	r24, Z+28	; 0x1c
    474a:	48 2f       	mov	r20, r24
    474c:	50 e0       	ldi	r21, 0x00	; 0
    474e:	2c 81       	ldd	r18, Y+4	; 0x04
    4750:	3d 81       	ldd	r19, Y+5	; 0x05
    4752:	cb 01       	movw	r24, r22
    4754:	b9 01       	movw	r22, r18
    4756:	0e 94 01 36 	call	0x6c02	; 0x6c02 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    475a:	ea 81       	ldd	r30, Y+2	; 0x02
    475c:	fb 81       	ldd	r31, Y+3	; 0x03
    475e:	26 81       	ldd	r18, Z+6	; 0x06
    4760:	37 81       	ldd	r19, Z+7	; 0x07
    4762:	ea 81       	ldd	r30, Y+2	; 0x02
    4764:	fb 81       	ldd	r31, Y+3	; 0x03
    4766:	84 8d       	ldd	r24, Z+28	; 0x1c
    4768:	88 2f       	mov	r24, r24
    476a:	90 e0       	ldi	r25, 0x00	; 0
    476c:	90 95       	com	r25
    476e:	81 95       	neg	r24
    4770:	9f 4f       	sbci	r25, 0xFF	; 255
    4772:	82 0f       	add	r24, r18
    4774:	93 1f       	adc	r25, r19
    4776:	ea 81       	ldd	r30, Y+2	; 0x02
    4778:	fb 81       	ldd	r31, Y+3	; 0x03
    477a:	97 83       	std	Z+7, r25	; 0x07
    477c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    477e:	ea 81       	ldd	r30, Y+2	; 0x02
    4780:	fb 81       	ldd	r31, Y+3	; 0x03
    4782:	26 81       	ldd	r18, Z+6	; 0x06
    4784:	37 81       	ldd	r19, Z+7	; 0x07
    4786:	ea 81       	ldd	r30, Y+2	; 0x02
    4788:	fb 81       	ldd	r31, Y+3	; 0x03
    478a:	80 81       	ld	r24, Z
    478c:	91 81       	ldd	r25, Z+1	; 0x01
    478e:	28 17       	cp	r18, r24
    4790:	39 07       	cpc	r19, r25
    4792:	90 f4       	brcc	.+36     	; 0x47b8 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4794:	ea 81       	ldd	r30, Y+2	; 0x02
    4796:	fb 81       	ldd	r31, Y+3	; 0x03
    4798:	22 81       	ldd	r18, Z+2	; 0x02
    479a:	33 81       	ldd	r19, Z+3	; 0x03
    479c:	ea 81       	ldd	r30, Y+2	; 0x02
    479e:	fb 81       	ldd	r31, Y+3	; 0x03
    47a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    47a2:	88 2f       	mov	r24, r24
    47a4:	90 e0       	ldi	r25, 0x00	; 0
    47a6:	90 95       	com	r25
    47a8:	81 95       	neg	r24
    47aa:	9f 4f       	sbci	r25, 0xFF	; 255
    47ac:	82 0f       	add	r24, r18
    47ae:	93 1f       	adc	r25, r19
    47b0:	ea 81       	ldd	r30, Y+2	; 0x02
    47b2:	fb 81       	ldd	r31, Y+3	; 0x03
    47b4:	97 83       	std	Z+7, r25	; 0x07
    47b6:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    47b8:	8e 81       	ldd	r24, Y+6	; 0x06
    47ba:	82 30       	cpi	r24, 0x02	; 2
    47bc:	61 f4       	brne	.+24     	; 0x47d6 <prvCopyDataToQueue+0x150>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    47be:	ea 81       	ldd	r30, Y+2	; 0x02
    47c0:	fb 81       	ldd	r31, Y+3	; 0x03
    47c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    47c4:	88 23       	and	r24, r24
    47c6:	39 f0       	breq	.+14     	; 0x47d6 <prvCopyDataToQueue+0x150>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    47c8:	ea 81       	ldd	r30, Y+2	; 0x02
    47ca:	fb 81       	ldd	r31, Y+3	; 0x03
    47cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    47ce:	81 50       	subi	r24, 0x01	; 1
    47d0:	ea 81       	ldd	r30, Y+2	; 0x02
    47d2:	fb 81       	ldd	r31, Y+3	; 0x03
    47d4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    47d6:	ea 81       	ldd	r30, Y+2	; 0x02
    47d8:	fb 81       	ldd	r31, Y+3	; 0x03
    47da:	82 8d       	ldd	r24, Z+26	; 0x1a
    47dc:	8f 5f       	subi	r24, 0xFF	; 255
    47de:	ea 81       	ldd	r30, Y+2	; 0x02
    47e0:	fb 81       	ldd	r31, Y+3	; 0x03
    47e2:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    47e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    47e6:	26 96       	adiw	r28, 0x06	; 6
    47e8:	0f b6       	in	r0, 0x3f	; 63
    47ea:	f8 94       	cli
    47ec:	de bf       	out	0x3e, r29	; 62
    47ee:	0f be       	out	0x3f, r0	; 63
    47f0:	cd bf       	out	0x3d, r28	; 61
    47f2:	cf 91       	pop	r28
    47f4:	df 91       	pop	r29
    47f6:	08 95       	ret

000047f8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    47f8:	df 93       	push	r29
    47fa:	cf 93       	push	r28
    47fc:	00 d0       	rcall	.+0      	; 0x47fe <prvCopyDataFromQueue+0x6>
    47fe:	00 d0       	rcall	.+0      	; 0x4800 <prvCopyDataFromQueue+0x8>
    4800:	cd b7       	in	r28, 0x3d	; 61
    4802:	de b7       	in	r29, 0x3e	; 62
    4804:	9a 83       	std	Y+2, r25	; 0x02
    4806:	89 83       	std	Y+1, r24	; 0x01
    4808:	7c 83       	std	Y+4, r23	; 0x04
    480a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    480c:	e9 81       	ldd	r30, Y+1	; 0x01
    480e:	fa 81       	ldd	r31, Y+2	; 0x02
    4810:	84 8d       	ldd	r24, Z+28	; 0x1c
    4812:	88 23       	and	r24, r24
    4814:	89 f1       	breq	.+98     	; 0x4878 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4816:	e9 81       	ldd	r30, Y+1	; 0x01
    4818:	fa 81       	ldd	r31, Y+2	; 0x02
    481a:	26 81       	ldd	r18, Z+6	; 0x06
    481c:	37 81       	ldd	r19, Z+7	; 0x07
    481e:	e9 81       	ldd	r30, Y+1	; 0x01
    4820:	fa 81       	ldd	r31, Y+2	; 0x02
    4822:	84 8d       	ldd	r24, Z+28	; 0x1c
    4824:	88 2f       	mov	r24, r24
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	82 0f       	add	r24, r18
    482a:	93 1f       	adc	r25, r19
    482c:	e9 81       	ldd	r30, Y+1	; 0x01
    482e:	fa 81       	ldd	r31, Y+2	; 0x02
    4830:	97 83       	std	Z+7, r25	; 0x07
    4832:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4834:	e9 81       	ldd	r30, Y+1	; 0x01
    4836:	fa 81       	ldd	r31, Y+2	; 0x02
    4838:	26 81       	ldd	r18, Z+6	; 0x06
    483a:	37 81       	ldd	r19, Z+7	; 0x07
    483c:	e9 81       	ldd	r30, Y+1	; 0x01
    483e:	fa 81       	ldd	r31, Y+2	; 0x02
    4840:	82 81       	ldd	r24, Z+2	; 0x02
    4842:	93 81       	ldd	r25, Z+3	; 0x03
    4844:	28 17       	cp	r18, r24
    4846:	39 07       	cpc	r19, r25
    4848:	40 f0       	brcs	.+16     	; 0x485a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    484a:	e9 81       	ldd	r30, Y+1	; 0x01
    484c:	fa 81       	ldd	r31, Y+2	; 0x02
    484e:	80 81       	ld	r24, Z
    4850:	91 81       	ldd	r25, Z+1	; 0x01
    4852:	e9 81       	ldd	r30, Y+1	; 0x01
    4854:	fa 81       	ldd	r31, Y+2	; 0x02
    4856:	97 83       	std	Z+7, r25	; 0x07
    4858:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    485a:	e9 81       	ldd	r30, Y+1	; 0x01
    485c:	fa 81       	ldd	r31, Y+2	; 0x02
    485e:	46 81       	ldd	r20, Z+6	; 0x06
    4860:	57 81       	ldd	r21, Z+7	; 0x07
    4862:	e9 81       	ldd	r30, Y+1	; 0x01
    4864:	fa 81       	ldd	r31, Y+2	; 0x02
    4866:	84 8d       	ldd	r24, Z+28	; 0x1c
    4868:	28 2f       	mov	r18, r24
    486a:	30 e0       	ldi	r19, 0x00	; 0
    486c:	8b 81       	ldd	r24, Y+3	; 0x03
    486e:	9c 81       	ldd	r25, Y+4	; 0x04
    4870:	ba 01       	movw	r22, r20
    4872:	a9 01       	movw	r20, r18
    4874:	0e 94 01 36 	call	0x6c02	; 0x6c02 <memcpy>
	}
}
    4878:	0f 90       	pop	r0
    487a:	0f 90       	pop	r0
    487c:	0f 90       	pop	r0
    487e:	0f 90       	pop	r0
    4880:	cf 91       	pop	r28
    4882:	df 91       	pop	r29
    4884:	08 95       	ret

00004886 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4886:	df 93       	push	r29
    4888:	cf 93       	push	r28
    488a:	00 d0       	rcall	.+0      	; 0x488c <prvUnlockQueue+0x6>
    488c:	cd b7       	in	r28, 0x3d	; 61
    488e:	de b7       	in	r29, 0x3e	; 62
    4890:	9a 83       	std	Y+2, r25	; 0x02
    4892:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4894:	0f b6       	in	r0, 0x3f	; 63
    4896:	f8 94       	cli
    4898:	0f 92       	push	r0
    489a:	15 c0       	rjmp	.+42     	; 0x48c6 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    489c:	e9 81       	ldd	r30, Y+1	; 0x01
    489e:	fa 81       	ldd	r31, Y+2	; 0x02
    48a0:	81 89       	ldd	r24, Z+17	; 0x11
    48a2:	88 23       	and	r24, r24
    48a4:	a9 f0       	breq	.+42     	; 0x48d0 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    48a6:	89 81       	ldd	r24, Y+1	; 0x01
    48a8:	9a 81       	ldd	r25, Y+2	; 0x02
    48aa:	41 96       	adiw	r24, 0x11	; 17
    48ac:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    48b0:	88 23       	and	r24, r24
    48b2:	11 f0       	breq	.+4      	; 0x48b8 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    48b4:	0e 94 38 30 	call	0x6070	; 0x6070 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    48b8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ba:	fa 81       	ldd	r31, Y+2	; 0x02
    48bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    48be:	81 50       	subi	r24, 0x01	; 1
    48c0:	e9 81       	ldd	r30, Y+1	; 0x01
    48c2:	fa 81       	ldd	r31, Y+2	; 0x02
    48c4:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    48c6:	e9 81       	ldd	r30, Y+1	; 0x01
    48c8:	fa 81       	ldd	r31, Y+2	; 0x02
    48ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    48cc:	18 16       	cp	r1, r24
    48ce:	34 f3       	brlt	.-52     	; 0x489c <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    48d0:	e9 81       	ldd	r30, Y+1	; 0x01
    48d2:	fa 81       	ldd	r31, Y+2	; 0x02
    48d4:	8f ef       	ldi	r24, 0xFF	; 255
    48d6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    48d8:	0f 90       	pop	r0
    48da:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    48dc:	0f b6       	in	r0, 0x3f	; 63
    48de:	f8 94       	cli
    48e0:	0f 92       	push	r0
    48e2:	15 c0       	rjmp	.+42     	; 0x490e <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    48e4:	e9 81       	ldd	r30, Y+1	; 0x01
    48e6:	fa 81       	ldd	r31, Y+2	; 0x02
    48e8:	80 85       	ldd	r24, Z+8	; 0x08
    48ea:	88 23       	and	r24, r24
    48ec:	a9 f0       	breq	.+42     	; 0x4918 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    48ee:	89 81       	ldd	r24, Y+1	; 0x01
    48f0:	9a 81       	ldd	r25, Y+2	; 0x02
    48f2:	08 96       	adiw	r24, 0x08	; 8
    48f4:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <xTaskRemoveFromEventList>
    48f8:	88 23       	and	r24, r24
    48fa:	11 f0       	breq	.+4      	; 0x4900 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    48fc:	0e 94 38 30 	call	0x6070	; 0x6070 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4900:	e9 81       	ldd	r30, Y+1	; 0x01
    4902:	fa 81       	ldd	r31, Y+2	; 0x02
    4904:	85 8d       	ldd	r24, Z+29	; 0x1d
    4906:	81 50       	subi	r24, 0x01	; 1
    4908:	e9 81       	ldd	r30, Y+1	; 0x01
    490a:	fa 81       	ldd	r31, Y+2	; 0x02
    490c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    490e:	e9 81       	ldd	r30, Y+1	; 0x01
    4910:	fa 81       	ldd	r31, Y+2	; 0x02
    4912:	85 8d       	ldd	r24, Z+29	; 0x1d
    4914:	18 16       	cp	r1, r24
    4916:	34 f3       	brlt	.-52     	; 0x48e4 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4918:	e9 81       	ldd	r30, Y+1	; 0x01
    491a:	fa 81       	ldd	r31, Y+2	; 0x02
    491c:	8f ef       	ldi	r24, 0xFF	; 255
    491e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4920:	0f 90       	pop	r0
    4922:	0f be       	out	0x3f, r0	; 63
}
    4924:	0f 90       	pop	r0
    4926:	0f 90       	pop	r0
    4928:	cf 91       	pop	r28
    492a:	df 91       	pop	r29
    492c:	08 95       	ret

0000492e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    492e:	df 93       	push	r29
    4930:	cf 93       	push	r28
    4932:	00 d0       	rcall	.+0      	; 0x4934 <prvIsQueueEmpty+0x6>
    4934:	0f 92       	push	r0
    4936:	cd b7       	in	r28, 0x3d	; 61
    4938:	de b7       	in	r29, 0x3e	; 62
    493a:	9b 83       	std	Y+3, r25	; 0x03
    493c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    493e:	0f b6       	in	r0, 0x3f	; 63
    4940:	f8 94       	cli
    4942:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4944:	ea 81       	ldd	r30, Y+2	; 0x02
    4946:	fb 81       	ldd	r31, Y+3	; 0x03
    4948:	82 8d       	ldd	r24, Z+26	; 0x1a
    494a:	88 23       	and	r24, r24
    494c:	19 f4       	brne	.+6      	; 0x4954 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    494e:	81 e0       	ldi	r24, 0x01	; 1
    4950:	89 83       	std	Y+1, r24	; 0x01
    4952:	01 c0       	rjmp	.+2      	; 0x4956 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4954:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4956:	0f 90       	pop	r0
    4958:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    495a:	89 81       	ldd	r24, Y+1	; 0x01
}
    495c:	0f 90       	pop	r0
    495e:	0f 90       	pop	r0
    4960:	0f 90       	pop	r0
    4962:	cf 91       	pop	r28
    4964:	df 91       	pop	r29
    4966:	08 95       	ret

00004968 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4968:	df 93       	push	r29
    496a:	cf 93       	push	r28
    496c:	00 d0       	rcall	.+0      	; 0x496e <xQueueIsQueueEmptyFromISR+0x6>
    496e:	0f 92       	push	r0
    4970:	cd b7       	in	r28, 0x3d	; 61
    4972:	de b7       	in	r29, 0x3e	; 62
    4974:	9b 83       	std	Y+3, r25	; 0x03
    4976:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4978:	ea 81       	ldd	r30, Y+2	; 0x02
    497a:	fb 81       	ldd	r31, Y+3	; 0x03
    497c:	82 8d       	ldd	r24, Z+26	; 0x1a
    497e:	88 23       	and	r24, r24
    4980:	19 f4       	brne	.+6      	; 0x4988 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    4982:	81 e0       	ldi	r24, 0x01	; 1
    4984:	89 83       	std	Y+1, r24	; 0x01
    4986:	01 c0       	rjmp	.+2      	; 0x498a <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    4988:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    498a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    498c:	0f 90       	pop	r0
    498e:	0f 90       	pop	r0
    4990:	0f 90       	pop	r0
    4992:	cf 91       	pop	r28
    4994:	df 91       	pop	r29
    4996:	08 95       	ret

00004998 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    4998:	df 93       	push	r29
    499a:	cf 93       	push	r28
    499c:	00 d0       	rcall	.+0      	; 0x499e <prvIsQueueFull+0x6>
    499e:	0f 92       	push	r0
    49a0:	cd b7       	in	r28, 0x3d	; 61
    49a2:	de b7       	in	r29, 0x3e	; 62
    49a4:	9b 83       	std	Y+3, r25	; 0x03
    49a6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    49a8:	0f b6       	in	r0, 0x3f	; 63
    49aa:	f8 94       	cli
    49ac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    49ae:	ea 81       	ldd	r30, Y+2	; 0x02
    49b0:	fb 81       	ldd	r31, Y+3	; 0x03
    49b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    49b4:	ea 81       	ldd	r30, Y+2	; 0x02
    49b6:	fb 81       	ldd	r31, Y+3	; 0x03
    49b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    49ba:	98 17       	cp	r25, r24
    49bc:	19 f4       	brne	.+6      	; 0x49c4 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    49be:	81 e0       	ldi	r24, 0x01	; 1
    49c0:	89 83       	std	Y+1, r24	; 0x01
    49c2:	01 c0       	rjmp	.+2      	; 0x49c6 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    49c4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    49c6:	0f 90       	pop	r0
    49c8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    49cc:	0f 90       	pop	r0
    49ce:	0f 90       	pop	r0
    49d0:	0f 90       	pop	r0
    49d2:	cf 91       	pop	r28
    49d4:	df 91       	pop	r29
    49d6:	08 95       	ret

000049d8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    49d8:	df 93       	push	r29
    49da:	cf 93       	push	r28
    49dc:	00 d0       	rcall	.+0      	; 0x49de <xQueueIsQueueFullFromISR+0x6>
    49de:	0f 92       	push	r0
    49e0:	cd b7       	in	r28, 0x3d	; 61
    49e2:	de b7       	in	r29, 0x3e	; 62
    49e4:	9b 83       	std	Y+3, r25	; 0x03
    49e6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    49e8:	ea 81       	ldd	r30, Y+2	; 0x02
    49ea:	fb 81       	ldd	r31, Y+3	; 0x03
    49ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    49ee:	ea 81       	ldd	r30, Y+2	; 0x02
    49f0:	fb 81       	ldd	r31, Y+3	; 0x03
    49f2:	83 8d       	ldd	r24, Z+27	; 0x1b
    49f4:	98 17       	cp	r25, r24
    49f6:	19 f4       	brne	.+6      	; 0x49fe <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    49f8:	81 e0       	ldi	r24, 0x01	; 1
    49fa:	89 83       	std	Y+1, r24	; 0x01
    49fc:	01 c0       	rjmp	.+2      	; 0x4a00 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    49fe:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4a00:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4a02:	0f 90       	pop	r0
    4a04:	0f 90       	pop	r0
    4a06:	0f 90       	pop	r0
    4a08:	cf 91       	pop	r28
    4a0a:	df 91       	pop	r29
    4a0c:	08 95       	ret

00004a0e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    4a0e:	df 93       	push	r29
    4a10:	cf 93       	push	r28
    4a12:	cd b7       	in	r28, 0x3d	; 61
    4a14:	de b7       	in	r29, 0x3e	; 62
    4a16:	2a 97       	sbiw	r28, 0x0a	; 10
    4a18:	0f b6       	in	r0, 0x3f	; 63
    4a1a:	f8 94       	cli
    4a1c:	de bf       	out	0x3e, r29	; 62
    4a1e:	0f be       	out	0x3f, r0	; 63
    4a20:	cd bf       	out	0x3d, r28	; 61
    4a22:	9d 83       	std	Y+5, r25	; 0x05
    4a24:	8c 83       	std	Y+4, r24	; 0x04
    4a26:	7f 83       	std	Y+7, r23	; 0x07
    4a28:	6e 83       	std	Y+6, r22	; 0x06
    4a2a:	59 87       	std	Y+9, r21	; 0x09
    4a2c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4a2e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a30:	9d 81       	ldd	r25, Y+5	; 0x05
    4a32:	9a 83       	std	Y+2, r25	; 0x02
    4a34:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    4a36:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4a38:	89 81       	ldd	r24, Y+1	; 0x01
    4a3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a3c:	0e 94 cc 24 	call	0x4998	; 0x4998 <prvIsQueueFull>
    4a40:	88 23       	and	r24, r24
    4a42:	a9 f0       	breq	.+42     	; 0x4a6e <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    4a44:	88 85       	ldd	r24, Y+8	; 0x08
    4a46:	99 85       	ldd	r25, Y+9	; 0x09
    4a48:	00 97       	sbiw	r24, 0x00	; 0
    4a4a:	71 f0       	breq	.+28     	; 0x4a68 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    4a4c:	89 81       	ldd	r24, Y+1	; 0x01
    4a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a50:	9c 01       	movw	r18, r24
    4a52:	28 5f       	subi	r18, 0xF8	; 248
    4a54:	3f 4f       	sbci	r19, 0xFF	; 255
    4a56:	88 85       	ldd	r24, Y+8	; 0x08
    4a58:	99 85       	ldd	r25, Y+9	; 0x09
    4a5a:	b9 01       	movw	r22, r18
    4a5c:	0e 94 51 13 	call	0x26a2	; 0x26a2 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    4a60:	78 94       	sei
					return errQUEUE_BLOCKED;
    4a62:	8c ef       	ldi	r24, 0xFC	; 252
    4a64:	8a 87       	std	Y+10, r24	; 0x0a
    4a66:	2a c0       	rjmp	.+84     	; 0x4abc <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    4a68:	78 94       	sei
					return errQUEUE_FULL;
    4a6a:	1a 86       	std	Y+10, r1	; 0x0a
    4a6c:	27 c0       	rjmp	.+78     	; 0x4abc <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    4a6e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    4a70:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4a72:	e9 81       	ldd	r30, Y+1	; 0x01
    4a74:	fa 81       	ldd	r31, Y+2	; 0x02
    4a76:	92 8d       	ldd	r25, Z+26	; 0x1a
    4a78:	e9 81       	ldd	r30, Y+1	; 0x01
    4a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    4a7e:	98 17       	cp	r25, r24
    4a80:	c8 f4       	brcc	.+50     	; 0x4ab4 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4a82:	89 81       	ldd	r24, Y+1	; 0x01
    4a84:	9a 81       	ldd	r25, Y+2	; 0x02
    4a86:	2e 81       	ldd	r18, Y+6	; 0x06
    4a88:	3f 81       	ldd	r19, Y+7	; 0x07
    4a8a:	b9 01       	movw	r22, r18
    4a8c:	40 e0       	ldi	r20, 0x00	; 0
    4a8e:	0e 94 43 23 	call	0x4686	; 0x4686 <prvCopyDataToQueue>
				xReturn = pdPASS;
    4a92:	81 e0       	ldi	r24, 0x01	; 1
    4a94:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4a96:	e9 81       	ldd	r30, Y+1	; 0x01
    4a98:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9a:	81 89       	ldd	r24, Z+17	; 0x11
    4a9c:	88 23       	and	r24, r24
    4a9e:	59 f0       	breq	.+22     	; 0x4ab6 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4aa0:	89 81       	ldd	r24, Y+1	; 0x01
    4aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    4aa4:	41 96       	adiw	r24, 0x11	; 17
    4aa6:	0e 94 5d 15 	call	0x2aba	; 0x2aba <xCoRoutineRemoveFromEventList>
    4aaa:	88 23       	and	r24, r24
    4aac:	21 f0       	breq	.+8      	; 0x4ab6 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    4aae:	8b ef       	ldi	r24, 0xFB	; 251
    4ab0:	8b 83       	std	Y+3, r24	; 0x03
    4ab2:	01 c0       	rjmp	.+2      	; 0x4ab6 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    4ab4:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4ab6:	78 94       	sei

		return xReturn;
    4ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    4aba:	8a 87       	std	Y+10, r24	; 0x0a
    4abc:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    4abe:	2a 96       	adiw	r28, 0x0a	; 10
    4ac0:	0f b6       	in	r0, 0x3f	; 63
    4ac2:	f8 94       	cli
    4ac4:	de bf       	out	0x3e, r29	; 62
    4ac6:	0f be       	out	0x3f, r0	; 63
    4ac8:	cd bf       	out	0x3d, r28	; 61
    4aca:	cf 91       	pop	r28
    4acc:	df 91       	pop	r29
    4ace:	08 95       	ret

00004ad0 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    4ad0:	df 93       	push	r29
    4ad2:	cf 93       	push	r28
    4ad4:	cd b7       	in	r28, 0x3d	; 61
    4ad6:	de b7       	in	r29, 0x3e	; 62
    4ad8:	2a 97       	sbiw	r28, 0x0a	; 10
    4ada:	0f b6       	in	r0, 0x3f	; 63
    4adc:	f8 94       	cli
    4ade:	de bf       	out	0x3e, r29	; 62
    4ae0:	0f be       	out	0x3f, r0	; 63
    4ae2:	cd bf       	out	0x3d, r28	; 61
    4ae4:	9d 83       	std	Y+5, r25	; 0x05
    4ae6:	8c 83       	std	Y+4, r24	; 0x04
    4ae8:	7f 83       	std	Y+7, r23	; 0x07
    4aea:	6e 83       	std	Y+6, r22	; 0x06
    4aec:	59 87       	std	Y+9, r21	; 0x09
    4aee:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4af0:	8c 81       	ldd	r24, Y+4	; 0x04
    4af2:	9d 81       	ldd	r25, Y+5	; 0x05
    4af4:	9a 83       	std	Y+2, r25	; 0x02
    4af6:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    4af8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4afa:	e9 81       	ldd	r30, Y+1	; 0x01
    4afc:	fa 81       	ldd	r31, Y+2	; 0x02
    4afe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b00:	88 23       	and	r24, r24
    4b02:	a9 f4       	brne	.+42     	; 0x4b2e <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    4b04:	88 85       	ldd	r24, Y+8	; 0x08
    4b06:	99 85       	ldd	r25, Y+9	; 0x09
    4b08:	00 97       	sbiw	r24, 0x00	; 0
    4b0a:	71 f0       	breq	.+28     	; 0x4b28 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    4b0c:	89 81       	ldd	r24, Y+1	; 0x01
    4b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b10:	9c 01       	movw	r18, r24
    4b12:	2f 5e       	subi	r18, 0xEF	; 239
    4b14:	3f 4f       	sbci	r19, 0xFF	; 255
    4b16:	88 85       	ldd	r24, Y+8	; 0x08
    4b18:	99 85       	ldd	r25, Y+9	; 0x09
    4b1a:	b9 01       	movw	r22, r18
    4b1c:	0e 94 51 13 	call	0x26a2	; 0x26a2 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    4b20:	78 94       	sei
					return errQUEUE_BLOCKED;
    4b22:	8c ef       	ldi	r24, 0xFC	; 252
    4b24:	8a 87       	std	Y+10, r24	; 0x0a
    4b26:	58 c0       	rjmp	.+176    	; 0x4bd8 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    4b28:	78 94       	sei
					return errQUEUE_FULL;
    4b2a:	1a 86       	std	Y+10, r1	; 0x0a
    4b2c:	55 c0       	rjmp	.+170    	; 0x4bd8 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    4b2e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    4b30:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4b32:	e9 81       	ldd	r30, Y+1	; 0x01
    4b34:	fa 81       	ldd	r31, Y+2	; 0x02
    4b36:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b38:	88 23       	and	r24, r24
    4b3a:	09 f4       	brne	.+2      	; 0x4b3e <xQueueCRReceive+0x6e>
    4b3c:	49 c0       	rjmp	.+146    	; 0x4bd0 <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b40:	fa 81       	ldd	r31, Y+2	; 0x02
    4b42:	26 81       	ldd	r18, Z+6	; 0x06
    4b44:	37 81       	ldd	r19, Z+7	; 0x07
    4b46:	e9 81       	ldd	r30, Y+1	; 0x01
    4b48:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4a:	84 8d       	ldd	r24, Z+28	; 0x1c
    4b4c:	88 2f       	mov	r24, r24
    4b4e:	90 e0       	ldi	r25, 0x00	; 0
    4b50:	82 0f       	add	r24, r18
    4b52:	93 1f       	adc	r25, r19
    4b54:	e9 81       	ldd	r30, Y+1	; 0x01
    4b56:	fa 81       	ldd	r31, Y+2	; 0x02
    4b58:	97 83       	std	Z+7, r25	; 0x07
    4b5a:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    4b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b60:	26 81       	ldd	r18, Z+6	; 0x06
    4b62:	37 81       	ldd	r19, Z+7	; 0x07
    4b64:	e9 81       	ldd	r30, Y+1	; 0x01
    4b66:	fa 81       	ldd	r31, Y+2	; 0x02
    4b68:	82 81       	ldd	r24, Z+2	; 0x02
    4b6a:	93 81       	ldd	r25, Z+3	; 0x03
    4b6c:	28 17       	cp	r18, r24
    4b6e:	39 07       	cpc	r19, r25
    4b70:	40 f0       	brcs	.+16     	; 0x4b82 <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4b72:	e9 81       	ldd	r30, Y+1	; 0x01
    4b74:	fa 81       	ldd	r31, Y+2	; 0x02
    4b76:	80 81       	ld	r24, Z
    4b78:	91 81       	ldd	r25, Z+1	; 0x01
    4b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b7e:	97 83       	std	Z+7, r25	; 0x07
    4b80:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    4b82:	e9 81       	ldd	r30, Y+1	; 0x01
    4b84:	fa 81       	ldd	r31, Y+2	; 0x02
    4b86:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b88:	81 50       	subi	r24, 0x01	; 1
    4b8a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b8c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b8e:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4b90:	e9 81       	ldd	r30, Y+1	; 0x01
    4b92:	fa 81       	ldd	r31, Y+2	; 0x02
    4b94:	46 81       	ldd	r20, Z+6	; 0x06
    4b96:	57 81       	ldd	r21, Z+7	; 0x07
    4b98:	e9 81       	ldd	r30, Y+1	; 0x01
    4b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    4b9e:	28 2f       	mov	r18, r24
    4ba0:	30 e0       	ldi	r19, 0x00	; 0
    4ba2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ba4:	9f 81       	ldd	r25, Y+7	; 0x07
    4ba6:	ba 01       	movw	r22, r20
    4ba8:	a9 01       	movw	r20, r18
    4baa:	0e 94 01 36 	call	0x6c02	; 0x6c02 <memcpy>

				xReturn = pdPASS;
    4bae:	81 e0       	ldi	r24, 0x01	; 1
    4bb0:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4bb2:	e9 81       	ldd	r30, Y+1	; 0x01
    4bb4:	fa 81       	ldd	r31, Y+2	; 0x02
    4bb6:	80 85       	ldd	r24, Z+8	; 0x08
    4bb8:	88 23       	and	r24, r24
    4bba:	59 f0       	breq	.+22     	; 0x4bd2 <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4bbc:	89 81       	ldd	r24, Y+1	; 0x01
    4bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    4bc0:	08 96       	adiw	r24, 0x08	; 8
    4bc2:	0e 94 5d 15 	call	0x2aba	; 0x2aba <xCoRoutineRemoveFromEventList>
    4bc6:	88 23       	and	r24, r24
    4bc8:	21 f0       	breq	.+8      	; 0x4bd2 <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    4bca:	8b ef       	ldi	r24, 0xFB	; 251
    4bcc:	8b 83       	std	Y+3, r24	; 0x03
    4bce:	01 c0       	rjmp	.+2      	; 0x4bd2 <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    4bd0:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    4bd2:	78 94       	sei

		return xReturn;
    4bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd6:	8a 87       	std	Y+10, r24	; 0x0a
    4bd8:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    4bda:	2a 96       	adiw	r28, 0x0a	; 10
    4bdc:	0f b6       	in	r0, 0x3f	; 63
    4bde:	f8 94       	cli
    4be0:	de bf       	out	0x3e, r29	; 62
    4be2:	0f be       	out	0x3f, r0	; 63
    4be4:	cd bf       	out	0x3d, r28	; 61
    4be6:	cf 91       	pop	r28
    4be8:	df 91       	pop	r29
    4bea:	08 95       	ret

00004bec <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    4bec:	df 93       	push	r29
    4bee:	cf 93       	push	r28
    4bf0:	cd b7       	in	r28, 0x3d	; 61
    4bf2:	de b7       	in	r29, 0x3e	; 62
    4bf4:	28 97       	sbiw	r28, 0x08	; 8
    4bf6:	0f b6       	in	r0, 0x3f	; 63
    4bf8:	f8 94       	cli
    4bfa:	de bf       	out	0x3e, r29	; 62
    4bfc:	0f be       	out	0x3f, r0	; 63
    4bfe:	cd bf       	out	0x3d, r28	; 61
    4c00:	9c 83       	std	Y+4, r25	; 0x04
    4c02:	8b 83       	std	Y+3, r24	; 0x03
    4c04:	7e 83       	std	Y+6, r23	; 0x06
    4c06:	6d 83       	std	Y+5, r22	; 0x05
    4c08:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4c0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4c0e:	9a 83       	std	Y+2, r25	; 0x02
    4c10:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4c12:	e9 81       	ldd	r30, Y+1	; 0x01
    4c14:	fa 81       	ldd	r31, Y+2	; 0x02
    4c16:	92 8d       	ldd	r25, Z+26	; 0x1a
    4c18:	e9 81       	ldd	r30, Y+1	; 0x01
    4c1a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c1c:	83 8d       	ldd	r24, Z+27	; 0x1b
    4c1e:	98 17       	cp	r25, r24
    4c20:	d0 f4       	brcc	.+52     	; 0x4c56 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    4c22:	89 81       	ldd	r24, Y+1	; 0x01
    4c24:	9a 81       	ldd	r25, Y+2	; 0x02
    4c26:	2d 81       	ldd	r18, Y+5	; 0x05
    4c28:	3e 81       	ldd	r19, Y+6	; 0x06
    4c2a:	b9 01       	movw	r22, r18
    4c2c:	40 e0       	ldi	r20, 0x00	; 0
    4c2e:	0e 94 43 23 	call	0x4686	; 0x4686 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    4c32:	8f 81       	ldd	r24, Y+7	; 0x07
    4c34:	88 23       	and	r24, r24
    4c36:	79 f4       	brne	.+30     	; 0x4c56 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4c38:	e9 81       	ldd	r30, Y+1	; 0x01
    4c3a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c3c:	81 89       	ldd	r24, Z+17	; 0x11
    4c3e:	88 23       	and	r24, r24
    4c40:	51 f0       	breq	.+20     	; 0x4c56 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4c42:	89 81       	ldd	r24, Y+1	; 0x01
    4c44:	9a 81       	ldd	r25, Y+2	; 0x02
    4c46:	41 96       	adiw	r24, 0x11	; 17
    4c48:	0e 94 5d 15 	call	0x2aba	; 0x2aba <xCoRoutineRemoveFromEventList>
    4c4c:	88 23       	and	r24, r24
    4c4e:	19 f0       	breq	.+6      	; 0x4c56 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    4c50:	81 e0       	ldi	r24, 0x01	; 1
    4c52:	88 87       	std	Y+8, r24	; 0x08
    4c54:	02 c0       	rjmp	.+4      	; 0x4c5a <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    4c56:	8f 81       	ldd	r24, Y+7	; 0x07
    4c58:	88 87       	std	Y+8, r24	; 0x08
    4c5a:	88 85       	ldd	r24, Y+8	; 0x08
	}
    4c5c:	28 96       	adiw	r28, 0x08	; 8
    4c5e:	0f b6       	in	r0, 0x3f	; 63
    4c60:	f8 94       	cli
    4c62:	de bf       	out	0x3e, r29	; 62
    4c64:	0f be       	out	0x3f, r0	; 63
    4c66:	cd bf       	out	0x3d, r28	; 61
    4c68:	cf 91       	pop	r28
    4c6a:	df 91       	pop	r29
    4c6c:	08 95       	ret

00004c6e <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    4c6e:	df 93       	push	r29
    4c70:	cf 93       	push	r28
    4c72:	cd b7       	in	r28, 0x3d	; 61
    4c74:	de b7       	in	r29, 0x3e	; 62
    4c76:	29 97       	sbiw	r28, 0x09	; 9
    4c78:	0f b6       	in	r0, 0x3f	; 63
    4c7a:	f8 94       	cli
    4c7c:	de bf       	out	0x3e, r29	; 62
    4c7e:	0f be       	out	0x3f, r0	; 63
    4c80:	cd bf       	out	0x3d, r28	; 61
    4c82:	9d 83       	std	Y+5, r25	; 0x05
    4c84:	8c 83       	std	Y+4, r24	; 0x04
    4c86:	7f 83       	std	Y+7, r23	; 0x07
    4c88:	6e 83       	std	Y+6, r22	; 0x06
    4c8a:	59 87       	std	Y+9, r21	; 0x09
    4c8c:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    4c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    4c90:	9d 81       	ldd	r25, Y+5	; 0x05
    4c92:	9a 83       	std	Y+2, r25	; 0x02
    4c94:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4c96:	e9 81       	ldd	r30, Y+1	; 0x01
    4c98:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4c9c:	88 23       	and	r24, r24
    4c9e:	09 f4       	brne	.+2      	; 0x4ca2 <xQueueCRReceiveFromISR+0x34>
    4ca0:	50 c0       	rjmp	.+160    	; 0x4d42 <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca6:	26 81       	ldd	r18, Z+6	; 0x06
    4ca8:	37 81       	ldd	r19, Z+7	; 0x07
    4caa:	e9 81       	ldd	r30, Y+1	; 0x01
    4cac:	fa 81       	ldd	r31, Y+2	; 0x02
    4cae:	84 8d       	ldd	r24, Z+28	; 0x1c
    4cb0:	88 2f       	mov	r24, r24
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	82 0f       	add	r24, r18
    4cb6:	93 1f       	adc	r25, r19
    4cb8:	e9 81       	ldd	r30, Y+1	; 0x01
    4cba:	fa 81       	ldd	r31, Y+2	; 0x02
    4cbc:	97 83       	std	Z+7, r25	; 0x07
    4cbe:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    4cc0:	e9 81       	ldd	r30, Y+1	; 0x01
    4cc2:	fa 81       	ldd	r31, Y+2	; 0x02
    4cc4:	26 81       	ldd	r18, Z+6	; 0x06
    4cc6:	37 81       	ldd	r19, Z+7	; 0x07
    4cc8:	e9 81       	ldd	r30, Y+1	; 0x01
    4cca:	fa 81       	ldd	r31, Y+2	; 0x02
    4ccc:	82 81       	ldd	r24, Z+2	; 0x02
    4cce:	93 81       	ldd	r25, Z+3	; 0x03
    4cd0:	28 17       	cp	r18, r24
    4cd2:	39 07       	cpc	r19, r25
    4cd4:	40 f0       	brcs	.+16     	; 0x4ce6 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cda:	80 81       	ld	r24, Z
    4cdc:	91 81       	ldd	r25, Z+1	; 0x01
    4cde:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ce2:	97 83       	std	Z+7, r25	; 0x07
    4ce4:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    4ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cea:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cec:	81 50       	subi	r24, 0x01	; 1
    4cee:	e9 81       	ldd	r30, Y+1	; 0x01
    4cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    4cf2:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    4cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    4cf8:	46 81       	ldd	r20, Z+6	; 0x06
    4cfa:	57 81       	ldd	r21, Z+7	; 0x07
    4cfc:	e9 81       	ldd	r30, Y+1	; 0x01
    4cfe:	fa 81       	ldd	r31, Y+2	; 0x02
    4d00:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d02:	28 2f       	mov	r18, r24
    4d04:	30 e0       	ldi	r19, 0x00	; 0
    4d06:	8e 81       	ldd	r24, Y+6	; 0x06
    4d08:	9f 81       	ldd	r25, Y+7	; 0x07
    4d0a:	ba 01       	movw	r22, r20
    4d0c:	a9 01       	movw	r20, r18
    4d0e:	0e 94 01 36 	call	0x6c02	; 0x6c02 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    4d12:	e8 85       	ldd	r30, Y+8	; 0x08
    4d14:	f9 85       	ldd	r31, Y+9	; 0x09
    4d16:	80 81       	ld	r24, Z
    4d18:	88 23       	and	r24, r24
    4d1a:	81 f4       	brne	.+32     	; 0x4d3c <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d20:	80 85       	ldd	r24, Z+8	; 0x08
    4d22:	88 23       	and	r24, r24
    4d24:	59 f0       	breq	.+22     	; 0x4d3c <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4d26:	89 81       	ldd	r24, Y+1	; 0x01
    4d28:	9a 81       	ldd	r25, Y+2	; 0x02
    4d2a:	08 96       	adiw	r24, 0x08	; 8
    4d2c:	0e 94 5d 15 	call	0x2aba	; 0x2aba <xCoRoutineRemoveFromEventList>
    4d30:	88 23       	and	r24, r24
    4d32:	21 f0       	breq	.+8      	; 0x4d3c <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    4d34:	e8 85       	ldd	r30, Y+8	; 0x08
    4d36:	f9 85       	ldd	r31, Y+9	; 0x09
    4d38:	81 e0       	ldi	r24, 0x01	; 1
    4d3a:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    4d3c:	81 e0       	ldi	r24, 0x01	; 1
    4d3e:	8b 83       	std	Y+3, r24	; 0x03
    4d40:	01 c0       	rjmp	.+2      	; 0x4d44 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    4d42:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    4d44:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4d46:	29 96       	adiw	r28, 0x09	; 9
    4d48:	0f b6       	in	r0, 0x3f	; 63
    4d4a:	f8 94       	cli
    4d4c:	de bf       	out	0x3e, r29	; 62
    4d4e:	0f be       	out	0x3f, r0	; 63
    4d50:	cd bf       	out	0x3d, r28	; 61
    4d52:	cf 91       	pop	r28
    4d54:	df 91       	pop	r29
    4d56:	08 95       	ret

00004d58 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4d58:	af 92       	push	r10
    4d5a:	bf 92       	push	r11
    4d5c:	cf 92       	push	r12
    4d5e:	df 92       	push	r13
    4d60:	ef 92       	push	r14
    4d62:	ff 92       	push	r15
    4d64:	0f 93       	push	r16
    4d66:	1f 93       	push	r17
    4d68:	df 93       	push	r29
    4d6a:	cf 93       	push	r28
    4d6c:	cd b7       	in	r28, 0x3d	; 61
    4d6e:	de b7       	in	r29, 0x3e	; 62
    4d70:	64 97       	sbiw	r28, 0x14	; 20
    4d72:	0f b6       	in	r0, 0x3f	; 63
    4d74:	f8 94       	cli
    4d76:	de bf       	out	0x3e, r29	; 62
    4d78:	0f be       	out	0x3f, r0	; 63
    4d7a:	cd bf       	out	0x3d, r28	; 61
    4d7c:	9f 83       	std	Y+7, r25	; 0x07
    4d7e:	8e 83       	std	Y+6, r24	; 0x06
    4d80:	79 87       	std	Y+9, r23	; 0x09
    4d82:	68 87       	std	Y+8, r22	; 0x08
    4d84:	5b 87       	std	Y+11, r21	; 0x0b
    4d86:	4a 87       	std	Y+10, r20	; 0x0a
    4d88:	3d 87       	std	Y+13, r19	; 0x0d
    4d8a:	2c 87       	std	Y+12, r18	; 0x0c
    4d8c:	0e 87       	std	Y+14, r16	; 0x0e
    4d8e:	f8 8a       	std	Y+16, r15	; 0x10
    4d90:	ef 86       	std	Y+15, r14	; 0x0f
    4d92:	da 8a       	std	Y+18, r13	; 0x12
    4d94:	c9 8a       	std	Y+17, r12	; 0x11
    4d96:	bc 8a       	std	Y+20, r11	; 0x14
    4d98:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4d9a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d9c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d9e:	29 89       	ldd	r18, Y+17	; 0x11
    4da0:	3a 89       	ldd	r19, Y+18	; 0x12
    4da2:	b9 01       	movw	r22, r18
    4da4:	0e 94 d3 31 	call	0x63a6	; 0x63a6 <prvAllocateTCBAndStack>
    4da8:	9c 83       	std	Y+4, r25	; 0x04
    4daa:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4dac:	8b 81       	ldd	r24, Y+3	; 0x03
    4dae:	9c 81       	ldd	r25, Y+4	; 0x04
    4db0:	00 97       	sbiw	r24, 0x00	; 0
    4db2:	09 f4       	brne	.+2      	; 0x4db6 <xTaskGenericCreate+0x5e>
    4db4:	92 c0       	rjmp	.+292    	; 0x4eda <xTaskGenericCreate+0x182>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    4db6:	eb 81       	ldd	r30, Y+3	; 0x03
    4db8:	fc 81       	ldd	r31, Y+4	; 0x04
    4dba:	27 89       	ldd	r18, Z+23	; 0x17
    4dbc:	30 8d       	ldd	r19, Z+24	; 0x18
    4dbe:	8a 85       	ldd	r24, Y+10	; 0x0a
    4dc0:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dc2:	01 97       	sbiw	r24, 0x01	; 1
    4dc4:	82 0f       	add	r24, r18
    4dc6:	93 1f       	adc	r25, r19
    4dc8:	9a 83       	std	Y+2, r25	; 0x02
    4dca:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    4dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    4dce:	9c 81       	ldd	r25, Y+4	; 0x04
    4dd0:	28 85       	ldd	r18, Y+8	; 0x08
    4dd2:	39 85       	ldd	r19, Y+9	; 0x09
    4dd4:	eb 89       	ldd	r30, Y+19	; 0x13
    4dd6:	fc 89       	ldd	r31, Y+20	; 0x14
    4dd8:	aa 85       	ldd	r26, Y+10	; 0x0a
    4dda:	bb 85       	ldd	r27, Y+11	; 0x0b
    4ddc:	b9 01       	movw	r22, r18
    4dde:	4e 85       	ldd	r20, Y+14	; 0x0e
    4de0:	9f 01       	movw	r18, r30
    4de2:	8d 01       	movw	r16, r26
    4de4:	0e 94 90 30 	call	0x6120	; 0x6120 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4de8:	89 81       	ldd	r24, Y+1	; 0x01
    4dea:	9a 81       	ldd	r25, Y+2	; 0x02
    4dec:	2e 81       	ldd	r18, Y+6	; 0x06
    4dee:	3f 81       	ldd	r19, Y+7	; 0x07
    4df0:	4c 85       	ldd	r20, Y+12	; 0x0c
    4df2:	5d 85       	ldd	r21, Y+13	; 0x0d
    4df4:	b9 01       	movw	r22, r18
    4df6:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <pxPortInitialiseStack>
    4dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    4dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    4dfe:	91 83       	std	Z+1, r25	; 0x01
    4e00:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    4e02:	8f 85       	ldd	r24, Y+15	; 0x0f
    4e04:	98 89       	ldd	r25, Y+16	; 0x10
    4e06:	00 97       	sbiw	r24, 0x00	; 0
    4e08:	31 f0       	breq	.+12     	; 0x4e16 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4e0a:	ef 85       	ldd	r30, Y+15	; 0x0f
    4e0c:	f8 89       	ldd	r31, Y+16	; 0x10
    4e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e10:	9c 81       	ldd	r25, Y+4	; 0x04
    4e12:	91 83       	std	Z+1, r25	; 0x01
    4e14:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    4e16:	0f b6       	in	r0, 0x3f	; 63
    4e18:	f8 94       	cli
    4e1a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4e1c:	80 91 ef 06 	lds	r24, 0x06EF
    4e20:	8f 5f       	subi	r24, 0xFF	; 255
    4e22:	80 93 ef 06 	sts	0x06EF, r24
			if( pxCurrentTCB == NULL )
    4e26:	80 91 ec 06 	lds	r24, 0x06EC
    4e2a:	90 91 ed 06 	lds	r25, 0x06ED
    4e2e:	00 97       	sbiw	r24, 0x00	; 0
    4e30:	69 f4       	brne	.+26     	; 0x4e4c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4e32:	8b 81       	ldd	r24, Y+3	; 0x03
    4e34:	9c 81       	ldd	r25, Y+4	; 0x04
    4e36:	90 93 ed 06 	sts	0x06ED, r25
    4e3a:	80 93 ec 06 	sts	0x06EC, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4e3e:	80 91 ef 06 	lds	r24, 0x06EF
    4e42:	81 30       	cpi	r24, 0x01	; 1
    4e44:	a9 f4       	brne	.+42     	; 0x4e70 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4e46:	0e 94 0a 31 	call	0x6214	; 0x6214 <prvInitialiseTaskLists>
    4e4a:	12 c0       	rjmp	.+36     	; 0x4e70 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4e4c:	80 91 f3 06 	lds	r24, 0x06F3
    4e50:	88 23       	and	r24, r24
    4e52:	71 f4       	brne	.+28     	; 0x4e70 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4e54:	e0 91 ec 06 	lds	r30, 0x06EC
    4e58:	f0 91 ed 06 	lds	r31, 0x06ED
    4e5c:	96 89       	ldd	r25, Z+22	; 0x16
    4e5e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e60:	89 17       	cp	r24, r25
    4e62:	30 f0       	brcs	.+12     	; 0x4e70 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4e64:	8b 81       	ldd	r24, Y+3	; 0x03
    4e66:	9c 81       	ldd	r25, Y+4	; 0x04
    4e68:	90 93 ed 06 	sts	0x06ED, r25
    4e6c:	80 93 ec 06 	sts	0x06EC, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    4e70:	80 91 f7 06 	lds	r24, 0x06F7
    4e74:	8f 5f       	subi	r24, 0xFF	; 255
    4e76:	80 93 f7 06 	sts	0x06F7, r24

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    4e7a:	80 91 f7 06 	lds	r24, 0x06F7
    4e7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e80:	fc 81       	ldd	r31, Y+4	; 0x04
    4e82:	85 a7       	std	Z+45, r24	; 0x2d
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    4e84:	eb 81       	ldd	r30, Y+3	; 0x03
    4e86:	fc 81       	ldd	r31, Y+4	; 0x04
    4e88:	96 89       	ldd	r25, Z+22	; 0x16
    4e8a:	80 91 f2 06 	lds	r24, 0x06F2
    4e8e:	89 17       	cp	r24, r25
    4e90:	28 f4       	brcc	.+10     	; 0x4e9c <xTaskGenericCreate+0x144>
    4e92:	eb 81       	ldd	r30, Y+3	; 0x03
    4e94:	fc 81       	ldd	r31, Y+4	; 0x04
    4e96:	86 89       	ldd	r24, Z+22	; 0x16
    4e98:	80 93 f2 06 	sts	0x06F2, r24
    4e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea0:	86 89       	ldd	r24, Z+22	; 0x16
    4ea2:	28 2f       	mov	r18, r24
    4ea4:	30 e0       	ldi	r19, 0x00	; 0
    4ea6:	c9 01       	movw	r24, r18
    4ea8:	88 0f       	add	r24, r24
    4eaa:	99 1f       	adc	r25, r25
    4eac:	88 0f       	add	r24, r24
    4eae:	99 1f       	adc	r25, r25
    4eb0:	88 0f       	add	r24, r24
    4eb2:	99 1f       	adc	r25, r25
    4eb4:	82 0f       	add	r24, r18
    4eb6:	93 1f       	adc	r25, r19
    4eb8:	ac 01       	movw	r20, r24
    4eba:	47 50       	subi	r20, 0x07	; 7
    4ebc:	59 4f       	sbci	r21, 0xF9	; 249
    4ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec2:	9c 01       	movw	r18, r24
    4ec4:	2e 5f       	subi	r18, 0xFE	; 254
    4ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ec8:	ca 01       	movw	r24, r20
    4eca:	b9 01       	movw	r22, r18
    4ecc:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

			xReturn = pdPASS;
    4ed0:	81 e0       	ldi	r24, 0x01	; 1
    4ed2:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4ed4:	0f 90       	pop	r0
    4ed6:	0f be       	out	0x3f, r0	; 63
    4ed8:	02 c0       	rjmp	.+4      	; 0x4ede <xTaskGenericCreate+0x186>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4eda:	8f ef       	ldi	r24, 0xFF	; 255
    4edc:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4ede:	8d 81       	ldd	r24, Y+5	; 0x05
    4ee0:	81 30       	cpi	r24, 0x01	; 1
    4ee2:	71 f4       	brne	.+28     	; 0x4f00 <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    4ee4:	80 91 f3 06 	lds	r24, 0x06F3
    4ee8:	88 23       	and	r24, r24
    4eea:	51 f0       	breq	.+20     	; 0x4f00 <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4eec:	e0 91 ec 06 	lds	r30, 0x06EC
    4ef0:	f0 91 ed 06 	lds	r31, 0x06ED
    4ef4:	96 89       	ldd	r25, Z+22	; 0x16
    4ef6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ef8:	98 17       	cp	r25, r24
    4efa:	10 f4       	brcc	.+4      	; 0x4f00 <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    4efc:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    4f00:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4f02:	64 96       	adiw	r28, 0x14	; 20
    4f04:	0f b6       	in	r0, 0x3f	; 63
    4f06:	f8 94       	cli
    4f08:	de bf       	out	0x3e, r29	; 62
    4f0a:	0f be       	out	0x3f, r0	; 63
    4f0c:	cd bf       	out	0x3d, r28	; 61
    4f0e:	cf 91       	pop	r28
    4f10:	df 91       	pop	r29
    4f12:	1f 91       	pop	r17
    4f14:	0f 91       	pop	r16
    4f16:	ff 90       	pop	r15
    4f18:	ef 90       	pop	r14
    4f1a:	df 90       	pop	r13
    4f1c:	cf 90       	pop	r12
    4f1e:	bf 90       	pop	r11
    4f20:	af 90       	pop	r10
    4f22:	08 95       	ret

00004f24 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4f24:	df 93       	push	r29
    4f26:	cf 93       	push	r28
    4f28:	00 d0       	rcall	.+0      	; 0x4f2a <vTaskDelete+0x6>
    4f2a:	00 d0       	rcall	.+0      	; 0x4f2c <vTaskDelete+0x8>
    4f2c:	00 d0       	rcall	.+0      	; 0x4f2e <vTaskDelete+0xa>
    4f2e:	cd b7       	in	r28, 0x3d	; 61
    4f30:	de b7       	in	r29, 0x3e	; 62
    4f32:	9c 83       	std	Y+4, r25	; 0x04
    4f34:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4f36:	0f b6       	in	r0, 0x3f	; 63
    4f38:	f8 94       	cli
    4f3a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f40:	00 97       	sbiw	r24, 0x00	; 0
    4f42:	39 f4       	brne	.+14     	; 0x4f52 <vTaskDelete+0x2e>
    4f44:	80 91 ec 06 	lds	r24, 0x06EC
    4f48:	90 91 ed 06 	lds	r25, 0x06ED
    4f4c:	9e 83       	std	Y+6, r25	; 0x06
    4f4e:	8d 83       	std	Y+5, r24	; 0x05
    4f50:	04 c0       	rjmp	.+8      	; 0x4f5a <vTaskDelete+0x36>
    4f52:	8b 81       	ldd	r24, Y+3	; 0x03
    4f54:	9c 81       	ldd	r25, Y+4	; 0x04
    4f56:	9e 83       	std	Y+6, r25	; 0x06
    4f58:	8d 83       	std	Y+5, r24	; 0x05
    4f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4f5e:	9a 83       	std	Y+2, r25	; 0x02
    4f60:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4f62:	89 81       	ldd	r24, Y+1	; 0x01
    4f64:	9a 81       	ldd	r25, Y+2	; 0x02
    4f66:	02 96       	adiw	r24, 0x02	; 2
    4f68:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f70:	84 89       	ldd	r24, Z+20	; 0x14
    4f72:	95 89       	ldd	r25, Z+21	; 0x15
    4f74:	00 97       	sbiw	r24, 0x00	; 0
    4f76:	29 f0       	breq	.+10     	; 0x4f82 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4f78:	89 81       	ldd	r24, Y+1	; 0x01
    4f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f7c:	0c 96       	adiw	r24, 0x0c	; 12
    4f7e:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4f82:	89 81       	ldd	r24, Y+1	; 0x01
    4f84:	9a 81       	ldd	r25, Y+2	; 0x02
    4f86:	9c 01       	movw	r18, r24
    4f88:	2e 5f       	subi	r18, 0xFE	; 254
    4f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4f8c:	8e e4       	ldi	r24, 0x4E	; 78
    4f8e:	97 e0       	ldi	r25, 0x07	; 7
    4f90:	b9 01       	movw	r22, r18
    4f92:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4f96:	80 91 ee 06 	lds	r24, 0x06EE
    4f9a:	8f 5f       	subi	r24, 0xFF	; 255
    4f9c:	80 93 ee 06 	sts	0x06EE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4fa0:	80 91 f7 06 	lds	r24, 0x06F7
    4fa4:	8f 5f       	subi	r24, 0xFF	; 255
    4fa6:	80 93 f7 06 	sts	0x06F7, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4faa:	0f 90       	pop	r0
    4fac:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4fae:	80 91 f3 06 	lds	r24, 0x06F3
    4fb2:	88 23       	and	r24, r24
    4fb4:	99 f0       	breq	.+38     	; 0x4fdc <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    4fb6:	20 91 ec 06 	lds	r18, 0x06EC
    4fba:	30 91 ed 06 	lds	r19, 0x06ED
    4fbe:	89 81       	ldd	r24, Y+1	; 0x01
    4fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fc2:	82 17       	cp	r24, r18
    4fc4:	93 07       	cpc	r25, r19
    4fc6:	19 f4       	brne	.+6      	; 0x4fce <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    4fc8:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    4fcc:	07 c0       	rjmp	.+14     	; 0x4fdc <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    4fce:	0f b6       	in	r0, 0x3f	; 63
    4fd0:	f8 94       	cli
    4fd2:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    4fd4:	0e 94 e9 33 	call	0x67d2	; 0x67d2 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    4fd8:	0f 90       	pop	r0
    4fda:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    4fdc:	26 96       	adiw	r28, 0x06	; 6
    4fde:	0f b6       	in	r0, 0x3f	; 63
    4fe0:	f8 94       	cli
    4fe2:	de bf       	out	0x3e, r29	; 62
    4fe4:	0f be       	out	0x3f, r0	; 63
    4fe6:	cd bf       	out	0x3d, r28	; 61
    4fe8:	cf 91       	pop	r28
    4fea:	df 91       	pop	r29
    4fec:	08 95       	ret

00004fee <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4fee:	df 93       	push	r29
    4ff0:	cf 93       	push	r28
    4ff2:	cd b7       	in	r28, 0x3d	; 61
    4ff4:	de b7       	in	r29, 0x3e	; 62
    4ff6:	2a 97       	sbiw	r28, 0x0a	; 10
    4ff8:	0f b6       	in	r0, 0x3f	; 63
    4ffa:	f8 94       	cli
    4ffc:	de bf       	out	0x3e, r29	; 62
    4ffe:	0f be       	out	0x3f, r0	; 63
    5000:	cd bf       	out	0x3d, r28	; 61
    5002:	98 87       	std	Y+8, r25	; 0x08
    5004:	8f 83       	std	Y+7, r24	; 0x07
    5006:	7a 87       	std	Y+10, r23	; 0x0a
    5008:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    500a:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    500c:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    5010:	80 91 f0 06 	lds	r24, 0x06F0
    5014:	90 91 f1 06 	lds	r25, 0x06F1
    5018:	9a 83       	std	Y+2, r25	; 0x02
    501a:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    501c:	ef 81       	ldd	r30, Y+7	; 0x07
    501e:	f8 85       	ldd	r31, Y+8	; 0x08
    5020:	20 81       	ld	r18, Z
    5022:	31 81       	ldd	r19, Z+1	; 0x01
    5024:	89 85       	ldd	r24, Y+9	; 0x09
    5026:	9a 85       	ldd	r25, Y+10	; 0x0a
    5028:	82 0f       	add	r24, r18
    502a:	93 1f       	adc	r25, r19
    502c:	9e 83       	std	Y+6, r25	; 0x06
    502e:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    5030:	ef 81       	ldd	r30, Y+7	; 0x07
    5032:	f8 85       	ldd	r31, Y+8	; 0x08
    5034:	20 81       	ld	r18, Z
    5036:	31 81       	ldd	r19, Z+1	; 0x01
    5038:	89 81       	ldd	r24, Y+1	; 0x01
    503a:	9a 81       	ldd	r25, Y+2	; 0x02
    503c:	82 17       	cp	r24, r18
    503e:	93 07       	cpc	r25, r19
    5040:	98 f4       	brcc	.+38     	; 0x5068 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    5042:	ef 81       	ldd	r30, Y+7	; 0x07
    5044:	f8 85       	ldd	r31, Y+8	; 0x08
    5046:	20 81       	ld	r18, Z
    5048:	31 81       	ldd	r19, Z+1	; 0x01
    504a:	8d 81       	ldd	r24, Y+5	; 0x05
    504c:	9e 81       	ldd	r25, Y+6	; 0x06
    504e:	82 17       	cp	r24, r18
    5050:	93 07       	cpc	r25, r19
    5052:	e0 f4       	brcc	.+56     	; 0x508c <vTaskDelayUntil+0x9e>
    5054:	2d 81       	ldd	r18, Y+5	; 0x05
    5056:	3e 81       	ldd	r19, Y+6	; 0x06
    5058:	89 81       	ldd	r24, Y+1	; 0x01
    505a:	9a 81       	ldd	r25, Y+2	; 0x02
    505c:	82 17       	cp	r24, r18
    505e:	93 07       	cpc	r25, r19
    5060:	a8 f4       	brcc	.+42     	; 0x508c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5062:	81 e0       	ldi	r24, 0x01	; 1
    5064:	8b 83       	std	Y+3, r24	; 0x03
    5066:	12 c0       	rjmp	.+36     	; 0x508c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5068:	ef 81       	ldd	r30, Y+7	; 0x07
    506a:	f8 85       	ldd	r31, Y+8	; 0x08
    506c:	20 81       	ld	r18, Z
    506e:	31 81       	ldd	r19, Z+1	; 0x01
    5070:	8d 81       	ldd	r24, Y+5	; 0x05
    5072:	9e 81       	ldd	r25, Y+6	; 0x06
    5074:	82 17       	cp	r24, r18
    5076:	93 07       	cpc	r25, r19
    5078:	38 f0       	brcs	.+14     	; 0x5088 <vTaskDelayUntil+0x9a>
    507a:	2d 81       	ldd	r18, Y+5	; 0x05
    507c:	3e 81       	ldd	r19, Y+6	; 0x06
    507e:	89 81       	ldd	r24, Y+1	; 0x01
    5080:	9a 81       	ldd	r25, Y+2	; 0x02
    5082:	82 17       	cp	r24, r18
    5084:	93 07       	cpc	r25, r19
    5086:	10 f4       	brcc	.+4      	; 0x508c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5088:	81 e0       	ldi	r24, 0x01	; 1
    508a:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    508c:	ef 81       	ldd	r30, Y+7	; 0x07
    508e:	f8 85       	ldd	r31, Y+8	; 0x08
    5090:	8d 81       	ldd	r24, Y+5	; 0x05
    5092:	9e 81       	ldd	r25, Y+6	; 0x06
    5094:	91 83       	std	Z+1, r25	; 0x01
    5096:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5098:	8b 81       	ldd	r24, Y+3	; 0x03
    509a:	88 23       	and	r24, r24
    509c:	59 f0       	breq	.+22     	; 0x50b4 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    509e:	80 91 ec 06 	lds	r24, 0x06EC
    50a2:	90 91 ed 06 	lds	r25, 0x06ED
    50a6:	02 96       	adiw	r24, 0x02	; 2
    50a8:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    50ac:	8d 81       	ldd	r24, Y+5	; 0x05
    50ae:	9e 81       	ldd	r25, Y+6	; 0x06
    50b0:	0e 94 8a 31 	call	0x6314	; 0x6314 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    50b4:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    50b8:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    50ba:	8c 81       	ldd	r24, Y+4	; 0x04
    50bc:	88 23       	and	r24, r24
    50be:	11 f4       	brne	.+4      	; 0x50c4 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    50c0:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    50c4:	2a 96       	adiw	r28, 0x0a	; 10
    50c6:	0f b6       	in	r0, 0x3f	; 63
    50c8:	f8 94       	cli
    50ca:	de bf       	out	0x3e, r29	; 62
    50cc:	0f be       	out	0x3f, r0	; 63
    50ce:	cd bf       	out	0x3d, r28	; 61
    50d0:	cf 91       	pop	r28
    50d2:	df 91       	pop	r29
    50d4:	08 95       	ret

000050d6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    50d6:	df 93       	push	r29
    50d8:	cf 93       	push	r28
    50da:	00 d0       	rcall	.+0      	; 0x50dc <vTaskDelay+0x6>
    50dc:	00 d0       	rcall	.+0      	; 0x50de <vTaskDelay+0x8>
    50de:	0f 92       	push	r0
    50e0:	cd b7       	in	r28, 0x3d	; 61
    50e2:	de b7       	in	r29, 0x3e	; 62
    50e4:	9d 83       	std	Y+5, r25	; 0x05
    50e6:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    50e8:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    50ea:	8c 81       	ldd	r24, Y+4	; 0x04
    50ec:	9d 81       	ldd	r25, Y+5	; 0x05
    50ee:	00 97       	sbiw	r24, 0x00	; 0
    50f0:	d1 f0       	breq	.+52     	; 0x5126 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    50f2:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    50f6:	20 91 f0 06 	lds	r18, 0x06F0
    50fa:	30 91 f1 06 	lds	r19, 0x06F1
    50fe:	8c 81       	ldd	r24, Y+4	; 0x04
    5100:	9d 81       	ldd	r25, Y+5	; 0x05
    5102:	82 0f       	add	r24, r18
    5104:	93 1f       	adc	r25, r19
    5106:	9b 83       	std	Y+3, r25	; 0x03
    5108:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    510a:	80 91 ec 06 	lds	r24, 0x06EC
    510e:	90 91 ed 06 	lds	r25, 0x06ED
    5112:	02 96       	adiw	r24, 0x02	; 2
    5114:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    5118:	8a 81       	ldd	r24, Y+2	; 0x02
    511a:	9b 81       	ldd	r25, Y+3	; 0x03
    511c:	0e 94 8a 31 	call	0x6314	; 0x6314 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5120:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>
    5124:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5126:	89 81       	ldd	r24, Y+1	; 0x01
    5128:	88 23       	and	r24, r24
    512a:	11 f4       	brne	.+4      	; 0x5130 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    512c:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5130:	0f 90       	pop	r0
    5132:	0f 90       	pop	r0
    5134:	0f 90       	pop	r0
    5136:	0f 90       	pop	r0
    5138:	0f 90       	pop	r0
    513a:	cf 91       	pop	r28
    513c:	df 91       	pop	r29
    513e:	08 95       	ret

00005140 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    5140:	df 93       	push	r29
    5142:	cf 93       	push	r28
    5144:	cd b7       	in	r28, 0x3d	; 61
    5146:	de b7       	in	r29, 0x3e	; 62
    5148:	27 97       	sbiw	r28, 0x07	; 7
    514a:	0f b6       	in	r0, 0x3f	; 63
    514c:	f8 94       	cli
    514e:	de bf       	out	0x3e, r29	; 62
    5150:	0f be       	out	0x3f, r0	; 63
    5152:	cd bf       	out	0x3d, r28	; 61
    5154:	9d 83       	std	Y+5, r25	; 0x05
    5156:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    5158:	0f b6       	in	r0, 0x3f	; 63
    515a:	f8 94       	cli
    515c:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    515e:	8c 81       	ldd	r24, Y+4	; 0x04
    5160:	9d 81       	ldd	r25, Y+5	; 0x05
    5162:	00 97       	sbiw	r24, 0x00	; 0
    5164:	39 f4       	brne	.+14     	; 0x5174 <uxTaskPriorityGet+0x34>
    5166:	80 91 ec 06 	lds	r24, 0x06EC
    516a:	90 91 ed 06 	lds	r25, 0x06ED
    516e:	9f 83       	std	Y+7, r25	; 0x07
    5170:	8e 83       	std	Y+6, r24	; 0x06
    5172:	04 c0       	rjmp	.+8      	; 0x517c <uxTaskPriorityGet+0x3c>
    5174:	8c 81       	ldd	r24, Y+4	; 0x04
    5176:	9d 81       	ldd	r25, Y+5	; 0x05
    5178:	9f 83       	std	Y+7, r25	; 0x07
    517a:	8e 83       	std	Y+6, r24	; 0x06
    517c:	8e 81       	ldd	r24, Y+6	; 0x06
    517e:	9f 81       	ldd	r25, Y+7	; 0x07
    5180:	9b 83       	std	Y+3, r25	; 0x03
    5182:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    5184:	ea 81       	ldd	r30, Y+2	; 0x02
    5186:	fb 81       	ldd	r31, Y+3	; 0x03
    5188:	86 89       	ldd	r24, Z+22	; 0x16
    518a:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    518c:	0f 90       	pop	r0
    518e:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    5190:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5192:	27 96       	adiw	r28, 0x07	; 7
    5194:	0f b6       	in	r0, 0x3f	; 63
    5196:	f8 94       	cli
    5198:	de bf       	out	0x3e, r29	; 62
    519a:	0f be       	out	0x3f, r0	; 63
    519c:	cd bf       	out	0x3d, r28	; 61
    519e:	cf 91       	pop	r28
    51a0:	df 91       	pop	r29
    51a2:	08 95       	ret

000051a4 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    51a4:	df 93       	push	r29
    51a6:	cf 93       	push	r28
    51a8:	cd b7       	in	r28, 0x3d	; 61
    51aa:	de b7       	in	r29, 0x3e	; 62
    51ac:	2a 97       	sbiw	r28, 0x0a	; 10
    51ae:	0f b6       	in	r0, 0x3f	; 63
    51b0:	f8 94       	cli
    51b2:	de bf       	out	0x3e, r29	; 62
    51b4:	0f be       	out	0x3f, r0	; 63
    51b6:	cd bf       	out	0x3d, r28	; 61
    51b8:	9f 83       	std	Y+7, r25	; 0x07
    51ba:	8e 83       	std	Y+6, r24	; 0x06
    51bc:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    51be:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    51c0:	88 85       	ldd	r24, Y+8	; 0x08
    51c2:	86 30       	cpi	r24, 0x06	; 6
    51c4:	10 f0       	brcs	.+4      	; 0x51ca <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    51c6:	85 e0       	ldi	r24, 0x05	; 5
    51c8:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    51ca:	0f b6       	in	r0, 0x3f	; 63
    51cc:	f8 94       	cli
    51ce:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    51d0:	8e 81       	ldd	r24, Y+6	; 0x06
    51d2:	9f 81       	ldd	r25, Y+7	; 0x07
    51d4:	00 97       	sbiw	r24, 0x00	; 0
    51d6:	39 f4       	brne	.+14     	; 0x51e6 <vTaskPrioritySet+0x42>
    51d8:	80 91 ec 06 	lds	r24, 0x06EC
    51dc:	90 91 ed 06 	lds	r25, 0x06ED
    51e0:	9a 87       	std	Y+10, r25	; 0x0a
    51e2:	89 87       	std	Y+9, r24	; 0x09
    51e4:	04 c0       	rjmp	.+8      	; 0x51ee <vTaskPrioritySet+0x4a>
    51e6:	8e 81       	ldd	r24, Y+6	; 0x06
    51e8:	9f 81       	ldd	r25, Y+7	; 0x07
    51ea:	9a 87       	std	Y+10, r25	; 0x0a
    51ec:	89 87       	std	Y+9, r24	; 0x09
    51ee:	89 85       	ldd	r24, Y+9	; 0x09
    51f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    51f2:	9d 83       	std	Y+5, r25	; 0x05
    51f4:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    51f6:	ec 81       	ldd	r30, Y+4	; 0x04
    51f8:	fd 81       	ldd	r31, Y+5	; 0x05
    51fa:	87 a5       	ldd	r24, Z+47	; 0x2f
    51fc:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    51fe:	9b 81       	ldd	r25, Y+3	; 0x03
    5200:	88 85       	ldd	r24, Y+8	; 0x08
    5202:	98 17       	cp	r25, r24
    5204:	09 f4       	brne	.+2      	; 0x5208 <vTaskPrioritySet+0x64>
    5206:	8d c0       	rjmp	.+282    	; 0x5322 <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    5208:	98 85       	ldd	r25, Y+8	; 0x08
    520a:	8b 81       	ldd	r24, Y+3	; 0x03
    520c:	89 17       	cp	r24, r25
    520e:	a0 f4       	brcc	.+40     	; 0x5238 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    5210:	20 91 ec 06 	lds	r18, 0x06EC
    5214:	30 91 ed 06 	lds	r19, 0x06ED
    5218:	8c 81       	ldd	r24, Y+4	; 0x04
    521a:	9d 81       	ldd	r25, Y+5	; 0x05
    521c:	82 17       	cp	r24, r18
    521e:	93 07       	cpc	r25, r19
    5220:	b1 f0       	breq	.+44     	; 0x524e <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    5222:	e0 91 ec 06 	lds	r30, 0x06EC
    5226:	f0 91 ed 06 	lds	r31, 0x06ED
    522a:	96 89       	ldd	r25, Z+22	; 0x16
    522c:	88 85       	ldd	r24, Y+8	; 0x08
    522e:	89 17       	cp	r24, r25
    5230:	70 f0       	brcs	.+28     	; 0x524e <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    5232:	81 e0       	ldi	r24, 0x01	; 1
    5234:	89 83       	std	Y+1, r24	; 0x01
    5236:	0b c0       	rjmp	.+22     	; 0x524e <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    5238:	20 91 ec 06 	lds	r18, 0x06EC
    523c:	30 91 ed 06 	lds	r19, 0x06ED
    5240:	8c 81       	ldd	r24, Y+4	; 0x04
    5242:	9d 81       	ldd	r25, Y+5	; 0x05
    5244:	82 17       	cp	r24, r18
    5246:	93 07       	cpc	r25, r19
    5248:	11 f4       	brne	.+4      	; 0x524e <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    524a:	81 e0       	ldi	r24, 0x01	; 1
    524c:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    524e:	ec 81       	ldd	r30, Y+4	; 0x04
    5250:	fd 81       	ldd	r31, Y+5	; 0x05
    5252:	86 89       	ldd	r24, Z+22	; 0x16
    5254:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    5256:	ec 81       	ldd	r30, Y+4	; 0x04
    5258:	fd 81       	ldd	r31, Y+5	; 0x05
    525a:	97 a5       	ldd	r25, Z+47	; 0x2f
    525c:	ec 81       	ldd	r30, Y+4	; 0x04
    525e:	fd 81       	ldd	r31, Y+5	; 0x05
    5260:	86 89       	ldd	r24, Z+22	; 0x16
    5262:	98 17       	cp	r25, r24
    5264:	21 f4       	brne	.+8      	; 0x526e <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    5266:	ec 81       	ldd	r30, Y+4	; 0x04
    5268:	fd 81       	ldd	r31, Y+5	; 0x05
    526a:	88 85       	ldd	r24, Y+8	; 0x08
    526c:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    526e:	ec 81       	ldd	r30, Y+4	; 0x04
    5270:	fd 81       	ldd	r31, Y+5	; 0x05
    5272:	88 85       	ldd	r24, Y+8	; 0x08
    5274:	87 a7       	std	Z+47, r24	; 0x2f
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5276:	ec 81       	ldd	r30, Y+4	; 0x04
    5278:	fd 81       	ldd	r31, Y+5	; 0x05
    527a:	84 85       	ldd	r24, Z+12	; 0x0c
    527c:	95 85       	ldd	r25, Z+13	; 0x0d
    527e:	99 23       	and	r25, r25
    5280:	5c f0       	brlt	.+22     	; 0x5298 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5282:	88 85       	ldd	r24, Y+8	; 0x08
    5284:	28 2f       	mov	r18, r24
    5286:	30 e0       	ldi	r19, 0x00	; 0
    5288:	86 e0       	ldi	r24, 0x06	; 6
    528a:	90 e0       	ldi	r25, 0x00	; 0
    528c:	82 1b       	sub	r24, r18
    528e:	93 0b       	sbc	r25, r19
    5290:	ec 81       	ldd	r30, Y+4	; 0x04
    5292:	fd 81       	ldd	r31, Y+5	; 0x05
    5294:	95 87       	std	Z+13, r25	; 0x0d
    5296:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    5298:	ec 81       	ldd	r30, Y+4	; 0x04
    529a:	fd 81       	ldd	r31, Y+5	; 0x05
    529c:	42 85       	ldd	r20, Z+10	; 0x0a
    529e:	53 85       	ldd	r21, Z+11	; 0x0b
    52a0:	8a 81       	ldd	r24, Y+2	; 0x02
    52a2:	28 2f       	mov	r18, r24
    52a4:	30 e0       	ldi	r19, 0x00	; 0
    52a6:	c9 01       	movw	r24, r18
    52a8:	88 0f       	add	r24, r24
    52aa:	99 1f       	adc	r25, r25
    52ac:	88 0f       	add	r24, r24
    52ae:	99 1f       	adc	r25, r25
    52b0:	88 0f       	add	r24, r24
    52b2:	99 1f       	adc	r25, r25
    52b4:	82 0f       	add	r24, r18
    52b6:	93 1f       	adc	r25, r19
    52b8:	87 50       	subi	r24, 0x07	; 7
    52ba:	99 4f       	sbci	r25, 0xF9	; 249
    52bc:	48 17       	cp	r20, r24
    52be:	59 07       	cpc	r21, r25
    52c0:	59 f5       	brne	.+86     	; 0x5318 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    52c2:	8c 81       	ldd	r24, Y+4	; 0x04
    52c4:	9d 81       	ldd	r25, Y+5	; 0x05
    52c6:	02 96       	adiw	r24, 0x02	; 2
    52c8:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    52cc:	ec 81       	ldd	r30, Y+4	; 0x04
    52ce:	fd 81       	ldd	r31, Y+5	; 0x05
    52d0:	96 89       	ldd	r25, Z+22	; 0x16
    52d2:	80 91 f2 06 	lds	r24, 0x06F2
    52d6:	89 17       	cp	r24, r25
    52d8:	28 f4       	brcc	.+10     	; 0x52e4 <vTaskPrioritySet+0x140>
    52da:	ec 81       	ldd	r30, Y+4	; 0x04
    52dc:	fd 81       	ldd	r31, Y+5	; 0x05
    52de:	86 89       	ldd	r24, Z+22	; 0x16
    52e0:	80 93 f2 06 	sts	0x06F2, r24
    52e4:	ec 81       	ldd	r30, Y+4	; 0x04
    52e6:	fd 81       	ldd	r31, Y+5	; 0x05
    52e8:	86 89       	ldd	r24, Z+22	; 0x16
    52ea:	28 2f       	mov	r18, r24
    52ec:	30 e0       	ldi	r19, 0x00	; 0
    52ee:	c9 01       	movw	r24, r18
    52f0:	88 0f       	add	r24, r24
    52f2:	99 1f       	adc	r25, r25
    52f4:	88 0f       	add	r24, r24
    52f6:	99 1f       	adc	r25, r25
    52f8:	88 0f       	add	r24, r24
    52fa:	99 1f       	adc	r25, r25
    52fc:	82 0f       	add	r24, r18
    52fe:	93 1f       	adc	r25, r19
    5300:	ac 01       	movw	r20, r24
    5302:	47 50       	subi	r20, 0x07	; 7
    5304:	59 4f       	sbci	r21, 0xF9	; 249
    5306:	8c 81       	ldd	r24, Y+4	; 0x04
    5308:	9d 81       	ldd	r25, Y+5	; 0x05
    530a:	9c 01       	movw	r18, r24
    530c:	2e 5f       	subi	r18, 0xFE	; 254
    530e:	3f 4f       	sbci	r19, 0xFF	; 255
    5310:	ca 01       	movw	r24, r20
    5312:	b9 01       	movw	r22, r18
    5314:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    5318:	89 81       	ldd	r24, Y+1	; 0x01
    531a:	81 30       	cpi	r24, 0x01	; 1
    531c:	11 f4       	brne	.+4      	; 0x5322 <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    531e:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    5322:	0f 90       	pop	r0
    5324:	0f be       	out	0x3f, r0	; 63
	}
    5326:	2a 96       	adiw	r28, 0x0a	; 10
    5328:	0f b6       	in	r0, 0x3f	; 63
    532a:	f8 94       	cli
    532c:	de bf       	out	0x3e, r29	; 62
    532e:	0f be       	out	0x3f, r0	; 63
    5330:	cd bf       	out	0x3d, r28	; 61
    5332:	cf 91       	pop	r28
    5334:	df 91       	pop	r29
    5336:	08 95       	ret

00005338 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    5338:	df 93       	push	r29
    533a:	cf 93       	push	r28
    533c:	00 d0       	rcall	.+0      	; 0x533e <vTaskSuspend+0x6>
    533e:	00 d0       	rcall	.+0      	; 0x5340 <vTaskSuspend+0x8>
    5340:	00 d0       	rcall	.+0      	; 0x5342 <vTaskSuspend+0xa>
    5342:	cd b7       	in	r28, 0x3d	; 61
    5344:	de b7       	in	r29, 0x3e	; 62
    5346:	9c 83       	std	Y+4, r25	; 0x04
    5348:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    534a:	0f b6       	in	r0, 0x3f	; 63
    534c:	f8 94       	cli
    534e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    5350:	8b 81       	ldd	r24, Y+3	; 0x03
    5352:	9c 81       	ldd	r25, Y+4	; 0x04
    5354:	00 97       	sbiw	r24, 0x00	; 0
    5356:	39 f4       	brne	.+14     	; 0x5366 <vTaskSuspend+0x2e>
    5358:	80 91 ec 06 	lds	r24, 0x06EC
    535c:	90 91 ed 06 	lds	r25, 0x06ED
    5360:	9e 83       	std	Y+6, r25	; 0x06
    5362:	8d 83       	std	Y+5, r24	; 0x05
    5364:	04 c0       	rjmp	.+8      	; 0x536e <vTaskSuspend+0x36>
    5366:	8b 81       	ldd	r24, Y+3	; 0x03
    5368:	9c 81       	ldd	r25, Y+4	; 0x04
    536a:	9e 83       	std	Y+6, r25	; 0x06
    536c:	8d 83       	std	Y+5, r24	; 0x05
    536e:	8d 81       	ldd	r24, Y+5	; 0x05
    5370:	9e 81       	ldd	r25, Y+6	; 0x06
    5372:	9a 83       	std	Y+2, r25	; 0x02
    5374:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5376:	89 81       	ldd	r24, Y+1	; 0x01
    5378:	9a 81       	ldd	r25, Y+2	; 0x02
    537a:	02 96       	adiw	r24, 0x02	; 2
    537c:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5380:	e9 81       	ldd	r30, Y+1	; 0x01
    5382:	fa 81       	ldd	r31, Y+2	; 0x02
    5384:	84 89       	ldd	r24, Z+20	; 0x14
    5386:	95 89       	ldd	r25, Z+21	; 0x15
    5388:	00 97       	sbiw	r24, 0x00	; 0
    538a:	29 f0       	breq	.+10     	; 0x5396 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    538c:	89 81       	ldd	r24, Y+1	; 0x01
    538e:	9a 81       	ldd	r25, Y+2	; 0x02
    5390:	0c 96       	adiw	r24, 0x0c	; 12
    5392:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    5396:	89 81       	ldd	r24, Y+1	; 0x01
    5398:	9a 81       	ldd	r25, Y+2	; 0x02
    539a:	9c 01       	movw	r18, r24
    539c:	2e 5f       	subi	r18, 0xFE	; 254
    539e:	3f 4f       	sbci	r19, 0xFF	; 255
    53a0:	87 e5       	ldi	r24, 0x57	; 87
    53a2:	97 e0       	ldi	r25, 0x07	; 7
    53a4:	b9 01       	movw	r22, r18
    53a6:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    53aa:	0f 90       	pop	r0
    53ac:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    53ae:	20 91 ec 06 	lds	r18, 0x06EC
    53b2:	30 91 ed 06 	lds	r19, 0x06ED
    53b6:	89 81       	ldd	r24, Y+1	; 0x01
    53b8:	9a 81       	ldd	r25, Y+2	; 0x02
    53ba:	82 17       	cp	r24, r18
    53bc:	93 07       	cpc	r25, r19
    53be:	a9 f4       	brne	.+42     	; 0x53ea <vTaskSuspend+0xb2>
		{
			if( xSchedulerRunning != pdFALSE )
    53c0:	80 91 f3 06 	lds	r24, 0x06F3
    53c4:	88 23       	and	r24, r24
    53c6:	19 f0       	breq	.+6      	; 0x53ce <vTaskSuspend+0x96>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    53c8:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    53cc:	19 c0       	rjmp	.+50     	; 0x5400 <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    53ce:	90 91 57 07 	lds	r25, 0x0757
    53d2:	80 91 ef 06 	lds	r24, 0x06EF
    53d6:	98 17       	cp	r25, r24
    53d8:	29 f4       	brne	.+10     	; 0x53e4 <vTaskSuspend+0xac>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    53da:	10 92 ed 06 	sts	0x06ED, r1
    53de:	10 92 ec 06 	sts	0x06EC, r1
    53e2:	0e c0       	rjmp	.+28     	; 0x5400 <vTaskSuspend+0xc8>
				}
				else
				{
					vTaskSwitchContext();
    53e4:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <vTaskSwitchContext>
    53e8:	0b c0       	rjmp	.+22     	; 0x5400 <vTaskSuspend+0xc8>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    53ea:	80 91 f3 06 	lds	r24, 0x06F3
    53ee:	88 23       	and	r24, r24
    53f0:	39 f0       	breq	.+14     	; 0x5400 <vTaskSuspend+0xc8>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    53f2:	0f b6       	in	r0, 0x3f	; 63
    53f4:	f8 94       	cli
    53f6:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    53f8:	0e 94 e9 33 	call	0x67d2	; 0x67d2 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    53fc:	0f 90       	pop	r0
    53fe:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    5400:	26 96       	adiw	r28, 0x06	; 6
    5402:	0f b6       	in	r0, 0x3f	; 63
    5404:	f8 94       	cli
    5406:	de bf       	out	0x3e, r29	; 62
    5408:	0f be       	out	0x3f, r0	; 63
    540a:	cd bf       	out	0x3d, r28	; 61
    540c:	cf 91       	pop	r28
    540e:	df 91       	pop	r29
    5410:	08 95       	ret

00005412 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    5412:	df 93       	push	r29
    5414:	cf 93       	push	r28
    5416:	00 d0       	rcall	.+0      	; 0x5418 <prvTaskIsTaskSuspended+0x6>
    5418:	00 d0       	rcall	.+0      	; 0x541a <prvTaskIsTaskSuspended+0x8>
    541a:	0f 92       	push	r0
    541c:	cd b7       	in	r28, 0x3d	; 61
    541e:	de b7       	in	r29, 0x3e	; 62
    5420:	9d 83       	std	Y+5, r25	; 0x05
    5422:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    5424:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    5426:	8c 81       	ldd	r24, Y+4	; 0x04
    5428:	9d 81       	ldd	r25, Y+5	; 0x05
    542a:	9a 83       	std	Y+2, r25	; 0x02
    542c:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    542e:	e9 81       	ldd	r30, Y+1	; 0x01
    5430:	fa 81       	ldd	r31, Y+2	; 0x02
    5432:	82 85       	ldd	r24, Z+10	; 0x0a
    5434:	93 85       	ldd	r25, Z+11	; 0x0b
    5436:	27 e0       	ldi	r18, 0x07	; 7
    5438:	87 35       	cpi	r24, 0x57	; 87
    543a:	92 07       	cpc	r25, r18
    543c:	81 f4       	brne	.+32     	; 0x545e <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    543e:	e9 81       	ldd	r30, Y+1	; 0x01
    5440:	fa 81       	ldd	r31, Y+2	; 0x02
    5442:	84 89       	ldd	r24, Z+20	; 0x14
    5444:	95 89       	ldd	r25, Z+21	; 0x15
    5446:	27 e0       	ldi	r18, 0x07	; 7
    5448:	85 34       	cpi	r24, 0x45	; 69
    544a:	92 07       	cpc	r25, r18
    544c:	41 f0       	breq	.+16     	; 0x545e <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    544e:	e9 81       	ldd	r30, Y+1	; 0x01
    5450:	fa 81       	ldd	r31, Y+2	; 0x02
    5452:	84 89       	ldd	r24, Z+20	; 0x14
    5454:	95 89       	ldd	r25, Z+21	; 0x15
    5456:	00 97       	sbiw	r24, 0x00	; 0
    5458:	11 f4       	brne	.+4      	; 0x545e <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    545a:	81 e0       	ldi	r24, 0x01	; 1
    545c:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    545e:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    5460:	0f 90       	pop	r0
    5462:	0f 90       	pop	r0
    5464:	0f 90       	pop	r0
    5466:	0f 90       	pop	r0
    5468:	0f 90       	pop	r0
    546a:	cf 91       	pop	r28
    546c:	df 91       	pop	r29
    546e:	08 95       	ret

00005470 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    5470:	df 93       	push	r29
    5472:	cf 93       	push	r28
    5474:	00 d0       	rcall	.+0      	; 0x5476 <vTaskResume+0x6>
    5476:	00 d0       	rcall	.+0      	; 0x5478 <vTaskResume+0x8>
    5478:	cd b7       	in	r28, 0x3d	; 61
    547a:	de b7       	in	r29, 0x3e	; 62
    547c:	9c 83       	std	Y+4, r25	; 0x04
    547e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    5480:	8b 81       	ldd	r24, Y+3	; 0x03
    5482:	9c 81       	ldd	r25, Y+4	; 0x04
    5484:	9a 83       	std	Y+2, r25	; 0x02
    5486:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    5488:	89 81       	ldd	r24, Y+1	; 0x01
    548a:	9a 81       	ldd	r25, Y+2	; 0x02
    548c:	00 97       	sbiw	r24, 0x00	; 0
    548e:	09 f4       	brne	.+2      	; 0x5492 <vTaskResume+0x22>
    5490:	4c c0       	rjmp	.+152    	; 0x552a <vTaskResume+0xba>
    5492:	20 91 ec 06 	lds	r18, 0x06EC
    5496:	30 91 ed 06 	lds	r19, 0x06ED
    549a:	89 81       	ldd	r24, Y+1	; 0x01
    549c:	9a 81       	ldd	r25, Y+2	; 0x02
    549e:	82 17       	cp	r24, r18
    54a0:	93 07       	cpc	r25, r19
    54a2:	09 f4       	brne	.+2      	; 0x54a6 <vTaskResume+0x36>
    54a4:	42 c0       	rjmp	.+132    	; 0x552a <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    54a6:	0f b6       	in	r0, 0x3f	; 63
    54a8:	f8 94       	cli
    54aa:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    54ac:	89 81       	ldd	r24, Y+1	; 0x01
    54ae:	9a 81       	ldd	r25, Y+2	; 0x02
    54b0:	0e 94 09 2a 	call	0x5412	; 0x5412 <prvTaskIsTaskSuspended>
    54b4:	81 30       	cpi	r24, 0x01	; 1
    54b6:	b9 f5       	brne	.+110    	; 0x5526 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    54b8:	89 81       	ldd	r24, Y+1	; 0x01
    54ba:	9a 81       	ldd	r25, Y+2	; 0x02
    54bc:	02 96       	adiw	r24, 0x02	; 2
    54be:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    54c2:	e9 81       	ldd	r30, Y+1	; 0x01
    54c4:	fa 81       	ldd	r31, Y+2	; 0x02
    54c6:	96 89       	ldd	r25, Z+22	; 0x16
    54c8:	80 91 f2 06 	lds	r24, 0x06F2
    54cc:	89 17       	cp	r24, r25
    54ce:	28 f4       	brcc	.+10     	; 0x54da <vTaskResume+0x6a>
    54d0:	e9 81       	ldd	r30, Y+1	; 0x01
    54d2:	fa 81       	ldd	r31, Y+2	; 0x02
    54d4:	86 89       	ldd	r24, Z+22	; 0x16
    54d6:	80 93 f2 06 	sts	0x06F2, r24
    54da:	e9 81       	ldd	r30, Y+1	; 0x01
    54dc:	fa 81       	ldd	r31, Y+2	; 0x02
    54de:	86 89       	ldd	r24, Z+22	; 0x16
    54e0:	28 2f       	mov	r18, r24
    54e2:	30 e0       	ldi	r19, 0x00	; 0
    54e4:	c9 01       	movw	r24, r18
    54e6:	88 0f       	add	r24, r24
    54e8:	99 1f       	adc	r25, r25
    54ea:	88 0f       	add	r24, r24
    54ec:	99 1f       	adc	r25, r25
    54ee:	88 0f       	add	r24, r24
    54f0:	99 1f       	adc	r25, r25
    54f2:	82 0f       	add	r24, r18
    54f4:	93 1f       	adc	r25, r19
    54f6:	ac 01       	movw	r20, r24
    54f8:	47 50       	subi	r20, 0x07	; 7
    54fa:	59 4f       	sbci	r21, 0xF9	; 249
    54fc:	89 81       	ldd	r24, Y+1	; 0x01
    54fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5500:	9c 01       	movw	r18, r24
    5502:	2e 5f       	subi	r18, 0xFE	; 254
    5504:	3f 4f       	sbci	r19, 0xFF	; 255
    5506:	ca 01       	movw	r24, r20
    5508:	b9 01       	movw	r22, r18
    550a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    550e:	e9 81       	ldd	r30, Y+1	; 0x01
    5510:	fa 81       	ldd	r31, Y+2	; 0x02
    5512:	96 89       	ldd	r25, Z+22	; 0x16
    5514:	e0 91 ec 06 	lds	r30, 0x06EC
    5518:	f0 91 ed 06 	lds	r31, 0x06ED
    551c:	86 89       	ldd	r24, Z+22	; 0x16
    551e:	98 17       	cp	r25, r24
    5520:	10 f0       	brcs	.+4      	; 0x5526 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    5522:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5526:	0f 90       	pop	r0
    5528:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    552a:	0f 90       	pop	r0
    552c:	0f 90       	pop	r0
    552e:	0f 90       	pop	r0
    5530:	0f 90       	pop	r0
    5532:	cf 91       	pop	r28
    5534:	df 91       	pop	r29
    5536:	08 95       	ret

00005538 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    5538:	df 93       	push	r29
    553a:	cf 93       	push	r28
    553c:	00 d0       	rcall	.+0      	; 0x553e <xTaskResumeFromISR+0x6>
    553e:	00 d0       	rcall	.+0      	; 0x5540 <xTaskResumeFromISR+0x8>
    5540:	00 d0       	rcall	.+0      	; 0x5542 <xTaskResumeFromISR+0xa>
    5542:	cd b7       	in	r28, 0x3d	; 61
    5544:	de b7       	in	r29, 0x3e	; 62
    5546:	9e 83       	std	Y+6, r25	; 0x06
    5548:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    554a:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    554c:	8d 81       	ldd	r24, Y+5	; 0x05
    554e:	9e 81       	ldd	r25, Y+6	; 0x06
    5550:	9b 83       	std	Y+3, r25	; 0x03
    5552:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5554:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    5556:	8a 81       	ldd	r24, Y+2	; 0x02
    5558:	9b 81       	ldd	r25, Y+3	; 0x03
    555a:	0e 94 09 2a 	call	0x5412	; 0x5412 <prvTaskIsTaskSuspended>
    555e:	81 30       	cpi	r24, 0x01	; 1
    5560:	09 f0       	breq	.+2      	; 0x5564 <xTaskResumeFromISR+0x2c>
    5562:	46 c0       	rjmp	.+140    	; 0x55f0 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5564:	80 91 f8 06 	lds	r24, 0x06F8
    5568:	88 23       	and	r24, r24
    556a:	c1 f5       	brne	.+112    	; 0x55dc <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    556c:	ea 81       	ldd	r30, Y+2	; 0x02
    556e:	fb 81       	ldd	r31, Y+3	; 0x03
    5570:	96 89       	ldd	r25, Z+22	; 0x16
    5572:	e0 91 ec 06 	lds	r30, 0x06EC
    5576:	f0 91 ed 06 	lds	r31, 0x06ED
    557a:	86 89       	ldd	r24, Z+22	; 0x16
    557c:	98 17       	cp	r25, r24
    557e:	10 f0       	brcs	.+4      	; 0x5584 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    5580:	81 e0       	ldi	r24, 0x01	; 1
    5582:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    5584:	8a 81       	ldd	r24, Y+2	; 0x02
    5586:	9b 81       	ldd	r25, Y+3	; 0x03
    5588:	02 96       	adiw	r24, 0x02	; 2
    558a:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    558e:	ea 81       	ldd	r30, Y+2	; 0x02
    5590:	fb 81       	ldd	r31, Y+3	; 0x03
    5592:	96 89       	ldd	r25, Z+22	; 0x16
    5594:	80 91 f2 06 	lds	r24, 0x06F2
    5598:	89 17       	cp	r24, r25
    559a:	28 f4       	brcc	.+10     	; 0x55a6 <xTaskResumeFromISR+0x6e>
    559c:	ea 81       	ldd	r30, Y+2	; 0x02
    559e:	fb 81       	ldd	r31, Y+3	; 0x03
    55a0:	86 89       	ldd	r24, Z+22	; 0x16
    55a2:	80 93 f2 06 	sts	0x06F2, r24
    55a6:	ea 81       	ldd	r30, Y+2	; 0x02
    55a8:	fb 81       	ldd	r31, Y+3	; 0x03
    55aa:	86 89       	ldd	r24, Z+22	; 0x16
    55ac:	28 2f       	mov	r18, r24
    55ae:	30 e0       	ldi	r19, 0x00	; 0
    55b0:	c9 01       	movw	r24, r18
    55b2:	88 0f       	add	r24, r24
    55b4:	99 1f       	adc	r25, r25
    55b6:	88 0f       	add	r24, r24
    55b8:	99 1f       	adc	r25, r25
    55ba:	88 0f       	add	r24, r24
    55bc:	99 1f       	adc	r25, r25
    55be:	82 0f       	add	r24, r18
    55c0:	93 1f       	adc	r25, r19
    55c2:	ac 01       	movw	r20, r24
    55c4:	47 50       	subi	r20, 0x07	; 7
    55c6:	59 4f       	sbci	r21, 0xF9	; 249
    55c8:	8a 81       	ldd	r24, Y+2	; 0x02
    55ca:	9b 81       	ldd	r25, Y+3	; 0x03
    55cc:	9c 01       	movw	r18, r24
    55ce:	2e 5f       	subi	r18, 0xFE	; 254
    55d0:	3f 4f       	sbci	r19, 0xFF	; 255
    55d2:	ca 01       	movw	r24, r20
    55d4:	b9 01       	movw	r22, r18
    55d6:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
    55da:	0a c0       	rjmp	.+20     	; 0x55f0 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    55dc:	8a 81       	ldd	r24, Y+2	; 0x02
    55de:	9b 81       	ldd	r25, Y+3	; 0x03
    55e0:	9c 01       	movw	r18, r24
    55e2:	24 5f       	subi	r18, 0xF4	; 244
    55e4:	3f 4f       	sbci	r19, 0xFF	; 255
    55e6:	85 e4       	ldi	r24, 0x45	; 69
    55e8:	97 e0       	ldi	r25, 0x07	; 7
    55ea:	b9 01       	movw	r22, r18
    55ec:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    55f0:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    55f2:	26 96       	adiw	r28, 0x06	; 6
    55f4:	0f b6       	in	r0, 0x3f	; 63
    55f6:	f8 94       	cli
    55f8:	de bf       	out	0x3e, r29	; 62
    55fa:	0f be       	out	0x3f, r0	; 63
    55fc:	cd bf       	out	0x3d, r28	; 61
    55fe:	cf 91       	pop	r28
    5600:	df 91       	pop	r29
    5602:	08 95       	ret

00005604 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5604:	af 92       	push	r10
    5606:	bf 92       	push	r11
    5608:	cf 92       	push	r12
    560a:	df 92       	push	r13
    560c:	ef 92       	push	r14
    560e:	ff 92       	push	r15
    5610:	0f 93       	push	r16
    5612:	df 93       	push	r29
    5614:	cf 93       	push	r28
    5616:	0f 92       	push	r0
    5618:	cd b7       	in	r28, 0x3d	; 61
    561a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    561c:	80 e8       	ldi	r24, 0x80	; 128
    561e:	90 e3       	ldi	r25, 0x30	; 48
    5620:	2d e8       	ldi	r18, 0x8D	; 141
    5622:	30 e0       	ldi	r19, 0x00	; 0
    5624:	b9 01       	movw	r22, r18
    5626:	45 e5       	ldi	r20, 0x55	; 85
    5628:	50 e0       	ldi	r21, 0x00	; 0
    562a:	20 e0       	ldi	r18, 0x00	; 0
    562c:	30 e0       	ldi	r19, 0x00	; 0
    562e:	00 e0       	ldi	r16, 0x00	; 0
    5630:	ee 24       	eor	r14, r14
    5632:	ff 24       	eor	r15, r15
    5634:	cc 24       	eor	r12, r12
    5636:	dd 24       	eor	r13, r13
    5638:	aa 24       	eor	r10, r10
    563a:	bb 24       	eor	r11, r11
    563c:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <xTaskGenericCreate>
    5640:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5642:	89 81       	ldd	r24, Y+1	; 0x01
    5644:	81 30       	cpi	r24, 0x01	; 1
    5646:	51 f4       	brne	.+20     	; 0x565c <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5648:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    564a:	81 e0       	ldi	r24, 0x01	; 1
    564c:	80 93 f3 06 	sts	0x06F3, r24
		xTickCount = ( TickType_t ) 0U;
    5650:	10 92 f1 06 	sts	0x06F1, r1
    5654:	10 92 f0 06 	sts	0x06F0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5658:	0e 94 76 1d 	call	0x3aec	; 0x3aec <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    565c:	0f 90       	pop	r0
    565e:	cf 91       	pop	r28
    5660:	df 91       	pop	r29
    5662:	0f 91       	pop	r16
    5664:	ff 90       	pop	r15
    5666:	ef 90       	pop	r14
    5668:	df 90       	pop	r13
    566a:	cf 90       	pop	r12
    566c:	bf 90       	pop	r11
    566e:	af 90       	pop	r10
    5670:	08 95       	ret

00005672 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    5672:	df 93       	push	r29
    5674:	cf 93       	push	r28
    5676:	cd b7       	in	r28, 0x3d	; 61
    5678:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    567a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    567c:	10 92 f3 06 	sts	0x06F3, r1
	vPortEndScheduler();
    5680:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <vPortEndScheduler>
}
    5684:	cf 91       	pop	r28
    5686:	df 91       	pop	r29
    5688:	08 95       	ret

0000568a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    568a:	df 93       	push	r29
    568c:	cf 93       	push	r28
    568e:	cd b7       	in	r28, 0x3d	; 61
    5690:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5692:	80 91 f8 06 	lds	r24, 0x06F8
    5696:	8f 5f       	subi	r24, 0xFF	; 255
    5698:	80 93 f8 06 	sts	0x06F8, r24
}
    569c:	cf 91       	pop	r28
    569e:	df 91       	pop	r29
    56a0:	08 95       	ret

000056a2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    56a2:	df 93       	push	r29
    56a4:	cf 93       	push	r28
    56a6:	00 d0       	rcall	.+0      	; 0x56a8 <xTaskResumeAll+0x6>
    56a8:	0f 92       	push	r0
    56aa:	cd b7       	in	r28, 0x3d	; 61
    56ac:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    56ae:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    56b0:	0f b6       	in	r0, 0x3f	; 63
    56b2:	f8 94       	cli
    56b4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    56b6:	80 91 f8 06 	lds	r24, 0x06F8
    56ba:	81 50       	subi	r24, 0x01	; 1
    56bc:	80 93 f8 06 	sts	0x06F8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    56c0:	80 91 f8 06 	lds	r24, 0x06F8
    56c4:	88 23       	and	r24, r24
    56c6:	09 f0       	breq	.+2      	; 0x56ca <xTaskResumeAll+0x28>
    56c8:	6d c0       	rjmp	.+218    	; 0x57a4 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    56ca:	80 91 ef 06 	lds	r24, 0x06EF
    56ce:	88 23       	and	r24, r24
    56d0:	09 f4       	brne	.+2      	; 0x56d4 <xTaskResumeAll+0x32>
    56d2:	68 c0       	rjmp	.+208    	; 0x57a4 <xTaskResumeAll+0x102>
    56d4:	45 c0       	rjmp	.+138    	; 0x5760 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    56d6:	e0 91 4a 07 	lds	r30, 0x074A
    56da:	f0 91 4b 07 	lds	r31, 0x074B
    56de:	86 81       	ldd	r24, Z+6	; 0x06
    56e0:	97 81       	ldd	r25, Z+7	; 0x07
    56e2:	9b 83       	std	Y+3, r25	; 0x03
    56e4:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    56e6:	8a 81       	ldd	r24, Y+2	; 0x02
    56e8:	9b 81       	ldd	r25, Y+3	; 0x03
    56ea:	0c 96       	adiw	r24, 0x0c	; 12
    56ec:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    56f0:	8a 81       	ldd	r24, Y+2	; 0x02
    56f2:	9b 81       	ldd	r25, Y+3	; 0x03
    56f4:	02 96       	adiw	r24, 0x02	; 2
    56f6:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    56fa:	ea 81       	ldd	r30, Y+2	; 0x02
    56fc:	fb 81       	ldd	r31, Y+3	; 0x03
    56fe:	96 89       	ldd	r25, Z+22	; 0x16
    5700:	80 91 f2 06 	lds	r24, 0x06F2
    5704:	89 17       	cp	r24, r25
    5706:	28 f4       	brcc	.+10     	; 0x5712 <xTaskResumeAll+0x70>
    5708:	ea 81       	ldd	r30, Y+2	; 0x02
    570a:	fb 81       	ldd	r31, Y+3	; 0x03
    570c:	86 89       	ldd	r24, Z+22	; 0x16
    570e:	80 93 f2 06 	sts	0x06F2, r24
    5712:	ea 81       	ldd	r30, Y+2	; 0x02
    5714:	fb 81       	ldd	r31, Y+3	; 0x03
    5716:	86 89       	ldd	r24, Z+22	; 0x16
    5718:	28 2f       	mov	r18, r24
    571a:	30 e0       	ldi	r19, 0x00	; 0
    571c:	c9 01       	movw	r24, r18
    571e:	88 0f       	add	r24, r24
    5720:	99 1f       	adc	r25, r25
    5722:	88 0f       	add	r24, r24
    5724:	99 1f       	adc	r25, r25
    5726:	88 0f       	add	r24, r24
    5728:	99 1f       	adc	r25, r25
    572a:	82 0f       	add	r24, r18
    572c:	93 1f       	adc	r25, r19
    572e:	ac 01       	movw	r20, r24
    5730:	47 50       	subi	r20, 0x07	; 7
    5732:	59 4f       	sbci	r21, 0xF9	; 249
    5734:	8a 81       	ldd	r24, Y+2	; 0x02
    5736:	9b 81       	ldd	r25, Y+3	; 0x03
    5738:	9c 01       	movw	r18, r24
    573a:	2e 5f       	subi	r18, 0xFE	; 254
    573c:	3f 4f       	sbci	r19, 0xFF	; 255
    573e:	ca 01       	movw	r24, r20
    5740:	b9 01       	movw	r22, r18
    5742:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5746:	ea 81       	ldd	r30, Y+2	; 0x02
    5748:	fb 81       	ldd	r31, Y+3	; 0x03
    574a:	96 89       	ldd	r25, Z+22	; 0x16
    574c:	e0 91 ec 06 	lds	r30, 0x06EC
    5750:	f0 91 ed 06 	lds	r31, 0x06ED
    5754:	86 89       	ldd	r24, Z+22	; 0x16
    5756:	98 17       	cp	r25, r24
    5758:	18 f0       	brcs	.+6      	; 0x5760 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    575a:	81 e0       	ldi	r24, 0x01	; 1
    575c:	80 93 f5 06 	sts	0x06F5, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5760:	80 91 45 07 	lds	r24, 0x0745
    5764:	88 23       	and	r24, r24
    5766:	09 f0       	breq	.+2      	; 0x576a <xTaskResumeAll+0xc8>
    5768:	b6 cf       	rjmp	.-148    	; 0x56d6 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    576a:	80 91 f4 06 	lds	r24, 0x06F4
    576e:	88 23       	and	r24, r24
    5770:	89 f0       	breq	.+34     	; 0x5794 <xTaskResumeAll+0xf2>
    5772:	0c c0       	rjmp	.+24     	; 0x578c <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    5774:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <xTaskIncrementTick>
    5778:	88 23       	and	r24, r24
    577a:	19 f0       	breq	.+6      	; 0x5782 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    577c:	81 e0       	ldi	r24, 0x01	; 1
    577e:	80 93 f5 06 	sts	0x06F5, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    5782:	80 91 f4 06 	lds	r24, 0x06F4
    5786:	81 50       	subi	r24, 0x01	; 1
    5788:	80 93 f4 06 	sts	0x06F4, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    578c:	80 91 f4 06 	lds	r24, 0x06F4
    5790:	88 23       	and	r24, r24
    5792:	81 f7       	brne	.-32     	; 0x5774 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    5794:	80 91 f5 06 	lds	r24, 0x06F5
    5798:	81 30       	cpi	r24, 0x01	; 1
    579a:	21 f4       	brne	.+8      	; 0x57a4 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    579c:	81 e0       	ldi	r24, 0x01	; 1
    579e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    57a0:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    57a4:	0f 90       	pop	r0
    57a6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    57a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    57aa:	0f 90       	pop	r0
    57ac:	0f 90       	pop	r0
    57ae:	0f 90       	pop	r0
    57b0:	cf 91       	pop	r28
    57b2:	df 91       	pop	r29
    57b4:	08 95       	ret

000057b6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    57b6:	df 93       	push	r29
    57b8:	cf 93       	push	r28
    57ba:	00 d0       	rcall	.+0      	; 0x57bc <xTaskGetTickCount+0x6>
    57bc:	cd b7       	in	r28, 0x3d	; 61
    57be:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    57c0:	0f b6       	in	r0, 0x3f	; 63
    57c2:	f8 94       	cli
    57c4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    57c6:	80 91 f0 06 	lds	r24, 0x06F0
    57ca:	90 91 f1 06 	lds	r25, 0x06F1
    57ce:	9a 83       	std	Y+2, r25	; 0x02
    57d0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    57d2:	0f 90       	pop	r0
    57d4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    57d6:	89 81       	ldd	r24, Y+1	; 0x01
    57d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    57da:	0f 90       	pop	r0
    57dc:	0f 90       	pop	r0
    57de:	cf 91       	pop	r28
    57e0:	df 91       	pop	r29
    57e2:	08 95       	ret

000057e4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    57e4:	df 93       	push	r29
    57e6:	cf 93       	push	r28
    57e8:	00 d0       	rcall	.+0      	; 0x57ea <xTaskGetTickCountFromISR+0x6>
    57ea:	0f 92       	push	r0
    57ec:	cd b7       	in	r28, 0x3d	; 61
    57ee:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    57f0:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    57f2:	80 91 f0 06 	lds	r24, 0x06F0
    57f6:	90 91 f1 06 	lds	r25, 0x06F1
    57fa:	9b 83       	std	Y+3, r25	; 0x03
    57fc:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    57fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5800:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5802:	0f 90       	pop	r0
    5804:	0f 90       	pop	r0
    5806:	0f 90       	pop	r0
    5808:	cf 91       	pop	r28
    580a:	df 91       	pop	r29
    580c:	08 95       	ret

0000580e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    580e:	df 93       	push	r29
    5810:	cf 93       	push	r28
    5812:	cd b7       	in	r28, 0x3d	; 61
    5814:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    5816:	80 91 ef 06 	lds	r24, 0x06EF
}
    581a:	cf 91       	pop	r28
    581c:	df 91       	pop	r29
    581e:	08 95       	ret

00005820 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
    5820:	df 93       	push	r29
    5822:	cf 93       	push	r28
    5824:	cd b7       	in	r28, 0x3d	; 61
    5826:	de b7       	in	r29, 0x3e	; 62
    5828:	27 97       	sbiw	r28, 0x07	; 7
    582a:	0f b6       	in	r0, 0x3f	; 63
    582c:	f8 94       	cli
    582e:	de bf       	out	0x3e, r29	; 62
    5830:	0f be       	out	0x3f, r0	; 63
    5832:	cd bf       	out	0x3d, r28	; 61
    5834:	9c 83       	std	Y+4, r25	; 0x04
    5836:	8b 83       	std	Y+3, r24	; 0x03
    5838:	6d 83       	std	Y+5, r22	; 0x05
    583a:	5f 83       	std	Y+7, r21	; 0x07
    583c:	4e 83       	std	Y+6, r20	; 0x06
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    583e:	1a 82       	std	Y+2, r1	; 0x02
    5840:	86 e0       	ldi	r24, 0x06	; 6
    5842:	89 83       	std	Y+1, r24	; 0x01

		vTaskSuspendAll();
    5844:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
    5848:	90 91 ef 06 	lds	r25, 0x06EF
    584c:	8d 81       	ldd	r24, Y+5	; 0x05
    584e:	89 17       	cp	r24, r25
    5850:	08 f4       	brcc	.+2      	; 0x5854 <uxTaskGetSystemState+0x34>
    5852:	be c0       	rjmp	.+380    	; 0x59d0 <uxTaskGetSystemState+0x1b0>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
    5854:	89 81       	ldd	r24, Y+1	; 0x01
    5856:	81 50       	subi	r24, 0x01	; 1
    5858:	89 83       	std	Y+1, r24	; 0x01
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    585a:	8a 81       	ldd	r24, Y+2	; 0x02
    585c:	88 2f       	mov	r24, r24
    585e:	90 e0       	ldi	r25, 0x00	; 0
    5860:	9c 01       	movw	r18, r24
    5862:	22 0f       	add	r18, r18
    5864:	33 1f       	adc	r19, r19
    5866:	c9 01       	movw	r24, r18
    5868:	88 0f       	add	r24, r24
    586a:	99 1f       	adc	r25, r25
    586c:	88 0f       	add	r24, r24
    586e:	99 1f       	adc	r25, r25
    5870:	88 0f       	add	r24, r24
    5872:	99 1f       	adc	r25, r25
    5874:	ac 01       	movw	r20, r24
    5876:	42 1b       	sub	r20, r18
    5878:	53 0b       	sbc	r21, r19
    587a:	9a 01       	movw	r18, r20
    587c:	8b 81       	ldd	r24, Y+3	; 0x03
    587e:	9c 81       	ldd	r25, Y+4	; 0x04
    5880:	ac 01       	movw	r20, r24
    5882:	42 0f       	add	r20, r18
    5884:	53 1f       	adc	r21, r19
    5886:	89 81       	ldd	r24, Y+1	; 0x01
    5888:	28 2f       	mov	r18, r24
    588a:	30 e0       	ldi	r19, 0x00	; 0
    588c:	c9 01       	movw	r24, r18
    588e:	88 0f       	add	r24, r24
    5890:	99 1f       	adc	r25, r25
    5892:	88 0f       	add	r24, r24
    5894:	99 1f       	adc	r25, r25
    5896:	88 0f       	add	r24, r24
    5898:	99 1f       	adc	r25, r25
    589a:	82 0f       	add	r24, r18
    589c:	93 1f       	adc	r25, r19
    589e:	9c 01       	movw	r18, r24
    58a0:	27 50       	subi	r18, 0x07	; 7
    58a2:	39 4f       	sbci	r19, 0xF9	; 249
    58a4:	ca 01       	movw	r24, r20
    58a6:	b9 01       	movw	r22, r18
    58a8:	41 e0       	ldi	r20, 0x01	; 1
    58aa:	0e 94 23 32 	call	0x6446	; 0x6446 <prvListTaskWithinSingleList>
    58ae:	98 2f       	mov	r25, r24
    58b0:	8a 81       	ldd	r24, Y+2	; 0x02
    58b2:	89 0f       	add	r24, r25
    58b4:	8a 83       	std	Y+2, r24	; 0x02

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    58b6:	89 81       	ldd	r24, Y+1	; 0x01
    58b8:	88 23       	and	r24, r24
    58ba:	61 f6       	brne	.-104    	; 0x5854 <uxTaskGetSystemState+0x34>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    58bc:	8a 81       	ldd	r24, Y+2	; 0x02
    58be:	88 2f       	mov	r24, r24
    58c0:	90 e0       	ldi	r25, 0x00	; 0
    58c2:	9c 01       	movw	r18, r24
    58c4:	22 0f       	add	r18, r18
    58c6:	33 1f       	adc	r19, r19
    58c8:	c9 01       	movw	r24, r18
    58ca:	88 0f       	add	r24, r24
    58cc:	99 1f       	adc	r25, r25
    58ce:	88 0f       	add	r24, r24
    58d0:	99 1f       	adc	r25, r25
    58d2:	88 0f       	add	r24, r24
    58d4:	99 1f       	adc	r25, r25
    58d6:	ac 01       	movw	r20, r24
    58d8:	42 1b       	sub	r20, r18
    58da:	53 0b       	sbc	r21, r19
    58dc:	9a 01       	movw	r18, r20
    58de:	8b 81       	ldd	r24, Y+3	; 0x03
    58e0:	9c 81       	ldd	r25, Y+4	; 0x04
    58e2:	82 0f       	add	r24, r18
    58e4:	93 1f       	adc	r25, r19
    58e6:	20 91 41 07 	lds	r18, 0x0741
    58ea:	30 91 42 07 	lds	r19, 0x0742
    58ee:	b9 01       	movw	r22, r18
    58f0:	42 e0       	ldi	r20, 0x02	; 2
    58f2:	0e 94 23 32 	call	0x6446	; 0x6446 <prvListTaskWithinSingleList>
    58f6:	98 2f       	mov	r25, r24
    58f8:	8a 81       	ldd	r24, Y+2	; 0x02
    58fa:	89 0f       	add	r24, r25
    58fc:	8a 83       	std	Y+2, r24	; 0x02
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    58fe:	8a 81       	ldd	r24, Y+2	; 0x02
    5900:	88 2f       	mov	r24, r24
    5902:	90 e0       	ldi	r25, 0x00	; 0
    5904:	9c 01       	movw	r18, r24
    5906:	22 0f       	add	r18, r18
    5908:	33 1f       	adc	r19, r19
    590a:	c9 01       	movw	r24, r18
    590c:	88 0f       	add	r24, r24
    590e:	99 1f       	adc	r25, r25
    5910:	88 0f       	add	r24, r24
    5912:	99 1f       	adc	r25, r25
    5914:	88 0f       	add	r24, r24
    5916:	99 1f       	adc	r25, r25
    5918:	ac 01       	movw	r20, r24
    591a:	42 1b       	sub	r20, r18
    591c:	53 0b       	sbc	r21, r19
    591e:	9a 01       	movw	r18, r20
    5920:	8b 81       	ldd	r24, Y+3	; 0x03
    5922:	9c 81       	ldd	r25, Y+4	; 0x04
    5924:	82 0f       	add	r24, r18
    5926:	93 1f       	adc	r25, r19
    5928:	20 91 43 07 	lds	r18, 0x0743
    592c:	30 91 44 07 	lds	r19, 0x0744
    5930:	b9 01       	movw	r22, r18
    5932:	42 e0       	ldi	r20, 0x02	; 2
    5934:	0e 94 23 32 	call	0x6446	; 0x6446 <prvListTaskWithinSingleList>
    5938:	98 2f       	mov	r25, r24
    593a:	8a 81       	ldd	r24, Y+2	; 0x02
    593c:	89 0f       	add	r24, r25
    593e:	8a 83       	std	Y+2, r24	; 0x02

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    5940:	8a 81       	ldd	r24, Y+2	; 0x02
    5942:	88 2f       	mov	r24, r24
    5944:	90 e0       	ldi	r25, 0x00	; 0
    5946:	9c 01       	movw	r18, r24
    5948:	22 0f       	add	r18, r18
    594a:	33 1f       	adc	r19, r19
    594c:	c9 01       	movw	r24, r18
    594e:	88 0f       	add	r24, r24
    5950:	99 1f       	adc	r25, r25
    5952:	88 0f       	add	r24, r24
    5954:	99 1f       	adc	r25, r25
    5956:	88 0f       	add	r24, r24
    5958:	99 1f       	adc	r25, r25
    595a:	ac 01       	movw	r20, r24
    595c:	42 1b       	sub	r20, r18
    595e:	53 0b       	sbc	r21, r19
    5960:	9a 01       	movw	r18, r20
    5962:	8b 81       	ldd	r24, Y+3	; 0x03
    5964:	9c 81       	ldd	r25, Y+4	; 0x04
    5966:	82 0f       	add	r24, r18
    5968:	93 1f       	adc	r25, r19
    596a:	2e e4       	ldi	r18, 0x4E	; 78
    596c:	37 e0       	ldi	r19, 0x07	; 7
    596e:	b9 01       	movw	r22, r18
    5970:	44 e0       	ldi	r20, 0x04	; 4
    5972:	0e 94 23 32 	call	0x6446	; 0x6446 <prvListTaskWithinSingleList>
    5976:	98 2f       	mov	r25, r24
    5978:	8a 81       	ldd	r24, Y+2	; 0x02
    597a:	89 0f       	add	r24, r25
    597c:	8a 83       	std	Y+2, r24	; 0x02

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    597e:	8a 81       	ldd	r24, Y+2	; 0x02
    5980:	88 2f       	mov	r24, r24
    5982:	90 e0       	ldi	r25, 0x00	; 0
    5984:	9c 01       	movw	r18, r24
    5986:	22 0f       	add	r18, r18
    5988:	33 1f       	adc	r19, r19
    598a:	c9 01       	movw	r24, r18
    598c:	88 0f       	add	r24, r24
    598e:	99 1f       	adc	r25, r25
    5990:	88 0f       	add	r24, r24
    5992:	99 1f       	adc	r25, r25
    5994:	88 0f       	add	r24, r24
    5996:	99 1f       	adc	r25, r25
    5998:	ac 01       	movw	r20, r24
    599a:	42 1b       	sub	r20, r18
    599c:	53 0b       	sbc	r21, r19
    599e:	9a 01       	movw	r18, r20
    59a0:	8b 81       	ldd	r24, Y+3	; 0x03
    59a2:	9c 81       	ldd	r25, Y+4	; 0x04
    59a4:	82 0f       	add	r24, r18
    59a6:	93 1f       	adc	r25, r19
    59a8:	27 e5       	ldi	r18, 0x57	; 87
    59aa:	37 e0       	ldi	r19, 0x07	; 7
    59ac:	b9 01       	movw	r22, r18
    59ae:	43 e0       	ldi	r20, 0x03	; 3
    59b0:	0e 94 23 32 	call	0x6446	; 0x6446 <prvListTaskWithinSingleList>
    59b4:	98 2f       	mov	r25, r24
    59b6:	8a 81       	ldd	r24, Y+2	; 0x02
    59b8:	89 0f       	add	r24, r25
    59ba:	8a 83       	std	Y+2, r24	; 0x02
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
    59bc:	8e 81       	ldd	r24, Y+6	; 0x06
    59be:	9f 81       	ldd	r25, Y+7	; 0x07
    59c0:	00 97       	sbiw	r24, 0x00	; 0
    59c2:	31 f0       	breq	.+12     	; 0x59d0 <uxTaskGetSystemState+0x1b0>
					{
						*pulTotalRunTime = 0;
    59c4:	ee 81       	ldd	r30, Y+6	; 0x06
    59c6:	ff 81       	ldd	r31, Y+7	; 0x07
    59c8:	10 82       	st	Z, r1
    59ca:	11 82       	std	Z+1, r1	; 0x01
    59cc:	12 82       	std	Z+2, r1	; 0x02
    59ce:	13 82       	std	Z+3, r1	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
    59d0:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>

		return uxTask;
    59d4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    59d6:	27 96       	adiw	r28, 0x07	; 7
    59d8:	0f b6       	in	r0, 0x3f	; 63
    59da:	f8 94       	cli
    59dc:	de bf       	out	0x3e, r29	; 62
    59de:	0f be       	out	0x3f, r0	; 63
    59e0:	cd bf       	out	0x3d, r28	; 61
    59e2:	cf 91       	pop	r28
    59e4:	df 91       	pop	r29
    59e6:	08 95       	ret

000059e8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    59e8:	df 93       	push	r29
    59ea:	cf 93       	push	r28
    59ec:	cd b7       	in	r28, 0x3d	; 61
    59ee:	de b7       	in	r29, 0x3e	; 62
    59f0:	29 97       	sbiw	r28, 0x09	; 9
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	de bf       	out	0x3e, r29	; 62
    59f8:	0f be       	out	0x3f, r0	; 63
    59fa:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    59fc:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59fe:	80 91 f8 06 	lds	r24, 0x06F8
    5a02:	88 23       	and	r24, r24
    5a04:	09 f0       	breq	.+2      	; 0x5a08 <xTaskIncrementTick+0x20>
    5a06:	c2 c0       	rjmp	.+388    	; 0x5b8c <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    5a08:	80 91 f0 06 	lds	r24, 0x06F0
    5a0c:	90 91 f1 06 	lds	r25, 0x06F1
    5a10:	01 96       	adiw	r24, 0x01	; 1
    5a12:	90 93 f1 06 	sts	0x06F1, r25
    5a16:	80 93 f0 06 	sts	0x06F0, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    5a1a:	80 91 f0 06 	lds	r24, 0x06F0
    5a1e:	90 91 f1 06 	lds	r25, 0x06F1
    5a22:	9c 83       	std	Y+4, r25	; 0x04
    5a24:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    5a26:	8b 81       	ldd	r24, Y+3	; 0x03
    5a28:	9c 81       	ldd	r25, Y+4	; 0x04
    5a2a:	00 97       	sbiw	r24, 0x00	; 0
    5a2c:	d9 f4       	brne	.+54     	; 0x5a64 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    5a2e:	80 91 41 07 	lds	r24, 0x0741
    5a32:	90 91 42 07 	lds	r25, 0x0742
    5a36:	9a 83       	std	Y+2, r25	; 0x02
    5a38:	89 83       	std	Y+1, r24	; 0x01
    5a3a:	80 91 43 07 	lds	r24, 0x0743
    5a3e:	90 91 44 07 	lds	r25, 0x0744
    5a42:	90 93 42 07 	sts	0x0742, r25
    5a46:	80 93 41 07 	sts	0x0741, r24
    5a4a:	89 81       	ldd	r24, Y+1	; 0x01
    5a4c:	9a 81       	ldd	r25, Y+2	; 0x02
    5a4e:	90 93 44 07 	sts	0x0744, r25
    5a52:	80 93 43 07 	sts	0x0743, r24
    5a56:	80 91 f6 06 	lds	r24, 0x06F6
    5a5a:	8f 5f       	subi	r24, 0xFF	; 255
    5a5c:	80 93 f6 06 	sts	0x06F6, r24
    5a60:	0e 94 e9 33 	call	0x67d2	; 0x67d2 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    5a64:	20 91 a6 00 	lds	r18, 0x00A6
    5a68:	30 91 a7 00 	lds	r19, 0x00A7
    5a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a70:	82 17       	cp	r24, r18
    5a72:	93 07       	cpc	r25, r19
    5a74:	08 f4       	brcc	.+2      	; 0x5a78 <xTaskIncrementTick+0x90>
    5a76:	71 c0       	rjmp	.+226    	; 0x5b5a <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5a78:	e0 91 41 07 	lds	r30, 0x0741
    5a7c:	f0 91 42 07 	lds	r31, 0x0742
    5a80:	80 81       	ld	r24, Z
    5a82:	88 23       	and	r24, r24
    5a84:	39 f4       	brne	.+14     	; 0x5a94 <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    5a86:	8f ef       	ldi	r24, 0xFF	; 255
    5a88:	9f ef       	ldi	r25, 0xFF	; 255
    5a8a:	90 93 a7 00 	sts	0x00A7, r25
    5a8e:	80 93 a6 00 	sts	0x00A6, r24
    5a92:	63 c0       	rjmp	.+198    	; 0x5b5a <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5a94:	e0 91 41 07 	lds	r30, 0x0741
    5a98:	f0 91 42 07 	lds	r31, 0x0742
    5a9c:	05 80       	ldd	r0, Z+5	; 0x05
    5a9e:	f6 81       	ldd	r31, Z+6	; 0x06
    5aa0:	e0 2d       	mov	r30, r0
    5aa2:	86 81       	ldd	r24, Z+6	; 0x06
    5aa4:	97 81       	ldd	r25, Z+7	; 0x07
    5aa6:	99 87       	std	Y+9, r25	; 0x09
    5aa8:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5aaa:	e8 85       	ldd	r30, Y+8	; 0x08
    5aac:	f9 85       	ldd	r31, Y+9	; 0x09
    5aae:	82 81       	ldd	r24, Z+2	; 0x02
    5ab0:	93 81       	ldd	r25, Z+3	; 0x03
    5ab2:	9f 83       	std	Y+7, r25	; 0x07
    5ab4:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    5ab6:	2b 81       	ldd	r18, Y+3	; 0x03
    5ab8:	3c 81       	ldd	r19, Y+4	; 0x04
    5aba:	8e 81       	ldd	r24, Y+6	; 0x06
    5abc:	9f 81       	ldd	r25, Y+7	; 0x07
    5abe:	28 17       	cp	r18, r24
    5ac0:	39 07       	cpc	r19, r25
    5ac2:	38 f4       	brcc	.+14     	; 0x5ad2 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    5ac4:	8e 81       	ldd	r24, Y+6	; 0x06
    5ac6:	9f 81       	ldd	r25, Y+7	; 0x07
    5ac8:	90 93 a7 00 	sts	0x00A7, r25
    5acc:	80 93 a6 00 	sts	0x00A6, r24
    5ad0:	44 c0       	rjmp	.+136    	; 0x5b5a <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    5ad2:	88 85       	ldd	r24, Y+8	; 0x08
    5ad4:	99 85       	ldd	r25, Y+9	; 0x09
    5ad6:	02 96       	adiw	r24, 0x02	; 2
    5ad8:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5adc:	e8 85       	ldd	r30, Y+8	; 0x08
    5ade:	f9 85       	ldd	r31, Y+9	; 0x09
    5ae0:	84 89       	ldd	r24, Z+20	; 0x14
    5ae2:	95 89       	ldd	r25, Z+21	; 0x15
    5ae4:	00 97       	sbiw	r24, 0x00	; 0
    5ae6:	29 f0       	breq	.+10     	; 0x5af2 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5ae8:	88 85       	ldd	r24, Y+8	; 0x08
    5aea:	99 85       	ldd	r25, Y+9	; 0x09
    5aec:	0c 96       	adiw	r24, 0x0c	; 12
    5aee:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    5af2:	e8 85       	ldd	r30, Y+8	; 0x08
    5af4:	f9 85       	ldd	r31, Y+9	; 0x09
    5af6:	96 89       	ldd	r25, Z+22	; 0x16
    5af8:	80 91 f2 06 	lds	r24, 0x06F2
    5afc:	89 17       	cp	r24, r25
    5afe:	28 f4       	brcc	.+10     	; 0x5b0a <xTaskIncrementTick+0x122>
    5b00:	e8 85       	ldd	r30, Y+8	; 0x08
    5b02:	f9 85       	ldd	r31, Y+9	; 0x09
    5b04:	86 89       	ldd	r24, Z+22	; 0x16
    5b06:	80 93 f2 06 	sts	0x06F2, r24
    5b0a:	e8 85       	ldd	r30, Y+8	; 0x08
    5b0c:	f9 85       	ldd	r31, Y+9	; 0x09
    5b0e:	86 89       	ldd	r24, Z+22	; 0x16
    5b10:	28 2f       	mov	r18, r24
    5b12:	30 e0       	ldi	r19, 0x00	; 0
    5b14:	c9 01       	movw	r24, r18
    5b16:	88 0f       	add	r24, r24
    5b18:	99 1f       	adc	r25, r25
    5b1a:	88 0f       	add	r24, r24
    5b1c:	99 1f       	adc	r25, r25
    5b1e:	88 0f       	add	r24, r24
    5b20:	99 1f       	adc	r25, r25
    5b22:	82 0f       	add	r24, r18
    5b24:	93 1f       	adc	r25, r19
    5b26:	ac 01       	movw	r20, r24
    5b28:	47 50       	subi	r20, 0x07	; 7
    5b2a:	59 4f       	sbci	r21, 0xF9	; 249
    5b2c:	88 85       	ldd	r24, Y+8	; 0x08
    5b2e:	99 85       	ldd	r25, Y+9	; 0x09
    5b30:	9c 01       	movw	r18, r24
    5b32:	2e 5f       	subi	r18, 0xFE	; 254
    5b34:	3f 4f       	sbci	r19, 0xFF	; 255
    5b36:	ca 01       	movw	r24, r20
    5b38:	b9 01       	movw	r22, r18
    5b3a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5b3e:	e8 85       	ldd	r30, Y+8	; 0x08
    5b40:	f9 85       	ldd	r31, Y+9	; 0x09
    5b42:	96 89       	ldd	r25, Z+22	; 0x16
    5b44:	e0 91 ec 06 	lds	r30, 0x06EC
    5b48:	f0 91 ed 06 	lds	r31, 0x06ED
    5b4c:	86 89       	ldd	r24, Z+22	; 0x16
    5b4e:	98 17       	cp	r25, r24
    5b50:	08 f4       	brcc	.+2      	; 0x5b54 <xTaskIncrementTick+0x16c>
    5b52:	92 cf       	rjmp	.-220    	; 0x5a78 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    5b54:	81 e0       	ldi	r24, 0x01	; 1
    5b56:	8d 83       	std	Y+5, r24	; 0x05
    5b58:	8f cf       	rjmp	.-226    	; 0x5a78 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5b5a:	e0 91 ec 06 	lds	r30, 0x06EC
    5b5e:	f0 91 ed 06 	lds	r31, 0x06ED
    5b62:	86 89       	ldd	r24, Z+22	; 0x16
    5b64:	28 2f       	mov	r18, r24
    5b66:	30 e0       	ldi	r19, 0x00	; 0
    5b68:	c9 01       	movw	r24, r18
    5b6a:	88 0f       	add	r24, r24
    5b6c:	99 1f       	adc	r25, r25
    5b6e:	88 0f       	add	r24, r24
    5b70:	99 1f       	adc	r25, r25
    5b72:	88 0f       	add	r24, r24
    5b74:	99 1f       	adc	r25, r25
    5b76:	82 0f       	add	r24, r18
    5b78:	93 1f       	adc	r25, r19
    5b7a:	fc 01       	movw	r30, r24
    5b7c:	e7 50       	subi	r30, 0x07	; 7
    5b7e:	f9 4f       	sbci	r31, 0xF9	; 249
    5b80:	80 81       	ld	r24, Z
    5b82:	82 30       	cpi	r24, 0x02	; 2
    5b84:	40 f0       	brcs	.+16     	; 0x5b96 <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    5b86:	81 e0       	ldi	r24, 0x01	; 1
    5b88:	8d 83       	std	Y+5, r24	; 0x05
    5b8a:	05 c0       	rjmp	.+10     	; 0x5b96 <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5b8c:	80 91 f4 06 	lds	r24, 0x06F4
    5b90:	8f 5f       	subi	r24, 0xFF	; 255
    5b92:	80 93 f4 06 	sts	0x06F4, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5b96:	80 91 f5 06 	lds	r24, 0x06F5
    5b9a:	88 23       	and	r24, r24
    5b9c:	11 f0       	breq	.+4      	; 0x5ba2 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    5b9e:	81 e0       	ldi	r24, 0x01	; 1
    5ba0:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    5ba2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5ba4:	29 96       	adiw	r28, 0x09	; 9
    5ba6:	0f b6       	in	r0, 0x3f	; 63
    5ba8:	f8 94       	cli
    5baa:	de bf       	out	0x3e, r29	; 62
    5bac:	0f be       	out	0x3f, r0	; 63
    5bae:	cd bf       	out	0x3d, r28	; 61
    5bb0:	cf 91       	pop	r28
    5bb2:	df 91       	pop	r29
    5bb4:	08 95       	ret

00005bb6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5bb6:	df 93       	push	r29
    5bb8:	cf 93       	push	r28
    5bba:	00 d0       	rcall	.+0      	; 0x5bbc <vTaskSwitchContext+0x6>
    5bbc:	cd b7       	in	r28, 0x3d	; 61
    5bbe:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5bc0:	80 91 f8 06 	lds	r24, 0x06F8
    5bc4:	88 23       	and	r24, r24
    5bc6:	21 f0       	breq	.+8      	; 0x5bd0 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5bc8:	81 e0       	ldi	r24, 0x01	; 1
    5bca:	80 93 f5 06 	sts	0x06F5, r24
    5bce:	57 c0       	rjmp	.+174    	; 0x5c7e <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    5bd0:	10 92 f5 06 	sts	0x06F5, r1
    5bd4:	05 c0       	rjmp	.+10     	; 0x5be0 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    5bd6:	80 91 f2 06 	lds	r24, 0x06F2
    5bda:	81 50       	subi	r24, 0x01	; 1
    5bdc:	80 93 f2 06 	sts	0x06F2, r24
    5be0:	80 91 f2 06 	lds	r24, 0x06F2
    5be4:	28 2f       	mov	r18, r24
    5be6:	30 e0       	ldi	r19, 0x00	; 0
    5be8:	c9 01       	movw	r24, r18
    5bea:	88 0f       	add	r24, r24
    5bec:	99 1f       	adc	r25, r25
    5bee:	88 0f       	add	r24, r24
    5bf0:	99 1f       	adc	r25, r25
    5bf2:	88 0f       	add	r24, r24
    5bf4:	99 1f       	adc	r25, r25
    5bf6:	82 0f       	add	r24, r18
    5bf8:	93 1f       	adc	r25, r19
    5bfa:	fc 01       	movw	r30, r24
    5bfc:	e7 50       	subi	r30, 0x07	; 7
    5bfe:	f9 4f       	sbci	r31, 0xF9	; 249
    5c00:	80 81       	ld	r24, Z
    5c02:	88 23       	and	r24, r24
    5c04:	41 f3       	breq	.-48     	; 0x5bd6 <vTaskSwitchContext+0x20>
    5c06:	80 91 f2 06 	lds	r24, 0x06F2
    5c0a:	28 2f       	mov	r18, r24
    5c0c:	30 e0       	ldi	r19, 0x00	; 0
    5c0e:	c9 01       	movw	r24, r18
    5c10:	88 0f       	add	r24, r24
    5c12:	99 1f       	adc	r25, r25
    5c14:	88 0f       	add	r24, r24
    5c16:	99 1f       	adc	r25, r25
    5c18:	88 0f       	add	r24, r24
    5c1a:	99 1f       	adc	r25, r25
    5c1c:	82 0f       	add	r24, r18
    5c1e:	93 1f       	adc	r25, r19
    5c20:	87 50       	subi	r24, 0x07	; 7
    5c22:	99 4f       	sbci	r25, 0xF9	; 249
    5c24:	9a 83       	std	Y+2, r25	; 0x02
    5c26:	89 83       	std	Y+1, r24	; 0x01
    5c28:	e9 81       	ldd	r30, Y+1	; 0x01
    5c2a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c2c:	01 80       	ldd	r0, Z+1	; 0x01
    5c2e:	f2 81       	ldd	r31, Z+2	; 0x02
    5c30:	e0 2d       	mov	r30, r0
    5c32:	82 81       	ldd	r24, Z+2	; 0x02
    5c34:	93 81       	ldd	r25, Z+3	; 0x03
    5c36:	e9 81       	ldd	r30, Y+1	; 0x01
    5c38:	fa 81       	ldd	r31, Y+2	; 0x02
    5c3a:	92 83       	std	Z+2, r25	; 0x02
    5c3c:	81 83       	std	Z+1, r24	; 0x01
    5c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c40:	fa 81       	ldd	r31, Y+2	; 0x02
    5c42:	21 81       	ldd	r18, Z+1	; 0x01
    5c44:	32 81       	ldd	r19, Z+2	; 0x02
    5c46:	89 81       	ldd	r24, Y+1	; 0x01
    5c48:	9a 81       	ldd	r25, Y+2	; 0x02
    5c4a:	03 96       	adiw	r24, 0x03	; 3
    5c4c:	28 17       	cp	r18, r24
    5c4e:	39 07       	cpc	r19, r25
    5c50:	59 f4       	brne	.+22     	; 0x5c68 <vTaskSwitchContext+0xb2>
    5c52:	e9 81       	ldd	r30, Y+1	; 0x01
    5c54:	fa 81       	ldd	r31, Y+2	; 0x02
    5c56:	01 80       	ldd	r0, Z+1	; 0x01
    5c58:	f2 81       	ldd	r31, Z+2	; 0x02
    5c5a:	e0 2d       	mov	r30, r0
    5c5c:	82 81       	ldd	r24, Z+2	; 0x02
    5c5e:	93 81       	ldd	r25, Z+3	; 0x03
    5c60:	e9 81       	ldd	r30, Y+1	; 0x01
    5c62:	fa 81       	ldd	r31, Y+2	; 0x02
    5c64:	92 83       	std	Z+2, r25	; 0x02
    5c66:	81 83       	std	Z+1, r24	; 0x01
    5c68:	e9 81       	ldd	r30, Y+1	; 0x01
    5c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c6c:	01 80       	ldd	r0, Z+1	; 0x01
    5c6e:	f2 81       	ldd	r31, Z+2	; 0x02
    5c70:	e0 2d       	mov	r30, r0
    5c72:	86 81       	ldd	r24, Z+6	; 0x06
    5c74:	97 81       	ldd	r25, Z+7	; 0x07
    5c76:	90 93 ed 06 	sts	0x06ED, r25
    5c7a:	80 93 ec 06 	sts	0x06EC, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5c7e:	0f 90       	pop	r0
    5c80:	0f 90       	pop	r0
    5c82:	cf 91       	pop	r28
    5c84:	df 91       	pop	r29
    5c86:	08 95       	ret

00005c88 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5c88:	df 93       	push	r29
    5c8a:	cf 93       	push	r28
    5c8c:	00 d0       	rcall	.+0      	; 0x5c8e <vTaskPlaceOnEventList+0x6>
    5c8e:	00 d0       	rcall	.+0      	; 0x5c90 <vTaskPlaceOnEventList+0x8>
    5c90:	00 d0       	rcall	.+0      	; 0x5c92 <vTaskPlaceOnEventList+0xa>
    5c92:	cd b7       	in	r28, 0x3d	; 61
    5c94:	de b7       	in	r29, 0x3e	; 62
    5c96:	9c 83       	std	Y+4, r25	; 0x04
    5c98:	8b 83       	std	Y+3, r24	; 0x03
    5c9a:	7e 83       	std	Y+6, r23	; 0x06
    5c9c:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5c9e:	80 91 ec 06 	lds	r24, 0x06EC
    5ca2:	90 91 ed 06 	lds	r25, 0x06ED
    5ca6:	9c 01       	movw	r18, r24
    5ca8:	24 5f       	subi	r18, 0xF4	; 244
    5caa:	3f 4f       	sbci	r19, 0xFF	; 255
    5cac:	8b 81       	ldd	r24, Y+3	; 0x03
    5cae:	9c 81       	ldd	r25, Y+4	; 0x04
    5cb0:	b9 01       	movw	r22, r18
    5cb2:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5cb6:	80 91 ec 06 	lds	r24, 0x06EC
    5cba:	90 91 ed 06 	lds	r25, 0x06ED
    5cbe:	02 96       	adiw	r24, 0x02	; 2
    5cc0:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    5cc4:	8d 81       	ldd	r24, Y+5	; 0x05
    5cc6:	9e 81       	ldd	r25, Y+6	; 0x06
    5cc8:	2f ef       	ldi	r18, 0xFF	; 255
    5cca:	8f 3f       	cpi	r24, 0xFF	; 255
    5ccc:	92 07       	cpc	r25, r18
    5cce:	69 f4       	brne	.+26     	; 0x5cea <vTaskPlaceOnEventList+0x62>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5cd0:	80 91 ec 06 	lds	r24, 0x06EC
    5cd4:	90 91 ed 06 	lds	r25, 0x06ED
    5cd8:	9c 01       	movw	r18, r24
    5cda:	2e 5f       	subi	r18, 0xFE	; 254
    5cdc:	3f 4f       	sbci	r19, 0xFF	; 255
    5cde:	87 e5       	ldi	r24, 0x57	; 87
    5ce0:	97 e0       	ldi	r25, 0x07	; 7
    5ce2:	b9 01       	movw	r22, r18
    5ce4:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
    5ce8:	0e c0       	rjmp	.+28     	; 0x5d06 <vTaskPlaceOnEventList+0x7e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    5cea:	20 91 f0 06 	lds	r18, 0x06F0
    5cee:	30 91 f1 06 	lds	r19, 0x06F1
    5cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    5cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    5cf6:	82 0f       	add	r24, r18
    5cf8:	93 1f       	adc	r25, r19
    5cfa:	9a 83       	std	Y+2, r25	; 0x02
    5cfc:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5cfe:	89 81       	ldd	r24, Y+1	; 0x01
    5d00:	9a 81       	ldd	r25, Y+2	; 0x02
    5d02:	0e 94 8a 31 	call	0x6314	; 0x6314 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5d06:	26 96       	adiw	r28, 0x06	; 6
    5d08:	0f b6       	in	r0, 0x3f	; 63
    5d0a:	f8 94       	cli
    5d0c:	de bf       	out	0x3e, r29	; 62
    5d0e:	0f be       	out	0x3f, r0	; 63
    5d10:	cd bf       	out	0x3d, r28	; 61
    5d12:	cf 91       	pop	r28
    5d14:	df 91       	pop	r29
    5d16:	08 95       	ret

00005d18 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5d18:	df 93       	push	r29
    5d1a:	cf 93       	push	r28
    5d1c:	cd b7       	in	r28, 0x3d	; 61
    5d1e:	de b7       	in	r29, 0x3e	; 62
    5d20:	28 97       	sbiw	r28, 0x08	; 8
    5d22:	0f b6       	in	r0, 0x3f	; 63
    5d24:	f8 94       	cli
    5d26:	de bf       	out	0x3e, r29	; 62
    5d28:	0f be       	out	0x3f, r0	; 63
    5d2a:	cd bf       	out	0x3d, r28	; 61
    5d2c:	9c 83       	std	Y+4, r25	; 0x04
    5d2e:	8b 83       	std	Y+3, r24	; 0x03
    5d30:	7e 83       	std	Y+6, r23	; 0x06
    5d32:	6d 83       	std	Y+5, r22	; 0x05
    5d34:	58 87       	std	Y+8, r21	; 0x08
    5d36:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5d38:	e0 91 ec 06 	lds	r30, 0x06EC
    5d3c:	f0 91 ed 06 	lds	r31, 0x06ED
    5d40:	8d 81       	ldd	r24, Y+5	; 0x05
    5d42:	9e 81       	ldd	r25, Y+6	; 0x06
    5d44:	90 68       	ori	r25, 0x80	; 128
    5d46:	95 87       	std	Z+13, r25	; 0x0d
    5d48:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5d4a:	80 91 ec 06 	lds	r24, 0x06EC
    5d4e:	90 91 ed 06 	lds	r25, 0x06ED
    5d52:	9c 01       	movw	r18, r24
    5d54:	24 5f       	subi	r18, 0xF4	; 244
    5d56:	3f 4f       	sbci	r19, 0xFF	; 255
    5d58:	8b 81       	ldd	r24, Y+3	; 0x03
    5d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d5c:	b9 01       	movw	r22, r18
    5d5e:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    5d62:	80 91 ec 06 	lds	r24, 0x06EC
    5d66:	90 91 ed 06 	lds	r25, 0x06ED
    5d6a:	02 96       	adiw	r24, 0x02	; 2
    5d6c:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    5d70:	8f 81       	ldd	r24, Y+7	; 0x07
    5d72:	98 85       	ldd	r25, Y+8	; 0x08
    5d74:	2f ef       	ldi	r18, 0xFF	; 255
    5d76:	8f 3f       	cpi	r24, 0xFF	; 255
    5d78:	92 07       	cpc	r25, r18
    5d7a:	69 f4       	brne	.+26     	; 0x5d96 <vTaskPlaceOnUnorderedEventList+0x7e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    5d7c:	80 91 ec 06 	lds	r24, 0x06EC
    5d80:	90 91 ed 06 	lds	r25, 0x06ED
    5d84:	9c 01       	movw	r18, r24
    5d86:	2e 5f       	subi	r18, 0xFE	; 254
    5d88:	3f 4f       	sbci	r19, 0xFF	; 255
    5d8a:	87 e5       	ldi	r24, 0x57	; 87
    5d8c:	97 e0       	ldi	r25, 0x07	; 7
    5d8e:	b9 01       	movw	r22, r18
    5d90:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
    5d94:	0e c0       	rjmp	.+28     	; 0x5db2 <vTaskPlaceOnUnorderedEventList+0x9a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    5d96:	20 91 f0 06 	lds	r18, 0x06F0
    5d9a:	30 91 f1 06 	lds	r19, 0x06F1
    5d9e:	8f 81       	ldd	r24, Y+7	; 0x07
    5da0:	98 85       	ldd	r25, Y+8	; 0x08
    5da2:	82 0f       	add	r24, r18
    5da4:	93 1f       	adc	r25, r19
    5da6:	9a 83       	std	Y+2, r25	; 0x02
    5da8:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    5daa:	89 81       	ldd	r24, Y+1	; 0x01
    5dac:	9a 81       	ldd	r25, Y+2	; 0x02
    5dae:	0e 94 8a 31 	call	0x6314	; 0x6314 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5db2:	28 96       	adiw	r28, 0x08	; 8
    5db4:	0f b6       	in	r0, 0x3f	; 63
    5db6:	f8 94       	cli
    5db8:	de bf       	out	0x3e, r29	; 62
    5dba:	0f be       	out	0x3f, r0	; 63
    5dbc:	cd bf       	out	0x3d, r28	; 61
    5dbe:	cf 91       	pop	r28
    5dc0:	df 91       	pop	r29
    5dc2:	08 95       	ret

00005dc4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5dc4:	df 93       	push	r29
    5dc6:	cf 93       	push	r28
    5dc8:	00 d0       	rcall	.+0      	; 0x5dca <xTaskRemoveFromEventList+0x6>
    5dca:	00 d0       	rcall	.+0      	; 0x5dcc <xTaskRemoveFromEventList+0x8>
    5dcc:	0f 92       	push	r0
    5dce:	cd b7       	in	r28, 0x3d	; 61
    5dd0:	de b7       	in	r29, 0x3e	; 62
    5dd2:	9d 83       	std	Y+5, r25	; 0x05
    5dd4:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5dd6:	ec 81       	ldd	r30, Y+4	; 0x04
    5dd8:	fd 81       	ldd	r31, Y+5	; 0x05
    5dda:	05 80       	ldd	r0, Z+5	; 0x05
    5ddc:	f6 81       	ldd	r31, Z+6	; 0x06
    5dde:	e0 2d       	mov	r30, r0
    5de0:	86 81       	ldd	r24, Z+6	; 0x06
    5de2:	97 81       	ldd	r25, Z+7	; 0x07
    5de4:	9b 83       	std	Y+3, r25	; 0x03
    5de6:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5de8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dea:	9b 81       	ldd	r25, Y+3	; 0x03
    5dec:	0c 96       	adiw	r24, 0x0c	; 12
    5dee:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5df2:	80 91 f8 06 	lds	r24, 0x06F8
    5df6:	88 23       	and	r24, r24
    5df8:	61 f5       	brne	.+88     	; 0x5e52 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5dfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5dfc:	9b 81       	ldd	r25, Y+3	; 0x03
    5dfe:	02 96       	adiw	r24, 0x02	; 2
    5e00:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5e04:	ea 81       	ldd	r30, Y+2	; 0x02
    5e06:	fb 81       	ldd	r31, Y+3	; 0x03
    5e08:	96 89       	ldd	r25, Z+22	; 0x16
    5e0a:	80 91 f2 06 	lds	r24, 0x06F2
    5e0e:	89 17       	cp	r24, r25
    5e10:	28 f4       	brcc	.+10     	; 0x5e1c <xTaskRemoveFromEventList+0x58>
    5e12:	ea 81       	ldd	r30, Y+2	; 0x02
    5e14:	fb 81       	ldd	r31, Y+3	; 0x03
    5e16:	86 89       	ldd	r24, Z+22	; 0x16
    5e18:	80 93 f2 06 	sts	0x06F2, r24
    5e1c:	ea 81       	ldd	r30, Y+2	; 0x02
    5e1e:	fb 81       	ldd	r31, Y+3	; 0x03
    5e20:	86 89       	ldd	r24, Z+22	; 0x16
    5e22:	28 2f       	mov	r18, r24
    5e24:	30 e0       	ldi	r19, 0x00	; 0
    5e26:	c9 01       	movw	r24, r18
    5e28:	88 0f       	add	r24, r24
    5e2a:	99 1f       	adc	r25, r25
    5e2c:	88 0f       	add	r24, r24
    5e2e:	99 1f       	adc	r25, r25
    5e30:	88 0f       	add	r24, r24
    5e32:	99 1f       	adc	r25, r25
    5e34:	82 0f       	add	r24, r18
    5e36:	93 1f       	adc	r25, r19
    5e38:	ac 01       	movw	r20, r24
    5e3a:	47 50       	subi	r20, 0x07	; 7
    5e3c:	59 4f       	sbci	r21, 0xF9	; 249
    5e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e40:	9b 81       	ldd	r25, Y+3	; 0x03
    5e42:	9c 01       	movw	r18, r24
    5e44:	2e 5f       	subi	r18, 0xFE	; 254
    5e46:	3f 4f       	sbci	r19, 0xFF	; 255
    5e48:	ca 01       	movw	r24, r20
    5e4a:	b9 01       	movw	r22, r18
    5e4c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
    5e50:	0a c0       	rjmp	.+20     	; 0x5e66 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5e52:	8a 81       	ldd	r24, Y+2	; 0x02
    5e54:	9b 81       	ldd	r25, Y+3	; 0x03
    5e56:	9c 01       	movw	r18, r24
    5e58:	24 5f       	subi	r18, 0xF4	; 244
    5e5a:	3f 4f       	sbci	r19, 0xFF	; 255
    5e5c:	85 e4       	ldi	r24, 0x45	; 69
    5e5e:	97 e0       	ldi	r25, 0x07	; 7
    5e60:	b9 01       	movw	r22, r18
    5e62:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5e66:	ea 81       	ldd	r30, Y+2	; 0x02
    5e68:	fb 81       	ldd	r31, Y+3	; 0x03
    5e6a:	96 89       	ldd	r25, Z+22	; 0x16
    5e6c:	e0 91 ec 06 	lds	r30, 0x06EC
    5e70:	f0 91 ed 06 	lds	r31, 0x06ED
    5e74:	86 89       	ldd	r24, Z+22	; 0x16
    5e76:	89 17       	cp	r24, r25
    5e78:	30 f4       	brcc	.+12     	; 0x5e86 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5e7a:	81 e0       	ldi	r24, 0x01	; 1
    5e7c:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5e7e:	81 e0       	ldi	r24, 0x01	; 1
    5e80:	80 93 f5 06 	sts	0x06F5, r24
    5e84:	01 c0       	rjmp	.+2      	; 0x5e88 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5e86:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5e88:	89 81       	ldd	r24, Y+1	; 0x01
}
    5e8a:	0f 90       	pop	r0
    5e8c:	0f 90       	pop	r0
    5e8e:	0f 90       	pop	r0
    5e90:	0f 90       	pop	r0
    5e92:	0f 90       	pop	r0
    5e94:	cf 91       	pop	r28
    5e96:	df 91       	pop	r29
    5e98:	08 95       	ret

00005e9a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5e9a:	df 93       	push	r29
    5e9c:	cf 93       	push	r28
    5e9e:	cd b7       	in	r28, 0x3d	; 61
    5ea0:	de b7       	in	r29, 0x3e	; 62
    5ea2:	27 97       	sbiw	r28, 0x07	; 7
    5ea4:	0f b6       	in	r0, 0x3f	; 63
    5ea6:	f8 94       	cli
    5ea8:	de bf       	out	0x3e, r29	; 62
    5eaa:	0f be       	out	0x3f, r0	; 63
    5eac:	cd bf       	out	0x3d, r28	; 61
    5eae:	9d 83       	std	Y+5, r25	; 0x05
    5eb0:	8c 83       	std	Y+4, r24	; 0x04
    5eb2:	7f 83       	std	Y+7, r23	; 0x07
    5eb4:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5eb6:	8e 81       	ldd	r24, Y+6	; 0x06
    5eb8:	9f 81       	ldd	r25, Y+7	; 0x07
    5eba:	90 68       	ori	r25, 0x80	; 128
    5ebc:	ec 81       	ldd	r30, Y+4	; 0x04
    5ebe:	fd 81       	ldd	r31, Y+5	; 0x05
    5ec0:	91 83       	std	Z+1, r25	; 0x01
    5ec2:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    5ec4:	ec 81       	ldd	r30, Y+4	; 0x04
    5ec6:	fd 81       	ldd	r31, Y+5	; 0x05
    5ec8:	86 81       	ldd	r24, Z+6	; 0x06
    5eca:	97 81       	ldd	r25, Z+7	; 0x07
    5ecc:	9b 83       	std	Y+3, r25	; 0x03
    5ece:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5ed0:	8c 81       	ldd	r24, Y+4	; 0x04
    5ed2:	9d 81       	ldd	r25, Y+5	; 0x05
    5ed4:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eda:	9b 81       	ldd	r25, Y+3	; 0x03
    5edc:	02 96       	adiw	r24, 0x02	; 2
    5ede:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5ee2:	ea 81       	ldd	r30, Y+2	; 0x02
    5ee4:	fb 81       	ldd	r31, Y+3	; 0x03
    5ee6:	96 89       	ldd	r25, Z+22	; 0x16
    5ee8:	80 91 f2 06 	lds	r24, 0x06F2
    5eec:	89 17       	cp	r24, r25
    5eee:	28 f4       	brcc	.+10     	; 0x5efa <xTaskRemoveFromUnorderedEventList+0x60>
    5ef0:	ea 81       	ldd	r30, Y+2	; 0x02
    5ef2:	fb 81       	ldd	r31, Y+3	; 0x03
    5ef4:	86 89       	ldd	r24, Z+22	; 0x16
    5ef6:	80 93 f2 06 	sts	0x06F2, r24
    5efa:	ea 81       	ldd	r30, Y+2	; 0x02
    5efc:	fb 81       	ldd	r31, Y+3	; 0x03
    5efe:	86 89       	ldd	r24, Z+22	; 0x16
    5f00:	28 2f       	mov	r18, r24
    5f02:	30 e0       	ldi	r19, 0x00	; 0
    5f04:	c9 01       	movw	r24, r18
    5f06:	88 0f       	add	r24, r24
    5f08:	99 1f       	adc	r25, r25
    5f0a:	88 0f       	add	r24, r24
    5f0c:	99 1f       	adc	r25, r25
    5f0e:	88 0f       	add	r24, r24
    5f10:	99 1f       	adc	r25, r25
    5f12:	82 0f       	add	r24, r18
    5f14:	93 1f       	adc	r25, r19
    5f16:	ac 01       	movw	r20, r24
    5f18:	47 50       	subi	r20, 0x07	; 7
    5f1a:	59 4f       	sbci	r21, 0xF9	; 249
    5f1c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f1e:	9b 81       	ldd	r25, Y+3	; 0x03
    5f20:	9c 01       	movw	r18, r24
    5f22:	2e 5f       	subi	r18, 0xFE	; 254
    5f24:	3f 4f       	sbci	r19, 0xFF	; 255
    5f26:	ca 01       	movw	r24, r20
    5f28:	b9 01       	movw	r22, r18
    5f2a:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5f2e:	ea 81       	ldd	r30, Y+2	; 0x02
    5f30:	fb 81       	ldd	r31, Y+3	; 0x03
    5f32:	96 89       	ldd	r25, Z+22	; 0x16
    5f34:	e0 91 ec 06 	lds	r30, 0x06EC
    5f38:	f0 91 ed 06 	lds	r31, 0x06ED
    5f3c:	86 89       	ldd	r24, Z+22	; 0x16
    5f3e:	89 17       	cp	r24, r25
    5f40:	30 f4       	brcc	.+12     	; 0x5f4e <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    5f42:	81 e0       	ldi	r24, 0x01	; 1
    5f44:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5f46:	81 e0       	ldi	r24, 0x01	; 1
    5f48:	80 93 f5 06 	sts	0x06F5, r24
    5f4c:	01 c0       	rjmp	.+2      	; 0x5f50 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    5f4e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5f50:	89 81       	ldd	r24, Y+1	; 0x01
}
    5f52:	27 96       	adiw	r28, 0x07	; 7
    5f54:	0f b6       	in	r0, 0x3f	; 63
    5f56:	f8 94       	cli
    5f58:	de bf       	out	0x3e, r29	; 62
    5f5a:	0f be       	out	0x3f, r0	; 63
    5f5c:	cd bf       	out	0x3d, r28	; 61
    5f5e:	cf 91       	pop	r28
    5f60:	df 91       	pop	r29
    5f62:	08 95       	ret

00005f64 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5f64:	df 93       	push	r29
    5f66:	cf 93       	push	r28
    5f68:	00 d0       	rcall	.+0      	; 0x5f6a <vTaskSetTimeOutState+0x6>
    5f6a:	cd b7       	in	r28, 0x3d	; 61
    5f6c:	de b7       	in	r29, 0x3e	; 62
    5f6e:	9a 83       	std	Y+2, r25	; 0x02
    5f70:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5f72:	80 91 f6 06 	lds	r24, 0x06F6
    5f76:	e9 81       	ldd	r30, Y+1	; 0x01
    5f78:	fa 81       	ldd	r31, Y+2	; 0x02
    5f7a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5f7c:	80 91 f0 06 	lds	r24, 0x06F0
    5f80:	90 91 f1 06 	lds	r25, 0x06F1
    5f84:	e9 81       	ldd	r30, Y+1	; 0x01
    5f86:	fa 81       	ldd	r31, Y+2	; 0x02
    5f88:	92 83       	std	Z+2, r25	; 0x02
    5f8a:	81 83       	std	Z+1, r24	; 0x01
}
    5f8c:	0f 90       	pop	r0
    5f8e:	0f 90       	pop	r0
    5f90:	cf 91       	pop	r28
    5f92:	df 91       	pop	r29
    5f94:	08 95       	ret

00005f96 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5f96:	df 93       	push	r29
    5f98:	cf 93       	push	r28
    5f9a:	cd b7       	in	r28, 0x3d	; 61
    5f9c:	de b7       	in	r29, 0x3e	; 62
    5f9e:	27 97       	sbiw	r28, 0x07	; 7
    5fa0:	0f b6       	in	r0, 0x3f	; 63
    5fa2:	f8 94       	cli
    5fa4:	de bf       	out	0x3e, r29	; 62
    5fa6:	0f be       	out	0x3f, r0	; 63
    5fa8:	cd bf       	out	0x3d, r28	; 61
    5faa:	9d 83       	std	Y+5, r25	; 0x05
    5fac:	8c 83       	std	Y+4, r24	; 0x04
    5fae:	7f 83       	std	Y+7, r23	; 0x07
    5fb0:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5fb2:	0f b6       	in	r0, 0x3f	; 63
    5fb4:	f8 94       	cli
    5fb6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5fb8:	80 91 f0 06 	lds	r24, 0x06F0
    5fbc:	90 91 f1 06 	lds	r25, 0x06F1
    5fc0:	9a 83       	std	Y+2, r25	; 0x02
    5fc2:	89 83       	std	Y+1, r24	; 0x01

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    5fc4:	ee 81       	ldd	r30, Y+6	; 0x06
    5fc6:	ff 81       	ldd	r31, Y+7	; 0x07
    5fc8:	80 81       	ld	r24, Z
    5fca:	91 81       	ldd	r25, Z+1	; 0x01
    5fcc:	2f ef       	ldi	r18, 0xFF	; 255
    5fce:	8f 3f       	cpi	r24, 0xFF	; 255
    5fd0:	92 07       	cpc	r25, r18
    5fd2:	11 f4       	brne	.+4      	; 0x5fd8 <xTaskCheckForTimeOut+0x42>
			{
				xReturn = pdFALSE;
    5fd4:	1b 82       	std	Y+3, r1	; 0x03
    5fd6:	40 c0       	rjmp	.+128    	; 0x6058 <xTaskCheckForTimeOut+0xc2>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5fd8:	ec 81       	ldd	r30, Y+4	; 0x04
    5fda:	fd 81       	ldd	r31, Y+5	; 0x05
    5fdc:	90 81       	ld	r25, Z
    5fde:	80 91 f6 06 	lds	r24, 0x06F6
    5fe2:	98 17       	cp	r25, r24
    5fe4:	61 f0       	breq	.+24     	; 0x5ffe <xTaskCheckForTimeOut+0x68>
    5fe6:	ec 81       	ldd	r30, Y+4	; 0x04
    5fe8:	fd 81       	ldd	r31, Y+5	; 0x05
    5fea:	21 81       	ldd	r18, Z+1	; 0x01
    5fec:	32 81       	ldd	r19, Z+2	; 0x02
    5fee:	89 81       	ldd	r24, Y+1	; 0x01
    5ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    5ff2:	82 17       	cp	r24, r18
    5ff4:	93 07       	cpc	r25, r19
    5ff6:	18 f0       	brcs	.+6      	; 0x5ffe <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5ff8:	81 e0       	ldi	r24, 0x01	; 1
    5ffa:	8b 83       	std	Y+3, r24	; 0x03
    5ffc:	2d c0       	rjmp	.+90     	; 0x6058 <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    5ffe:	ec 81       	ldd	r30, Y+4	; 0x04
    6000:	fd 81       	ldd	r31, Y+5	; 0x05
    6002:	21 81       	ldd	r18, Z+1	; 0x01
    6004:	32 81       	ldd	r19, Z+2	; 0x02
    6006:	89 81       	ldd	r24, Y+1	; 0x01
    6008:	9a 81       	ldd	r25, Y+2	; 0x02
    600a:	ac 01       	movw	r20, r24
    600c:	42 1b       	sub	r20, r18
    600e:	53 0b       	sbc	r21, r19
    6010:	9a 01       	movw	r18, r20
    6012:	ee 81       	ldd	r30, Y+6	; 0x06
    6014:	ff 81       	ldd	r31, Y+7	; 0x07
    6016:	80 81       	ld	r24, Z
    6018:	91 81       	ldd	r25, Z+1	; 0x01
    601a:	28 17       	cp	r18, r24
    601c:	39 07       	cpc	r19, r25
    601e:	d0 f4       	brcc	.+52     	; 0x6054 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    6020:	ee 81       	ldd	r30, Y+6	; 0x06
    6022:	ff 81       	ldd	r31, Y+7	; 0x07
    6024:	40 81       	ld	r20, Z
    6026:	51 81       	ldd	r21, Z+1	; 0x01
    6028:	ec 81       	ldd	r30, Y+4	; 0x04
    602a:	fd 81       	ldd	r31, Y+5	; 0x05
    602c:	21 81       	ldd	r18, Z+1	; 0x01
    602e:	32 81       	ldd	r19, Z+2	; 0x02
    6030:	89 81       	ldd	r24, Y+1	; 0x01
    6032:	9a 81       	ldd	r25, Y+2	; 0x02
    6034:	b9 01       	movw	r22, r18
    6036:	68 1b       	sub	r22, r24
    6038:	79 0b       	sbc	r23, r25
    603a:	cb 01       	movw	r24, r22
    603c:	84 0f       	add	r24, r20
    603e:	95 1f       	adc	r25, r21
    6040:	ee 81       	ldd	r30, Y+6	; 0x06
    6042:	ff 81       	ldd	r31, Y+7	; 0x07
    6044:	91 83       	std	Z+1, r25	; 0x01
    6046:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    6048:	8c 81       	ldd	r24, Y+4	; 0x04
    604a:	9d 81       	ldd	r25, Y+5	; 0x05
    604c:	0e 94 b2 2f 	call	0x5f64	; 0x5f64 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    6050:	1b 82       	std	Y+3, r1	; 0x03
    6052:	02 c0       	rjmp	.+4      	; 0x6058 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    6054:	81 e0       	ldi	r24, 0x01	; 1
    6056:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    6058:	0f 90       	pop	r0
    605a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    605c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    605e:	27 96       	adiw	r28, 0x07	; 7
    6060:	0f b6       	in	r0, 0x3f	; 63
    6062:	f8 94       	cli
    6064:	de bf       	out	0x3e, r29	; 62
    6066:	0f be       	out	0x3f, r0	; 63
    6068:	cd bf       	out	0x3d, r28	; 61
    606a:	cf 91       	pop	r28
    606c:	df 91       	pop	r29
    606e:	08 95       	ret

00006070 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6070:	df 93       	push	r29
    6072:	cf 93       	push	r28
    6074:	cd b7       	in	r28, 0x3d	; 61
    6076:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    6078:	81 e0       	ldi	r24, 0x01	; 1
    607a:	80 93 f5 06 	sts	0x06F5, r24
}
    607e:	cf 91       	pop	r28
    6080:	df 91       	pop	r29
    6082:	08 95       	ret

00006084 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
    6084:	df 93       	push	r29
    6086:	cf 93       	push	r28
    6088:	00 d0       	rcall	.+0      	; 0x608a <uxTaskGetTaskNumber+0x6>
    608a:	00 d0       	rcall	.+0      	; 0x608c <uxTaskGetTaskNumber+0x8>
    608c:	0f 92       	push	r0
    608e:	cd b7       	in	r28, 0x3d	; 61
    6090:	de b7       	in	r29, 0x3e	; 62
    6092:	9d 83       	std	Y+5, r25	; 0x05
    6094:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxReturn;
	TCB_t *pxTCB;

		if( xTask != NULL )
    6096:	8c 81       	ldd	r24, Y+4	; 0x04
    6098:	9d 81       	ldd	r25, Y+5	; 0x05
    609a:	00 97       	sbiw	r24, 0x00	; 0
    609c:	49 f0       	breq	.+18     	; 0x60b0 <uxTaskGetTaskNumber+0x2c>
		{
			pxTCB = ( TCB_t * ) xTask;
    609e:	8c 81       	ldd	r24, Y+4	; 0x04
    60a0:	9d 81       	ldd	r25, Y+5	; 0x05
    60a2:	9a 83       	std	Y+2, r25	; 0x02
    60a4:	89 83       	std	Y+1, r24	; 0x01
			uxReturn = pxTCB->uxTaskNumber;
    60a6:	e9 81       	ldd	r30, Y+1	; 0x01
    60a8:	fa 81       	ldd	r31, Y+2	; 0x02
    60aa:	86 a5       	ldd	r24, Z+46	; 0x2e
    60ac:	8b 83       	std	Y+3, r24	; 0x03
    60ae:	01 c0       	rjmp	.+2      	; 0x60b2 <uxTaskGetTaskNumber+0x2e>
		}
		else
		{
			uxReturn = 0U;
    60b0:	1b 82       	std	Y+3, r1	; 0x03
		}

		return uxReturn;
    60b2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    60b4:	0f 90       	pop	r0
    60b6:	0f 90       	pop	r0
    60b8:	0f 90       	pop	r0
    60ba:	0f 90       	pop	r0
    60bc:	0f 90       	pop	r0
    60be:	cf 91       	pop	r28
    60c0:	df 91       	pop	r29
    60c2:	08 95       	ret

000060c4 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
    60c4:	df 93       	push	r29
    60c6:	cf 93       	push	r28
    60c8:	00 d0       	rcall	.+0      	; 0x60ca <vTaskSetTaskNumber+0x6>
    60ca:	00 d0       	rcall	.+0      	; 0x60cc <vTaskSetTaskNumber+0x8>
    60cc:	0f 92       	push	r0
    60ce:	cd b7       	in	r28, 0x3d	; 61
    60d0:	de b7       	in	r29, 0x3e	; 62
    60d2:	9c 83       	std	Y+4, r25	; 0x04
    60d4:	8b 83       	std	Y+3, r24	; 0x03
    60d6:	6d 83       	std	Y+5, r22	; 0x05
	TCB_t *pxTCB;

		if( xTask != NULL )
    60d8:	8b 81       	ldd	r24, Y+3	; 0x03
    60da:	9c 81       	ldd	r25, Y+4	; 0x04
    60dc:	00 97       	sbiw	r24, 0x00	; 0
    60de:	41 f0       	breq	.+16     	; 0x60f0 <vTaskSetTaskNumber+0x2c>
		{
			pxTCB = ( TCB_t * ) xTask;
    60e0:	8b 81       	ldd	r24, Y+3	; 0x03
    60e2:	9c 81       	ldd	r25, Y+4	; 0x04
    60e4:	9a 83       	std	Y+2, r25	; 0x02
    60e6:	89 83       	std	Y+1, r24	; 0x01
			pxTCB->uxTaskNumber = uxHandle;
    60e8:	e9 81       	ldd	r30, Y+1	; 0x01
    60ea:	fa 81       	ldd	r31, Y+2	; 0x02
    60ec:	8d 81       	ldd	r24, Y+5	; 0x05
    60ee:	86 a7       	std	Z+46, r24	; 0x2e
		}
	}
    60f0:	0f 90       	pop	r0
    60f2:	0f 90       	pop	r0
    60f4:	0f 90       	pop	r0
    60f6:	0f 90       	pop	r0
    60f8:	0f 90       	pop	r0
    60fa:	cf 91       	pop	r28
    60fc:	df 91       	pop	r29
    60fe:	08 95       	ret

00006100 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6100:	df 93       	push	r29
    6102:	cf 93       	push	r28
    6104:	00 d0       	rcall	.+0      	; 0x6106 <prvIdleTask+0x6>
    6106:	cd b7       	in	r28, 0x3d	; 61
    6108:	de b7       	in	r29, 0x3e	; 62
    610a:	9a 83       	std	Y+2, r25	; 0x02
    610c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    610e:	0e 94 4b 31 	call	0x6296	; 0x6296 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    6112:	80 91 f9 06 	lds	r24, 0x06F9
    6116:	82 30       	cpi	r24, 0x02	; 2
    6118:	d0 f3       	brcs	.-12     	; 0x610e <prvIdleTask+0xe>
			{
				taskYIELD();
    611a:	0e 94 b2 1d 	call	0x3b64	; 0x3b64 <vPortYield>
    611e:	f7 cf       	rjmp	.-18     	; 0x610e <prvIdleTask+0xe>

00006120 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    6120:	0f 93       	push	r16
    6122:	1f 93       	push	r17
    6124:	df 93       	push	r29
    6126:	cf 93       	push	r28
    6128:	cd b7       	in	r28, 0x3d	; 61
    612a:	de b7       	in	r29, 0x3e	; 62
    612c:	2a 97       	sbiw	r28, 0x0a	; 10
    612e:	0f b6       	in	r0, 0x3f	; 63
    6130:	f8 94       	cli
    6132:	de bf       	out	0x3e, r29	; 62
    6134:	0f be       	out	0x3f, r0	; 63
    6136:	cd bf       	out	0x3d, r28	; 61
    6138:	9b 83       	std	Y+3, r25	; 0x03
    613a:	8a 83       	std	Y+2, r24	; 0x02
    613c:	7d 83       	std	Y+5, r23	; 0x05
    613e:	6c 83       	std	Y+4, r22	; 0x04
    6140:	4e 83       	std	Y+6, r20	; 0x06
    6142:	38 87       	std	Y+8, r19	; 0x08
    6144:	2f 83       	std	Y+7, r18	; 0x07
    6146:	1a 87       	std	Y+10, r17	; 0x0a
    6148:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    614a:	19 82       	std	Y+1, r1	; 0x01
    614c:	21 c0       	rjmp	.+66     	; 0x6190 <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    614e:	89 81       	ldd	r24, Y+1	; 0x01
    6150:	48 2f       	mov	r20, r24
    6152:	50 e0       	ldi	r21, 0x00	; 0
    6154:	89 81       	ldd	r24, Y+1	; 0x01
    6156:	28 2f       	mov	r18, r24
    6158:	30 e0       	ldi	r19, 0x00	; 0
    615a:	8c 81       	ldd	r24, Y+4	; 0x04
    615c:	9d 81       	ldd	r25, Y+5	; 0x05
    615e:	fc 01       	movw	r30, r24
    6160:	e2 0f       	add	r30, r18
    6162:	f3 1f       	adc	r31, r19
    6164:	20 81       	ld	r18, Z
    6166:	8a 81       	ldd	r24, Y+2	; 0x02
    6168:	9b 81       	ldd	r25, Y+3	; 0x03
    616a:	84 0f       	add	r24, r20
    616c:	95 1f       	adc	r25, r21
    616e:	fc 01       	movw	r30, r24
    6170:	79 96       	adiw	r30, 0x19	; 25
    6172:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    6174:	89 81       	ldd	r24, Y+1	; 0x01
    6176:	28 2f       	mov	r18, r24
    6178:	30 e0       	ldi	r19, 0x00	; 0
    617a:	8c 81       	ldd	r24, Y+4	; 0x04
    617c:	9d 81       	ldd	r25, Y+5	; 0x05
    617e:	fc 01       	movw	r30, r24
    6180:	e2 0f       	add	r30, r18
    6182:	f3 1f       	adc	r31, r19
    6184:	80 81       	ld	r24, Z
    6186:	88 23       	and	r24, r24
    6188:	31 f0       	breq	.+12     	; 0x6196 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    618a:	89 81       	ldd	r24, Y+1	; 0x01
    618c:	8f 5f       	subi	r24, 0xFF	; 255
    618e:	89 83       	std	Y+1, r24	; 0x01
    6190:	89 81       	ldd	r24, Y+1	; 0x01
    6192:	84 31       	cpi	r24, 0x14	; 20
    6194:	e0 f2       	brcs	.-72     	; 0x614e <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    6196:	ea 81       	ldd	r30, Y+2	; 0x02
    6198:	fb 81       	ldd	r31, Y+3	; 0x03
    619a:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    619c:	8e 81       	ldd	r24, Y+6	; 0x06
    619e:	86 30       	cpi	r24, 0x06	; 6
    61a0:	10 f0       	brcs	.+4      	; 0x61a6 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    61a2:	85 e0       	ldi	r24, 0x05	; 5
    61a4:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    61a6:	ea 81       	ldd	r30, Y+2	; 0x02
    61a8:	fb 81       	ldd	r31, Y+3	; 0x03
    61aa:	8e 81       	ldd	r24, Y+6	; 0x06
    61ac:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    61ae:	ea 81       	ldd	r30, Y+2	; 0x02
    61b0:	fb 81       	ldd	r31, Y+3	; 0x03
    61b2:	8e 81       	ldd	r24, Y+6	; 0x06
    61b4:	87 a7       	std	Z+47, r24	; 0x2f
		pxTCB->uxMutexesHeld = 0;
    61b6:	ea 81       	ldd	r30, Y+2	; 0x02
    61b8:	fb 81       	ldd	r31, Y+3	; 0x03
    61ba:	10 aa       	std	Z+48, r1	; 0x30
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    61bc:	8a 81       	ldd	r24, Y+2	; 0x02
    61be:	9b 81       	ldd	r25, Y+3	; 0x03
    61c0:	02 96       	adiw	r24, 0x02	; 2
    61c2:	0e 94 6d 1a 	call	0x34da	; 0x34da <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    61c6:	8a 81       	ldd	r24, Y+2	; 0x02
    61c8:	9b 81       	ldd	r25, Y+3	; 0x03
    61ca:	0c 96       	adiw	r24, 0x0c	; 12
    61cc:	0e 94 6d 1a 	call	0x34da	; 0x34da <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    61d0:	ea 81       	ldd	r30, Y+2	; 0x02
    61d2:	fb 81       	ldd	r31, Y+3	; 0x03
    61d4:	8a 81       	ldd	r24, Y+2	; 0x02
    61d6:	9b 81       	ldd	r25, Y+3	; 0x03
    61d8:	91 87       	std	Z+9, r25	; 0x09
    61da:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    61dc:	8e 81       	ldd	r24, Y+6	; 0x06
    61de:	28 2f       	mov	r18, r24
    61e0:	30 e0       	ldi	r19, 0x00	; 0
    61e2:	86 e0       	ldi	r24, 0x06	; 6
    61e4:	90 e0       	ldi	r25, 0x00	; 0
    61e6:	82 1b       	sub	r24, r18
    61e8:	93 0b       	sbc	r25, r19
    61ea:	ea 81       	ldd	r30, Y+2	; 0x02
    61ec:	fb 81       	ldd	r31, Y+3	; 0x03
    61ee:	95 87       	std	Z+13, r25	; 0x0d
    61f0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    61f2:	ea 81       	ldd	r30, Y+2	; 0x02
    61f4:	fb 81       	ldd	r31, Y+3	; 0x03
    61f6:	8a 81       	ldd	r24, Y+2	; 0x02
    61f8:	9b 81       	ldd	r25, Y+3	; 0x03
    61fa:	93 8b       	std	Z+19, r25	; 0x13
    61fc:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    61fe:	2a 96       	adiw	r28, 0x0a	; 10
    6200:	0f b6       	in	r0, 0x3f	; 63
    6202:	f8 94       	cli
    6204:	de bf       	out	0x3e, r29	; 62
    6206:	0f be       	out	0x3f, r0	; 63
    6208:	cd bf       	out	0x3d, r28	; 61
    620a:	cf 91       	pop	r28
    620c:	df 91       	pop	r29
    620e:	1f 91       	pop	r17
    6210:	0f 91       	pop	r16
    6212:	08 95       	ret

00006214 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    6214:	df 93       	push	r29
    6216:	cf 93       	push	r28
    6218:	0f 92       	push	r0
    621a:	cd b7       	in	r28, 0x3d	; 61
    621c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    621e:	19 82       	std	Y+1, r1	; 0x01
    6220:	13 c0       	rjmp	.+38     	; 0x6248 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6222:	89 81       	ldd	r24, Y+1	; 0x01
    6224:	28 2f       	mov	r18, r24
    6226:	30 e0       	ldi	r19, 0x00	; 0
    6228:	c9 01       	movw	r24, r18
    622a:	88 0f       	add	r24, r24
    622c:	99 1f       	adc	r25, r25
    622e:	88 0f       	add	r24, r24
    6230:	99 1f       	adc	r25, r25
    6232:	88 0f       	add	r24, r24
    6234:	99 1f       	adc	r25, r25
    6236:	82 0f       	add	r24, r18
    6238:	93 1f       	adc	r25, r19
    623a:	87 50       	subi	r24, 0x07	; 7
    623c:	99 4f       	sbci	r25, 0xF9	; 249
    623e:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6242:	89 81       	ldd	r24, Y+1	; 0x01
    6244:	8f 5f       	subi	r24, 0xFF	; 255
    6246:	89 83       	std	Y+1, r24	; 0x01
    6248:	89 81       	ldd	r24, Y+1	; 0x01
    624a:	86 30       	cpi	r24, 0x06	; 6
    624c:	50 f3       	brcs	.-44     	; 0x6222 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    624e:	8f e2       	ldi	r24, 0x2F	; 47
    6250:	97 e0       	ldi	r25, 0x07	; 7
    6252:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    6256:	88 e3       	ldi	r24, 0x38	; 56
    6258:	97 e0       	ldi	r25, 0x07	; 7
    625a:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    625e:	85 e4       	ldi	r24, 0x45	; 69
    6260:	97 e0       	ldi	r25, 0x07	; 7
    6262:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    6266:	8e e4       	ldi	r24, 0x4E	; 78
    6268:	97 e0       	ldi	r25, 0x07	; 7
    626a:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    626e:	87 e5       	ldi	r24, 0x57	; 87
    6270:	97 e0       	ldi	r25, 0x07	; 7
    6272:	0e 94 43 1a 	call	0x3486	; 0x3486 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    6276:	8f e2       	ldi	r24, 0x2F	; 47
    6278:	97 e0       	ldi	r25, 0x07	; 7
    627a:	90 93 42 07 	sts	0x0742, r25
    627e:	80 93 41 07 	sts	0x0741, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6282:	88 e3       	ldi	r24, 0x38	; 56
    6284:	97 e0       	ldi	r25, 0x07	; 7
    6286:	90 93 44 07 	sts	0x0744, r25
    628a:	80 93 43 07 	sts	0x0743, r24
}
    628e:	0f 90       	pop	r0
    6290:	cf 91       	pop	r28
    6292:	df 91       	pop	r29
    6294:	08 95       	ret

00006296 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    6296:	df 93       	push	r29
    6298:	cf 93       	push	r28
    629a:	00 d0       	rcall	.+0      	; 0x629c <prvCheckTasksWaitingTermination+0x6>
    629c:	0f 92       	push	r0
    629e:	cd b7       	in	r28, 0x3d	; 61
    62a0:	de b7       	in	r29, 0x3e	; 62
    62a2:	2e c0       	rjmp	.+92     	; 0x6300 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    62a4:	0e 94 45 2b 	call	0x568a	; 0x568a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    62a8:	80 91 4e 07 	lds	r24, 0x074E
    62ac:	1b 82       	std	Y+3, r1	; 0x03
    62ae:	88 23       	and	r24, r24
    62b0:	11 f4       	brne	.+4      	; 0x62b6 <prvCheckTasksWaitingTermination+0x20>
    62b2:	81 e0       	ldi	r24, 0x01	; 1
    62b4:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    62b6:	0e 94 51 2b 	call	0x56a2	; 0x56a2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    62ba:	8b 81       	ldd	r24, Y+3	; 0x03
    62bc:	88 23       	and	r24, r24
    62be:	01 f5       	brne	.+64     	; 0x6300 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    62c0:	0f b6       	in	r0, 0x3f	; 63
    62c2:	f8 94       	cli
    62c4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    62c6:	e0 91 53 07 	lds	r30, 0x0753
    62ca:	f0 91 54 07 	lds	r31, 0x0754
    62ce:	86 81       	ldd	r24, Z+6	; 0x06
    62d0:	97 81       	ldd	r25, Z+7	; 0x07
    62d2:	9a 83       	std	Y+2, r25	; 0x02
    62d4:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    62d6:	89 81       	ldd	r24, Y+1	; 0x01
    62d8:	9a 81       	ldd	r25, Y+2	; 0x02
    62da:	02 96       	adiw	r24, 0x02	; 2
    62dc:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					--uxCurrentNumberOfTasks;
    62e0:	80 91 ef 06 	lds	r24, 0x06EF
    62e4:	81 50       	subi	r24, 0x01	; 1
    62e6:	80 93 ef 06 	sts	0x06EF, r24
					--uxTasksDeleted;
    62ea:	80 91 ee 06 	lds	r24, 0x06EE
    62ee:	81 50       	subi	r24, 0x01	; 1
    62f0:	80 93 ee 06 	sts	0x06EE, r24
				}
				taskEXIT_CRITICAL();
    62f4:	0f 90       	pop	r0
    62f6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    62f8:	89 81       	ldd	r24, Y+1	; 0x01
    62fa:	9a 81       	ldd	r25, Y+2	; 0x02
    62fc:	0e 94 d3 33 	call	0x67a6	; 0x67a6 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    6300:	80 91 ee 06 	lds	r24, 0x06EE
    6304:	88 23       	and	r24, r24
    6306:	71 f6       	brne	.-100    	; 0x62a4 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    6308:	0f 90       	pop	r0
    630a:	0f 90       	pop	r0
    630c:	0f 90       	pop	r0
    630e:	cf 91       	pop	r28
    6310:	df 91       	pop	r29
    6312:	08 95       	ret

00006314 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    6314:	df 93       	push	r29
    6316:	cf 93       	push	r28
    6318:	00 d0       	rcall	.+0      	; 0x631a <prvAddCurrentTaskToDelayedList+0x6>
    631a:	cd b7       	in	r28, 0x3d	; 61
    631c:	de b7       	in	r29, 0x3e	; 62
    631e:	9a 83       	std	Y+2, r25	; 0x02
    6320:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    6322:	e0 91 ec 06 	lds	r30, 0x06EC
    6326:	f0 91 ed 06 	lds	r31, 0x06ED
    632a:	89 81       	ldd	r24, Y+1	; 0x01
    632c:	9a 81       	ldd	r25, Y+2	; 0x02
    632e:	93 83       	std	Z+3, r25	; 0x03
    6330:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    6332:	20 91 f0 06 	lds	r18, 0x06F0
    6336:	30 91 f1 06 	lds	r19, 0x06F1
    633a:	89 81       	ldd	r24, Y+1	; 0x01
    633c:	9a 81       	ldd	r25, Y+2	; 0x02
    633e:	82 17       	cp	r24, r18
    6340:	93 07       	cpc	r25, r19
    6342:	70 f4       	brcc	.+28     	; 0x6360 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    6344:	80 91 43 07 	lds	r24, 0x0743
    6348:	90 91 44 07 	lds	r25, 0x0744
    634c:	20 91 ec 06 	lds	r18, 0x06EC
    6350:	30 91 ed 06 	lds	r19, 0x06ED
    6354:	2e 5f       	subi	r18, 0xFE	; 254
    6356:	3f 4f       	sbci	r19, 0xFF	; 255
    6358:	b9 01       	movw	r22, r18
    635a:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>
    635e:	1e c0       	rjmp	.+60     	; 0x639c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    6360:	40 91 41 07 	lds	r20, 0x0741
    6364:	50 91 42 07 	lds	r21, 0x0742
    6368:	80 91 ec 06 	lds	r24, 0x06EC
    636c:	90 91 ed 06 	lds	r25, 0x06ED
    6370:	9c 01       	movw	r18, r24
    6372:	2e 5f       	subi	r18, 0xFE	; 254
    6374:	3f 4f       	sbci	r19, 0xFF	; 255
    6376:	ca 01       	movw	r24, r20
    6378:	b9 01       	movw	r22, r18
    637a:	0e 94 c1 1a 	call	0x3582	; 0x3582 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    637e:	20 91 a6 00 	lds	r18, 0x00A6
    6382:	30 91 a7 00 	lds	r19, 0x00A7
    6386:	89 81       	ldd	r24, Y+1	; 0x01
    6388:	9a 81       	ldd	r25, Y+2	; 0x02
    638a:	82 17       	cp	r24, r18
    638c:	93 07       	cpc	r25, r19
    638e:	30 f4       	brcc	.+12     	; 0x639c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    6390:	89 81       	ldd	r24, Y+1	; 0x01
    6392:	9a 81       	ldd	r25, Y+2	; 0x02
    6394:	90 93 a7 00 	sts	0x00A7, r25
    6398:	80 93 a6 00 	sts	0x00A6, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    639c:	0f 90       	pop	r0
    639e:	0f 90       	pop	r0
    63a0:	cf 91       	pop	r28
    63a2:	df 91       	pop	r29
    63a4:	08 95       	ret

000063a6 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    63a6:	df 93       	push	r29
    63a8:	cf 93       	push	r28
    63aa:	cd b7       	in	r28, 0x3d	; 61
    63ac:	de b7       	in	r29, 0x3e	; 62
    63ae:	28 97       	sbiw	r28, 0x08	; 8
    63b0:	0f b6       	in	r0, 0x3f	; 63
    63b2:	f8 94       	cli
    63b4:	de bf       	out	0x3e, r29	; 62
    63b6:	0f be       	out	0x3f, r0	; 63
    63b8:	cd bf       	out	0x3d, r28	; 61
    63ba:	9c 83       	std	Y+4, r25	; 0x04
    63bc:	8b 83       	std	Y+3, r24	; 0x03
    63be:	7e 83       	std	Y+6, r23	; 0x06
    63c0:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    63c2:	81 e3       	ldi	r24, 0x31	; 49
    63c4:	90 e0       	ldi	r25, 0x00	; 0
    63c6:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    63ca:	9a 83       	std	Y+2, r25	; 0x02
    63cc:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    63ce:	89 81       	ldd	r24, Y+1	; 0x01
    63d0:	9a 81       	ldd	r25, Y+2	; 0x02
    63d2:	00 97       	sbiw	r24, 0x00	; 0
    63d4:	69 f1       	breq	.+90     	; 0x6430 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    63d6:	8d 81       	ldd	r24, Y+5	; 0x05
    63d8:	9e 81       	ldd	r25, Y+6	; 0x06
    63da:	00 97       	sbiw	r24, 0x00	; 0
    63dc:	39 f4       	brne	.+14     	; 0x63ec <prvAllocateTCBAndStack+0x46>
    63de:	8b 81       	ldd	r24, Y+3	; 0x03
    63e0:	9c 81       	ldd	r25, Y+4	; 0x04
    63e2:	0e 94 f5 18 	call	0x31ea	; 0x31ea <pvPortMalloc>
    63e6:	98 87       	std	Y+8, r25	; 0x08
    63e8:	8f 83       	std	Y+7, r24	; 0x07
    63ea:	04 c0       	rjmp	.+8      	; 0x63f4 <prvAllocateTCBAndStack+0x4e>
    63ec:	8d 81       	ldd	r24, Y+5	; 0x05
    63ee:	9e 81       	ldd	r25, Y+6	; 0x06
    63f0:	98 87       	std	Y+8, r25	; 0x08
    63f2:	8f 83       	std	Y+7, r24	; 0x07
    63f4:	e9 81       	ldd	r30, Y+1	; 0x01
    63f6:	fa 81       	ldd	r31, Y+2	; 0x02
    63f8:	8f 81       	ldd	r24, Y+7	; 0x07
    63fa:	98 85       	ldd	r25, Y+8	; 0x08
    63fc:	90 8f       	std	Z+24, r25	; 0x18
    63fe:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    6400:	e9 81       	ldd	r30, Y+1	; 0x01
    6402:	fa 81       	ldd	r31, Y+2	; 0x02
    6404:	87 89       	ldd	r24, Z+23	; 0x17
    6406:	90 8d       	ldd	r25, Z+24	; 0x18
    6408:	00 97       	sbiw	r24, 0x00	; 0
    640a:	39 f4       	brne	.+14     	; 0x641a <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    640c:	89 81       	ldd	r24, Y+1	; 0x01
    640e:	9a 81       	ldd	r25, Y+2	; 0x02
    6410:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
			pxNewTCB = NULL;
    6414:	1a 82       	std	Y+2, r1	; 0x02
    6416:	19 82       	std	Y+1, r1	; 0x01
    6418:	0b c0       	rjmp	.+22     	; 0x6430 <prvAllocateTCBAndStack+0x8a>
		{
			/* Avoid dependency on memset() if it is not required. */
			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
			{
				/* Just to help debugging. */
				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
    641a:	e9 81       	ldd	r30, Y+1	; 0x01
    641c:	fa 81       	ldd	r31, Y+2	; 0x02
    641e:	87 89       	ldd	r24, Z+23	; 0x17
    6420:	90 8d       	ldd	r25, Z+24	; 0x18
    6422:	2b 81       	ldd	r18, Y+3	; 0x03
    6424:	3c 81       	ldd	r19, Y+4	; 0x04
    6426:	65 ea       	ldi	r22, 0xA5	; 165
    6428:	70 e0       	ldi	r23, 0x00	; 0
    642a:	a9 01       	movw	r20, r18
    642c:	0e 94 0a 36 	call	0x6c14	; 0x6c14 <memset>
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    6430:	89 81       	ldd	r24, Y+1	; 0x01
    6432:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6434:	28 96       	adiw	r28, 0x08	; 8
    6436:	0f b6       	in	r0, 0x3f	; 63
    6438:	f8 94       	cli
    643a:	de bf       	out	0x3e, r29	; 62
    643c:	0f be       	out	0x3f, r0	; 63
    643e:	cd bf       	out	0x3d, r28	; 61
    6440:	cf 91       	pop	r28
    6442:	df 91       	pop	r29
    6444:	08 95       	ret

00006446 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
    6446:	0f 93       	push	r16
    6448:	1f 93       	push	r17
    644a:	df 93       	push	r29
    644c:	cf 93       	push	r28
    644e:	cd b7       	in	r28, 0x3d	; 61
    6450:	de b7       	in	r29, 0x3e	; 62
    6452:	2e 97       	sbiw	r28, 0x0e	; 14
    6454:	0f b6       	in	r0, 0x3f	; 63
    6456:	f8 94       	cli
    6458:	de bf       	out	0x3e, r29	; 62
    645a:	0f be       	out	0x3f, r0	; 63
    645c:	cd bf       	out	0x3d, r28	; 61
    645e:	9b 87       	std	Y+11, r25	; 0x0b
    6460:	8a 87       	std	Y+10, r24	; 0x0a
    6462:	7d 87       	std	Y+13, r23	; 0x0d
    6464:	6c 87       	std	Y+12, r22	; 0x0c
    6466:	4e 87       	std	Y+14, r20	; 0x0e
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    6468:	1d 82       	std	Y+5, r1	; 0x05

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    646a:	ec 85       	ldd	r30, Y+12	; 0x0c
    646c:	fd 85       	ldd	r31, Y+13	; 0x0d
    646e:	80 81       	ld	r24, Z
    6470:	88 23       	and	r24, r24
    6472:	09 f4       	brne	.+2      	; 0x6476 <prvListTaskWithinSingleList+0x30>
    6474:	5e c1       	rjmp	.+700    	; 0x6732 <prvListTaskWithinSingleList+0x2ec>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    6476:	8c 85       	ldd	r24, Y+12	; 0x0c
    6478:	9d 85       	ldd	r25, Y+13	; 0x0d
    647a:	9c 83       	std	Y+4, r25	; 0x04
    647c:	8b 83       	std	Y+3, r24	; 0x03
    647e:	eb 81       	ldd	r30, Y+3	; 0x03
    6480:	fc 81       	ldd	r31, Y+4	; 0x04
    6482:	01 80       	ldd	r0, Z+1	; 0x01
    6484:	f2 81       	ldd	r31, Z+2	; 0x02
    6486:	e0 2d       	mov	r30, r0
    6488:	82 81       	ldd	r24, Z+2	; 0x02
    648a:	93 81       	ldd	r25, Z+3	; 0x03
    648c:	eb 81       	ldd	r30, Y+3	; 0x03
    648e:	fc 81       	ldd	r31, Y+4	; 0x04
    6490:	92 83       	std	Z+2, r25	; 0x02
    6492:	81 83       	std	Z+1, r24	; 0x01
    6494:	eb 81       	ldd	r30, Y+3	; 0x03
    6496:	fc 81       	ldd	r31, Y+4	; 0x04
    6498:	21 81       	ldd	r18, Z+1	; 0x01
    649a:	32 81       	ldd	r19, Z+2	; 0x02
    649c:	8b 81       	ldd	r24, Y+3	; 0x03
    649e:	9c 81       	ldd	r25, Y+4	; 0x04
    64a0:	03 96       	adiw	r24, 0x03	; 3
    64a2:	28 17       	cp	r18, r24
    64a4:	39 07       	cpc	r19, r25
    64a6:	59 f4       	brne	.+22     	; 0x64be <prvListTaskWithinSingleList+0x78>
    64a8:	eb 81       	ldd	r30, Y+3	; 0x03
    64aa:	fc 81       	ldd	r31, Y+4	; 0x04
    64ac:	01 80       	ldd	r0, Z+1	; 0x01
    64ae:	f2 81       	ldd	r31, Z+2	; 0x02
    64b0:	e0 2d       	mov	r30, r0
    64b2:	82 81       	ldd	r24, Z+2	; 0x02
    64b4:	93 81       	ldd	r25, Z+3	; 0x03
    64b6:	eb 81       	ldd	r30, Y+3	; 0x03
    64b8:	fc 81       	ldd	r31, Y+4	; 0x04
    64ba:	92 83       	std	Z+2, r25	; 0x02
    64bc:	81 83       	std	Z+1, r24	; 0x01
    64be:	eb 81       	ldd	r30, Y+3	; 0x03
    64c0:	fc 81       	ldd	r31, Y+4	; 0x04
    64c2:	01 80       	ldd	r0, Z+1	; 0x01
    64c4:	f2 81       	ldd	r31, Z+2	; 0x02
    64c6:	e0 2d       	mov	r30, r0
    64c8:	86 81       	ldd	r24, Z+6	; 0x06
    64ca:	97 81       	ldd	r25, Z+7	; 0x07
    64cc:	9f 83       	std	Y+7, r25	; 0x07
    64ce:	8e 83       	std	Y+6, r24	; 0x06
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    64d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    64d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    64d4:	9a 83       	std	Y+2, r25	; 0x02
    64d6:	89 83       	std	Y+1, r24	; 0x01
    64d8:	e9 81       	ldd	r30, Y+1	; 0x01
    64da:	fa 81       	ldd	r31, Y+2	; 0x02
    64dc:	01 80       	ldd	r0, Z+1	; 0x01
    64de:	f2 81       	ldd	r31, Z+2	; 0x02
    64e0:	e0 2d       	mov	r30, r0
    64e2:	82 81       	ldd	r24, Z+2	; 0x02
    64e4:	93 81       	ldd	r25, Z+3	; 0x03
    64e6:	e9 81       	ldd	r30, Y+1	; 0x01
    64e8:	fa 81       	ldd	r31, Y+2	; 0x02
    64ea:	92 83       	std	Z+2, r25	; 0x02
    64ec:	81 83       	std	Z+1, r24	; 0x01
    64ee:	e9 81       	ldd	r30, Y+1	; 0x01
    64f0:	fa 81       	ldd	r31, Y+2	; 0x02
    64f2:	21 81       	ldd	r18, Z+1	; 0x01
    64f4:	32 81       	ldd	r19, Z+2	; 0x02
    64f6:	89 81       	ldd	r24, Y+1	; 0x01
    64f8:	9a 81       	ldd	r25, Y+2	; 0x02
    64fa:	03 96       	adiw	r24, 0x03	; 3
    64fc:	28 17       	cp	r18, r24
    64fe:	39 07       	cpc	r19, r25
    6500:	59 f4       	brne	.+22     	; 0x6518 <prvListTaskWithinSingleList+0xd2>
    6502:	e9 81       	ldd	r30, Y+1	; 0x01
    6504:	fa 81       	ldd	r31, Y+2	; 0x02
    6506:	01 80       	ldd	r0, Z+1	; 0x01
    6508:	f2 81       	ldd	r31, Z+2	; 0x02
    650a:	e0 2d       	mov	r30, r0
    650c:	82 81       	ldd	r24, Z+2	; 0x02
    650e:	93 81       	ldd	r25, Z+3	; 0x03
    6510:	e9 81       	ldd	r30, Y+1	; 0x01
    6512:	fa 81       	ldd	r31, Y+2	; 0x02
    6514:	92 83       	std	Z+2, r25	; 0x02
    6516:	81 83       	std	Z+1, r24	; 0x01
    6518:	e9 81       	ldd	r30, Y+1	; 0x01
    651a:	fa 81       	ldd	r31, Y+2	; 0x02
    651c:	01 80       	ldd	r0, Z+1	; 0x01
    651e:	f2 81       	ldd	r31, Z+2	; 0x02
    6520:	e0 2d       	mov	r30, r0
    6522:	86 81       	ldd	r24, Z+6	; 0x06
    6524:	97 81       	ldd	r25, Z+7	; 0x07
    6526:	99 87       	std	Y+9, r25	; 0x09
    6528:	88 87       	std	Y+8, r24	; 0x08

				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
    652a:	8d 81       	ldd	r24, Y+5	; 0x05
    652c:	88 2f       	mov	r24, r24
    652e:	90 e0       	ldi	r25, 0x00	; 0
    6530:	9c 01       	movw	r18, r24
    6532:	22 0f       	add	r18, r18
    6534:	33 1f       	adc	r19, r19
    6536:	c9 01       	movw	r24, r18
    6538:	88 0f       	add	r24, r24
    653a:	99 1f       	adc	r25, r25
    653c:	88 0f       	add	r24, r24
    653e:	99 1f       	adc	r25, r25
    6540:	88 0f       	add	r24, r24
    6542:	99 1f       	adc	r25, r25
    6544:	ac 01       	movw	r20, r24
    6546:	42 1b       	sub	r20, r18
    6548:	53 0b       	sbc	r21, r19
    654a:	9a 01       	movw	r18, r20
    654c:	8a 85       	ldd	r24, Y+10	; 0x0a
    654e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6550:	fc 01       	movw	r30, r24
    6552:	e2 0f       	add	r30, r18
    6554:	f3 1f       	adc	r31, r19
    6556:	88 85       	ldd	r24, Y+8	; 0x08
    6558:	99 85       	ldd	r25, Y+9	; 0x09
    655a:	91 83       	std	Z+1, r25	; 0x01
    655c:	80 83       	st	Z, r24
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
    655e:	8d 81       	ldd	r24, Y+5	; 0x05
    6560:	88 2f       	mov	r24, r24
    6562:	90 e0       	ldi	r25, 0x00	; 0
    6564:	9c 01       	movw	r18, r24
    6566:	22 0f       	add	r18, r18
    6568:	33 1f       	adc	r19, r19
    656a:	c9 01       	movw	r24, r18
    656c:	88 0f       	add	r24, r24
    656e:	99 1f       	adc	r25, r25
    6570:	88 0f       	add	r24, r24
    6572:	99 1f       	adc	r25, r25
    6574:	88 0f       	add	r24, r24
    6576:	99 1f       	adc	r25, r25
    6578:	fc 01       	movw	r30, r24
    657a:	e2 1b       	sub	r30, r18
    657c:	f3 0b       	sbc	r31, r19
    657e:	9f 01       	movw	r18, r30
    6580:	8a 85       	ldd	r24, Y+10	; 0x0a
    6582:	9b 85       	ldd	r25, Y+11	; 0x0b
    6584:	fc 01       	movw	r30, r24
    6586:	e2 0f       	add	r30, r18
    6588:	f3 1f       	adc	r31, r19
    658a:	88 85       	ldd	r24, Y+8	; 0x08
    658c:	99 85       	ldd	r25, Y+9	; 0x09
    658e:	49 96       	adiw	r24, 0x19	; 25
    6590:	93 83       	std	Z+3, r25	; 0x03
    6592:	82 83       	std	Z+2, r24	; 0x02
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
    6594:	8d 81       	ldd	r24, Y+5	; 0x05
    6596:	88 2f       	mov	r24, r24
    6598:	90 e0       	ldi	r25, 0x00	; 0
    659a:	9c 01       	movw	r18, r24
    659c:	22 0f       	add	r18, r18
    659e:	33 1f       	adc	r19, r19
    65a0:	c9 01       	movw	r24, r18
    65a2:	88 0f       	add	r24, r24
    65a4:	99 1f       	adc	r25, r25
    65a6:	88 0f       	add	r24, r24
    65a8:	99 1f       	adc	r25, r25
    65aa:	88 0f       	add	r24, r24
    65ac:	99 1f       	adc	r25, r25
    65ae:	ac 01       	movw	r20, r24
    65b0:	42 1b       	sub	r20, r18
    65b2:	53 0b       	sbc	r21, r19
    65b4:	9a 01       	movw	r18, r20
    65b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    65b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    65ba:	dc 01       	movw	r26, r24
    65bc:	a2 0f       	add	r26, r18
    65be:	b3 1f       	adc	r27, r19
    65c0:	e8 85       	ldd	r30, Y+8	; 0x08
    65c2:	f9 85       	ldd	r31, Y+9	; 0x09
    65c4:	85 a5       	ldd	r24, Z+45	; 0x2d
    65c6:	14 96       	adiw	r26, 0x04	; 4
    65c8:	8c 93       	st	X, r24
				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
    65ca:	8d 81       	ldd	r24, Y+5	; 0x05
    65cc:	88 2f       	mov	r24, r24
    65ce:	90 e0       	ldi	r25, 0x00	; 0
    65d0:	9c 01       	movw	r18, r24
    65d2:	22 0f       	add	r18, r18
    65d4:	33 1f       	adc	r19, r19
    65d6:	c9 01       	movw	r24, r18
    65d8:	88 0f       	add	r24, r24
    65da:	99 1f       	adc	r25, r25
    65dc:	88 0f       	add	r24, r24
    65de:	99 1f       	adc	r25, r25
    65e0:	88 0f       	add	r24, r24
    65e2:	99 1f       	adc	r25, r25
    65e4:	fc 01       	movw	r30, r24
    65e6:	e2 1b       	sub	r30, r18
    65e8:	f3 0b       	sbc	r31, r19
    65ea:	9f 01       	movw	r18, r30
    65ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    65ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    65f0:	fc 01       	movw	r30, r24
    65f2:	e2 0f       	add	r30, r18
    65f4:	f3 1f       	adc	r31, r19
    65f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    65f8:	85 83       	std	Z+5, r24	; 0x05
				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
    65fa:	8d 81       	ldd	r24, Y+5	; 0x05
    65fc:	88 2f       	mov	r24, r24
    65fe:	90 e0       	ldi	r25, 0x00	; 0
    6600:	9c 01       	movw	r18, r24
    6602:	22 0f       	add	r18, r18
    6604:	33 1f       	adc	r19, r19
    6606:	c9 01       	movw	r24, r18
    6608:	88 0f       	add	r24, r24
    660a:	99 1f       	adc	r25, r25
    660c:	88 0f       	add	r24, r24
    660e:	99 1f       	adc	r25, r25
    6610:	88 0f       	add	r24, r24
    6612:	99 1f       	adc	r25, r25
    6614:	ac 01       	movw	r20, r24
    6616:	42 1b       	sub	r20, r18
    6618:	53 0b       	sbc	r21, r19
    661a:	9a 01       	movw	r18, r20
    661c:	8a 85       	ldd	r24, Y+10	; 0x0a
    661e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6620:	dc 01       	movw	r26, r24
    6622:	a2 0f       	add	r26, r18
    6624:	b3 1f       	adc	r27, r19
    6626:	e8 85       	ldd	r30, Y+8	; 0x08
    6628:	f9 85       	ldd	r31, Y+9	; 0x09
    662a:	86 89       	ldd	r24, Z+22	; 0x16
    662c:	16 96       	adiw	r26, 0x06	; 6
    662e:	8c 93       	st	X, r24
    6630:	16 97       	sbiw	r26, 0x06	; 6
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a chance
					it is actually just blocked indefinitely - so really it should
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
    6632:	8e 85       	ldd	r24, Y+14	; 0x0e
    6634:	83 30       	cpi	r24, 0x03	; 3
    6636:	f1 f4       	brne	.+60     	; 0x6674 <prvListTaskWithinSingleList+0x22e>
					{
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
    6638:	e8 85       	ldd	r30, Y+8	; 0x08
    663a:	f9 85       	ldd	r31, Y+9	; 0x09
    663c:	84 89       	ldd	r24, Z+20	; 0x14
    663e:	95 89       	ldd	r25, Z+21	; 0x15
    6640:	00 97       	sbiw	r24, 0x00	; 0
    6642:	c1 f0       	breq	.+48     	; 0x6674 <prvListTaskWithinSingleList+0x22e>
						{
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
    6644:	8d 81       	ldd	r24, Y+5	; 0x05
    6646:	88 2f       	mov	r24, r24
    6648:	90 e0       	ldi	r25, 0x00	; 0
    664a:	9c 01       	movw	r18, r24
    664c:	22 0f       	add	r18, r18
    664e:	33 1f       	adc	r19, r19
    6650:	c9 01       	movw	r24, r18
    6652:	88 0f       	add	r24, r24
    6654:	99 1f       	adc	r25, r25
    6656:	88 0f       	add	r24, r24
    6658:	99 1f       	adc	r25, r25
    665a:	88 0f       	add	r24, r24
    665c:	99 1f       	adc	r25, r25
    665e:	fc 01       	movw	r30, r24
    6660:	e2 1b       	sub	r30, r18
    6662:	f3 0b       	sbc	r31, r19
    6664:	9f 01       	movw	r18, r30
    6666:	8a 85       	ldd	r24, Y+10	; 0x0a
    6668:	9b 85       	ldd	r25, Y+11	; 0x0b
    666a:	fc 01       	movw	r30, r24
    666c:	e2 0f       	add	r30, r18
    666e:	f3 1f       	adc	r31, r19
    6670:	82 e0       	ldi	r24, 0x02	; 2
    6672:	85 83       	std	Z+5, r24	; 0x05
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
    6674:	8d 81       	ldd	r24, Y+5	; 0x05
    6676:	88 2f       	mov	r24, r24
    6678:	90 e0       	ldi	r25, 0x00	; 0
    667a:	9c 01       	movw	r18, r24
    667c:	22 0f       	add	r18, r18
    667e:	33 1f       	adc	r19, r19
    6680:	c9 01       	movw	r24, r18
    6682:	88 0f       	add	r24, r24
    6684:	99 1f       	adc	r25, r25
    6686:	88 0f       	add	r24, r24
    6688:	99 1f       	adc	r25, r25
    668a:	88 0f       	add	r24, r24
    668c:	99 1f       	adc	r25, r25
    668e:	ac 01       	movw	r20, r24
    6690:	42 1b       	sub	r20, r18
    6692:	53 0b       	sbc	r21, r19
    6694:	9a 01       	movw	r18, r20
    6696:	8a 85       	ldd	r24, Y+10	; 0x0a
    6698:	9b 85       	ldd	r25, Y+11	; 0x0b
    669a:	dc 01       	movw	r26, r24
    669c:	a2 0f       	add	r26, r18
    669e:	b3 1f       	adc	r27, r19
    66a0:	e8 85       	ldd	r30, Y+8	; 0x08
    66a2:	f9 85       	ldd	r31, Y+9	; 0x09
    66a4:	87 a5       	ldd	r24, Z+47	; 0x2f
    66a6:	17 96       	adiw	r26, 0x07	; 7
    66a8:	8c 93       	st	X, r24
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
    66aa:	8d 81       	ldd	r24, Y+5	; 0x05
    66ac:	88 2f       	mov	r24, r24
    66ae:	90 e0       	ldi	r25, 0x00	; 0
    66b0:	9c 01       	movw	r18, r24
    66b2:	22 0f       	add	r18, r18
    66b4:	33 1f       	adc	r19, r19
    66b6:	c9 01       	movw	r24, r18
    66b8:	88 0f       	add	r24, r24
    66ba:	99 1f       	adc	r25, r25
    66bc:	88 0f       	add	r24, r24
    66be:	99 1f       	adc	r25, r25
    66c0:	88 0f       	add	r24, r24
    66c2:	99 1f       	adc	r25, r25
    66c4:	fc 01       	movw	r30, r24
    66c6:	e2 1b       	sub	r30, r18
    66c8:	f3 0b       	sbc	r31, r19
    66ca:	9f 01       	movw	r18, r30
    66cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    66ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    66d0:	fc 01       	movw	r30, r24
    66d2:	e2 0f       	add	r30, r18
    66d4:	f3 1f       	adc	r31, r19
    66d6:	10 86       	std	Z+8, r1	; 0x08
    66d8:	11 86       	std	Z+9, r1	; 0x09
    66da:	12 86       	std	Z+10, r1	; 0x0a
    66dc:	13 86       	std	Z+11, r1	; 0x0b
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
    66de:	8d 81       	ldd	r24, Y+5	; 0x05
    66e0:	88 2f       	mov	r24, r24
    66e2:	90 e0       	ldi	r25, 0x00	; 0
    66e4:	9c 01       	movw	r18, r24
    66e6:	22 0f       	add	r18, r18
    66e8:	33 1f       	adc	r19, r19
    66ea:	c9 01       	movw	r24, r18
    66ec:	88 0f       	add	r24, r24
    66ee:	99 1f       	adc	r25, r25
    66f0:	88 0f       	add	r24, r24
    66f2:	99 1f       	adc	r25, r25
    66f4:	88 0f       	add	r24, r24
    66f6:	99 1f       	adc	r25, r25
    66f8:	ac 01       	movw	r20, r24
    66fa:	42 1b       	sub	r20, r18
    66fc:	53 0b       	sbc	r21, r19
    66fe:	9a 01       	movw	r18, r20
    6700:	8a 85       	ldd	r24, Y+10	; 0x0a
    6702:	9b 85       	ldd	r25, Y+11	; 0x0b
    6704:	8c 01       	movw	r16, r24
    6706:	02 0f       	add	r16, r18
    6708:	13 1f       	adc	r17, r19
    670a:	e8 85       	ldd	r30, Y+8	; 0x08
    670c:	f9 85       	ldd	r31, Y+9	; 0x09
    670e:	87 89       	ldd	r24, Z+23	; 0x17
    6710:	90 8d       	ldd	r25, Z+24	; 0x18
    6712:	0e 94 a5 33 	call	0x674a	; 0x674a <prvTaskCheckFreeStackSpace>
    6716:	f8 01       	movw	r30, r16
    6718:	95 87       	std	Z+13, r25	; 0x0d
    671a:	84 87       	std	Z+12, r24	; 0x0c
				}
				#endif

				uxTask++;
    671c:	8d 81       	ldd	r24, Y+5	; 0x05
    671e:	8f 5f       	subi	r24, 0xFF	; 255
    6720:	8d 83       	std	Y+5, r24	; 0x05

			} while( pxNextTCB != pxFirstTCB );
    6722:	28 85       	ldd	r18, Y+8	; 0x08
    6724:	39 85       	ldd	r19, Y+9	; 0x09
    6726:	8e 81       	ldd	r24, Y+6	; 0x06
    6728:	9f 81       	ldd	r25, Y+7	; 0x07
    672a:	28 17       	cp	r18, r24
    672c:	39 07       	cpc	r19, r25
    672e:	09 f0       	breq	.+2      	; 0x6732 <prvListTaskWithinSingleList+0x2ec>
    6730:	cf ce       	rjmp	.-610    	; 0x64d0 <prvListTaskWithinSingleList+0x8a>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
    6732:	8d 81       	ldd	r24, Y+5	; 0x05
	}
    6734:	2e 96       	adiw	r28, 0x0e	; 14
    6736:	0f b6       	in	r0, 0x3f	; 63
    6738:	f8 94       	cli
    673a:	de bf       	out	0x3e, r29	; 62
    673c:	0f be       	out	0x3f, r0	; 63
    673e:	cd bf       	out	0x3d, r28	; 61
    6740:	cf 91       	pop	r28
    6742:	df 91       	pop	r29
    6744:	1f 91       	pop	r17
    6746:	0f 91       	pop	r16
    6748:	08 95       	ret

0000674a <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
    674a:	df 93       	push	r29
    674c:	cf 93       	push	r28
    674e:	00 d0       	rcall	.+0      	; 0x6750 <prvTaskCheckFreeStackSpace+0x6>
    6750:	00 d0       	rcall	.+0      	; 0x6752 <prvTaskCheckFreeStackSpace+0x8>
    6752:	00 d0       	rcall	.+0      	; 0x6754 <prvTaskCheckFreeStackSpace+0xa>
    6754:	cd b7       	in	r28, 0x3d	; 61
    6756:	de b7       	in	r29, 0x3e	; 62
    6758:	9e 83       	std	Y+6, r25	; 0x06
    675a:	8d 83       	std	Y+5, r24	; 0x05
	uint32_t ulCount = 0U;
    675c:	19 82       	std	Y+1, r1	; 0x01
    675e:	1a 82       	std	Y+2, r1	; 0x02
    6760:	1b 82       	std	Y+3, r1	; 0x03
    6762:	1c 82       	std	Y+4, r1	; 0x04
    6764:	10 c0       	rjmp	.+32     	; 0x6786 <prvTaskCheckFreeStackSpace+0x3c>

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
    6766:	8d 81       	ldd	r24, Y+5	; 0x05
    6768:	9e 81       	ldd	r25, Y+6	; 0x06
    676a:	01 96       	adiw	r24, 0x01	; 1
    676c:	9e 83       	std	Y+6, r25	; 0x06
    676e:	8d 83       	std	Y+5, r24	; 0x05
			ulCount++;
    6770:	89 81       	ldd	r24, Y+1	; 0x01
    6772:	9a 81       	ldd	r25, Y+2	; 0x02
    6774:	ab 81       	ldd	r26, Y+3	; 0x03
    6776:	bc 81       	ldd	r27, Y+4	; 0x04
    6778:	01 96       	adiw	r24, 0x01	; 1
    677a:	a1 1d       	adc	r26, r1
    677c:	b1 1d       	adc	r27, r1
    677e:	89 83       	std	Y+1, r24	; 0x01
    6780:	9a 83       	std	Y+2, r25	; 0x02
    6782:	ab 83       	std	Y+3, r26	; 0x03
    6784:	bc 83       	std	Y+4, r27	; 0x04

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    6786:	ed 81       	ldd	r30, Y+5	; 0x05
    6788:	fe 81       	ldd	r31, Y+6	; 0x06
    678a:	80 81       	ld	r24, Z
    678c:	85 3a       	cpi	r24, 0xA5	; 165
    678e:	59 f3       	breq	.-42     	; 0x6766 <prvTaskCheckFreeStackSpace+0x1c>
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

		return ( uint16_t ) ulCount;
    6790:	89 81       	ldd	r24, Y+1	; 0x01
    6792:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    6794:	26 96       	adiw	r28, 0x06	; 6
    6796:	0f b6       	in	r0, 0x3f	; 63
    6798:	f8 94       	cli
    679a:	de bf       	out	0x3e, r29	; 62
    679c:	0f be       	out	0x3f, r0	; 63
    679e:	cd bf       	out	0x3d, r28	; 61
    67a0:	cf 91       	pop	r28
    67a2:	df 91       	pop	r29
    67a4:	08 95       	ret

000067a6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    67a6:	df 93       	push	r29
    67a8:	cf 93       	push	r28
    67aa:	00 d0       	rcall	.+0      	; 0x67ac <prvDeleteTCB+0x6>
    67ac:	cd b7       	in	r28, 0x3d	; 61
    67ae:	de b7       	in	r29, 0x3e	; 62
    67b0:	9a 83       	std	Y+2, r25	; 0x02
    67b2:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    67b4:	e9 81       	ldd	r30, Y+1	; 0x01
    67b6:	fa 81       	ldd	r31, Y+2	; 0x02
    67b8:	87 89       	ldd	r24, Z+23	; 0x17
    67ba:	90 8d       	ldd	r25, Z+24	; 0x18
    67bc:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
		vPortFree( pxTCB );
    67c0:	89 81       	ldd	r24, Y+1	; 0x01
    67c2:	9a 81       	ldd	r25, Y+2	; 0x02
    67c4:	0e 94 4b 19 	call	0x3296	; 0x3296 <vPortFree>
	}
    67c8:	0f 90       	pop	r0
    67ca:	0f 90       	pop	r0
    67cc:	cf 91       	pop	r28
    67ce:	df 91       	pop	r29
    67d0:	08 95       	ret

000067d2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    67d2:	df 93       	push	r29
    67d4:	cf 93       	push	r28
    67d6:	00 d0       	rcall	.+0      	; 0x67d8 <prvResetNextTaskUnblockTime+0x6>
    67d8:	cd b7       	in	r28, 0x3d	; 61
    67da:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    67dc:	e0 91 41 07 	lds	r30, 0x0741
    67e0:	f0 91 42 07 	lds	r31, 0x0742
    67e4:	80 81       	ld	r24, Z
    67e6:	88 23       	and	r24, r24
    67e8:	39 f4       	brne	.+14     	; 0x67f8 <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    67ea:	8f ef       	ldi	r24, 0xFF	; 255
    67ec:	9f ef       	ldi	r25, 0xFF	; 255
    67ee:	90 93 a7 00 	sts	0x00A7, r25
    67f2:	80 93 a6 00 	sts	0x00A6, r24
    67f6:	13 c0       	rjmp	.+38     	; 0x681e <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    67f8:	e0 91 41 07 	lds	r30, 0x0741
    67fc:	f0 91 42 07 	lds	r31, 0x0742
    6800:	05 80       	ldd	r0, Z+5	; 0x05
    6802:	f6 81       	ldd	r31, Z+6	; 0x06
    6804:	e0 2d       	mov	r30, r0
    6806:	86 81       	ldd	r24, Z+6	; 0x06
    6808:	97 81       	ldd	r25, Z+7	; 0x07
    680a:	9a 83       	std	Y+2, r25	; 0x02
    680c:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    680e:	e9 81       	ldd	r30, Y+1	; 0x01
    6810:	fa 81       	ldd	r31, Y+2	; 0x02
    6812:	82 81       	ldd	r24, Z+2	; 0x02
    6814:	93 81       	ldd	r25, Z+3	; 0x03
    6816:	90 93 a7 00 	sts	0x00A7, r25
    681a:	80 93 a6 00 	sts	0x00A6, r24
	}
}
    681e:	0f 90       	pop	r0
    6820:	0f 90       	pop	r0
    6822:	cf 91       	pop	r28
    6824:	df 91       	pop	r29
    6826:	08 95       	ret

00006828 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    6828:	df 93       	push	r29
    682a:	cf 93       	push	r28
    682c:	00 d0       	rcall	.+0      	; 0x682e <xTaskGetCurrentTaskHandle+0x6>
    682e:	cd b7       	in	r28, 0x3d	; 61
    6830:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    6832:	80 91 ec 06 	lds	r24, 0x06EC
    6836:	90 91 ed 06 	lds	r25, 0x06ED
    683a:	9a 83       	std	Y+2, r25	; 0x02
    683c:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    683e:	89 81       	ldd	r24, Y+1	; 0x01
    6840:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    6842:	0f 90       	pop	r0
    6844:	0f 90       	pop	r0
    6846:	cf 91       	pop	r28
    6848:	df 91       	pop	r29
    684a:	08 95       	ret

0000684c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    684c:	df 93       	push	r29
    684e:	cf 93       	push	r28
    6850:	00 d0       	rcall	.+0      	; 0x6852 <vTaskPriorityInherit+0x6>
    6852:	00 d0       	rcall	.+0      	; 0x6854 <vTaskPriorityInherit+0x8>
    6854:	cd b7       	in	r28, 0x3d	; 61
    6856:	de b7       	in	r29, 0x3e	; 62
    6858:	9c 83       	std	Y+4, r25	; 0x04
    685a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    685c:	8b 81       	ldd	r24, Y+3	; 0x03
    685e:	9c 81       	ldd	r25, Y+4	; 0x04
    6860:	9a 83       	std	Y+2, r25	; 0x02
    6862:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    6864:	8b 81       	ldd	r24, Y+3	; 0x03
    6866:	9c 81       	ldd	r25, Y+4	; 0x04
    6868:	00 97       	sbiw	r24, 0x00	; 0
    686a:	09 f4       	brne	.+2      	; 0x686e <vTaskPriorityInherit+0x22>
    686c:	73 c0       	rjmp	.+230    	; 0x6954 <vTaskPriorityInherit+0x108>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    686e:	e9 81       	ldd	r30, Y+1	; 0x01
    6870:	fa 81       	ldd	r31, Y+2	; 0x02
    6872:	96 89       	ldd	r25, Z+22	; 0x16
    6874:	e0 91 ec 06 	lds	r30, 0x06EC
    6878:	f0 91 ed 06 	lds	r31, 0x06ED
    687c:	86 89       	ldd	r24, Z+22	; 0x16
    687e:	98 17       	cp	r25, r24
    6880:	08 f0       	brcs	.+2      	; 0x6884 <vTaskPriorityInherit+0x38>
    6882:	68 c0       	rjmp	.+208    	; 0x6954 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    6884:	e9 81       	ldd	r30, Y+1	; 0x01
    6886:	fa 81       	ldd	r31, Y+2	; 0x02
    6888:	84 85       	ldd	r24, Z+12	; 0x0c
    688a:	95 85       	ldd	r25, Z+13	; 0x0d
    688c:	99 23       	and	r25, r25
    688e:	7c f0       	brlt	.+30     	; 0x68ae <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6890:	e0 91 ec 06 	lds	r30, 0x06EC
    6894:	f0 91 ed 06 	lds	r31, 0x06ED
    6898:	86 89       	ldd	r24, Z+22	; 0x16
    689a:	28 2f       	mov	r18, r24
    689c:	30 e0       	ldi	r19, 0x00	; 0
    689e:	86 e0       	ldi	r24, 0x06	; 6
    68a0:	90 e0       	ldi	r25, 0x00	; 0
    68a2:	82 1b       	sub	r24, r18
    68a4:	93 0b       	sbc	r25, r19
    68a6:	e9 81       	ldd	r30, Y+1	; 0x01
    68a8:	fa 81       	ldd	r31, Y+2	; 0x02
    68aa:	95 87       	std	Z+13, r25	; 0x0d
    68ac:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    68ae:	e9 81       	ldd	r30, Y+1	; 0x01
    68b0:	fa 81       	ldd	r31, Y+2	; 0x02
    68b2:	42 85       	ldd	r20, Z+10	; 0x0a
    68b4:	53 85       	ldd	r21, Z+11	; 0x0b
    68b6:	e9 81       	ldd	r30, Y+1	; 0x01
    68b8:	fa 81       	ldd	r31, Y+2	; 0x02
    68ba:	86 89       	ldd	r24, Z+22	; 0x16
    68bc:	28 2f       	mov	r18, r24
    68be:	30 e0       	ldi	r19, 0x00	; 0
    68c0:	c9 01       	movw	r24, r18
    68c2:	88 0f       	add	r24, r24
    68c4:	99 1f       	adc	r25, r25
    68c6:	88 0f       	add	r24, r24
    68c8:	99 1f       	adc	r25, r25
    68ca:	88 0f       	add	r24, r24
    68cc:	99 1f       	adc	r25, r25
    68ce:	82 0f       	add	r24, r18
    68d0:	93 1f       	adc	r25, r19
    68d2:	87 50       	subi	r24, 0x07	; 7
    68d4:	99 4f       	sbci	r25, 0xF9	; 249
    68d6:	48 17       	cp	r20, r24
    68d8:	59 07       	cpc	r21, r25
    68da:	a1 f5       	brne	.+104    	; 0x6944 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    68dc:	89 81       	ldd	r24, Y+1	; 0x01
    68de:	9a 81       	ldd	r25, Y+2	; 0x02
    68e0:	02 96       	adiw	r24, 0x02	; 2
    68e2:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    68e6:	e0 91 ec 06 	lds	r30, 0x06EC
    68ea:	f0 91 ed 06 	lds	r31, 0x06ED
    68ee:	86 89       	ldd	r24, Z+22	; 0x16
    68f0:	e9 81       	ldd	r30, Y+1	; 0x01
    68f2:	fa 81       	ldd	r31, Y+2	; 0x02
    68f4:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    68f6:	e9 81       	ldd	r30, Y+1	; 0x01
    68f8:	fa 81       	ldd	r31, Y+2	; 0x02
    68fa:	96 89       	ldd	r25, Z+22	; 0x16
    68fc:	80 91 f2 06 	lds	r24, 0x06F2
    6900:	89 17       	cp	r24, r25
    6902:	28 f4       	brcc	.+10     	; 0x690e <vTaskPriorityInherit+0xc2>
    6904:	e9 81       	ldd	r30, Y+1	; 0x01
    6906:	fa 81       	ldd	r31, Y+2	; 0x02
    6908:	86 89       	ldd	r24, Z+22	; 0x16
    690a:	80 93 f2 06 	sts	0x06F2, r24
    690e:	e9 81       	ldd	r30, Y+1	; 0x01
    6910:	fa 81       	ldd	r31, Y+2	; 0x02
    6912:	86 89       	ldd	r24, Z+22	; 0x16
    6914:	28 2f       	mov	r18, r24
    6916:	30 e0       	ldi	r19, 0x00	; 0
    6918:	c9 01       	movw	r24, r18
    691a:	88 0f       	add	r24, r24
    691c:	99 1f       	adc	r25, r25
    691e:	88 0f       	add	r24, r24
    6920:	99 1f       	adc	r25, r25
    6922:	88 0f       	add	r24, r24
    6924:	99 1f       	adc	r25, r25
    6926:	82 0f       	add	r24, r18
    6928:	93 1f       	adc	r25, r19
    692a:	ac 01       	movw	r20, r24
    692c:	47 50       	subi	r20, 0x07	; 7
    692e:	59 4f       	sbci	r21, 0xF9	; 249
    6930:	89 81       	ldd	r24, Y+1	; 0x01
    6932:	9a 81       	ldd	r25, Y+2	; 0x02
    6934:	9c 01       	movw	r18, r24
    6936:	2e 5f       	subi	r18, 0xFE	; 254
    6938:	3f 4f       	sbci	r19, 0xFF	; 255
    693a:	ca 01       	movw	r24, r20
    693c:	b9 01       	movw	r22, r18
    693e:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>
    6942:	08 c0       	rjmp	.+16     	; 0x6954 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    6944:	e0 91 ec 06 	lds	r30, 0x06EC
    6948:	f0 91 ed 06 	lds	r31, 0x06ED
    694c:	86 89       	ldd	r24, Z+22	; 0x16
    694e:	e9 81       	ldd	r30, Y+1	; 0x01
    6950:	fa 81       	ldd	r31, Y+2	; 0x02
    6952:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6954:	0f 90       	pop	r0
    6956:	0f 90       	pop	r0
    6958:	0f 90       	pop	r0
    695a:	0f 90       	pop	r0
    695c:	cf 91       	pop	r28
    695e:	df 91       	pop	r29
    6960:	08 95       	ret

00006962 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    6962:	df 93       	push	r29
    6964:	cf 93       	push	r28
    6966:	00 d0       	rcall	.+0      	; 0x6968 <xTaskPriorityDisinherit+0x6>
    6968:	00 d0       	rcall	.+0      	; 0x696a <xTaskPriorityDisinherit+0x8>
    696a:	0f 92       	push	r0
    696c:	cd b7       	in	r28, 0x3d	; 61
    696e:	de b7       	in	r29, 0x3e	; 62
    6970:	9d 83       	std	Y+5, r25	; 0x05
    6972:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    6974:	8c 81       	ldd	r24, Y+4	; 0x04
    6976:	9d 81       	ldd	r25, Y+5	; 0x05
    6978:	9b 83       	std	Y+3, r25	; 0x03
    697a:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    697c:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    697e:	8c 81       	ldd	r24, Y+4	; 0x04
    6980:	9d 81       	ldd	r25, Y+5	; 0x05
    6982:	00 97       	sbiw	r24, 0x00	; 0
    6984:	09 f4       	brne	.+2      	; 0x6988 <xTaskPriorityDisinherit+0x26>
    6986:	56 c0       	rjmp	.+172    	; 0x6a34 <xTaskPriorityDisinherit+0xd2>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    6988:	ea 81       	ldd	r30, Y+2	; 0x02
    698a:	fb 81       	ldd	r31, Y+3	; 0x03
    698c:	80 a9       	ldd	r24, Z+48	; 0x30
    698e:	81 50       	subi	r24, 0x01	; 1
    6990:	ea 81       	ldd	r30, Y+2	; 0x02
    6992:	fb 81       	ldd	r31, Y+3	; 0x03
    6994:	80 ab       	std	Z+48, r24	; 0x30

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    6996:	ea 81       	ldd	r30, Y+2	; 0x02
    6998:	fb 81       	ldd	r31, Y+3	; 0x03
    699a:	96 89       	ldd	r25, Z+22	; 0x16
    699c:	ea 81       	ldd	r30, Y+2	; 0x02
    699e:	fb 81       	ldd	r31, Y+3	; 0x03
    69a0:	87 a5       	ldd	r24, Z+47	; 0x2f
    69a2:	98 17       	cp	r25, r24
    69a4:	09 f4       	brne	.+2      	; 0x69a8 <xTaskPriorityDisinherit+0x46>
    69a6:	46 c0       	rjmp	.+140    	; 0x6a34 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    69a8:	ea 81       	ldd	r30, Y+2	; 0x02
    69aa:	fb 81       	ldd	r31, Y+3	; 0x03
    69ac:	80 a9       	ldd	r24, Z+48	; 0x30
    69ae:	88 23       	and	r24, r24
    69b0:	09 f0       	breq	.+2      	; 0x69b4 <xTaskPriorityDisinherit+0x52>
    69b2:	40 c0       	rjmp	.+128    	; 0x6a34 <xTaskPriorityDisinherit+0xd2>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    69b4:	8a 81       	ldd	r24, Y+2	; 0x02
    69b6:	9b 81       	ldd	r25, Y+3	; 0x03
    69b8:	02 96       	adiw	r24, 0x02	; 2
    69ba:	0e 94 2d 1b 	call	0x365a	; 0x365a <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    69be:	ea 81       	ldd	r30, Y+2	; 0x02
    69c0:	fb 81       	ldd	r31, Y+3	; 0x03
    69c2:	87 a5       	ldd	r24, Z+47	; 0x2f
    69c4:	ea 81       	ldd	r30, Y+2	; 0x02
    69c6:	fb 81       	ldd	r31, Y+3	; 0x03
    69c8:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    69ca:	ea 81       	ldd	r30, Y+2	; 0x02
    69cc:	fb 81       	ldd	r31, Y+3	; 0x03
    69ce:	86 89       	ldd	r24, Z+22	; 0x16
    69d0:	28 2f       	mov	r18, r24
    69d2:	30 e0       	ldi	r19, 0x00	; 0
    69d4:	86 e0       	ldi	r24, 0x06	; 6
    69d6:	90 e0       	ldi	r25, 0x00	; 0
    69d8:	82 1b       	sub	r24, r18
    69da:	93 0b       	sbc	r25, r19
    69dc:	ea 81       	ldd	r30, Y+2	; 0x02
    69de:	fb 81       	ldd	r31, Y+3	; 0x03
    69e0:	95 87       	std	Z+13, r25	; 0x0d
    69e2:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    69e4:	ea 81       	ldd	r30, Y+2	; 0x02
    69e6:	fb 81       	ldd	r31, Y+3	; 0x03
    69e8:	96 89       	ldd	r25, Z+22	; 0x16
    69ea:	80 91 f2 06 	lds	r24, 0x06F2
    69ee:	89 17       	cp	r24, r25
    69f0:	28 f4       	brcc	.+10     	; 0x69fc <xTaskPriorityDisinherit+0x9a>
    69f2:	ea 81       	ldd	r30, Y+2	; 0x02
    69f4:	fb 81       	ldd	r31, Y+3	; 0x03
    69f6:	86 89       	ldd	r24, Z+22	; 0x16
    69f8:	80 93 f2 06 	sts	0x06F2, r24
    69fc:	ea 81       	ldd	r30, Y+2	; 0x02
    69fe:	fb 81       	ldd	r31, Y+3	; 0x03
    6a00:	86 89       	ldd	r24, Z+22	; 0x16
    6a02:	28 2f       	mov	r18, r24
    6a04:	30 e0       	ldi	r19, 0x00	; 0
    6a06:	c9 01       	movw	r24, r18
    6a08:	88 0f       	add	r24, r24
    6a0a:	99 1f       	adc	r25, r25
    6a0c:	88 0f       	add	r24, r24
    6a0e:	99 1f       	adc	r25, r25
    6a10:	88 0f       	add	r24, r24
    6a12:	99 1f       	adc	r25, r25
    6a14:	82 0f       	add	r24, r18
    6a16:	93 1f       	adc	r25, r19
    6a18:	ac 01       	movw	r20, r24
    6a1a:	47 50       	subi	r20, 0x07	; 7
    6a1c:	59 4f       	sbci	r21, 0xF9	; 249
    6a1e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a20:	9b 81       	ldd	r25, Y+3	; 0x03
    6a22:	9c 01       	movw	r18, r24
    6a24:	2e 5f       	subi	r18, 0xFE	; 254
    6a26:	3f 4f       	sbci	r19, 0xFF	; 255
    6a28:	ca 01       	movw	r24, r20
    6a2a:	b9 01       	movw	r22, r18
    6a2c:	0e 94 7d 1a 	call	0x34fa	; 0x34fa <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    6a30:	81 e0       	ldi	r24, 0x01	; 1
    6a32:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    6a34:	89 81       	ldd	r24, Y+1	; 0x01
	}
    6a36:	0f 90       	pop	r0
    6a38:	0f 90       	pop	r0
    6a3a:	0f 90       	pop	r0
    6a3c:	0f 90       	pop	r0
    6a3e:	0f 90       	pop	r0
    6a40:	cf 91       	pop	r28
    6a42:	df 91       	pop	r29
    6a44:	08 95       	ret

00006a46 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    6a46:	df 93       	push	r29
    6a48:	cf 93       	push	r28
    6a4a:	00 d0       	rcall	.+0      	; 0x6a4c <uxTaskResetEventItemValue+0x6>
    6a4c:	cd b7       	in	r28, 0x3d	; 61
    6a4e:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    6a50:	e0 91 ec 06 	lds	r30, 0x06EC
    6a54:	f0 91 ed 06 	lds	r31, 0x06ED
    6a58:	84 85       	ldd	r24, Z+12	; 0x0c
    6a5a:	95 85       	ldd	r25, Z+13	; 0x0d
    6a5c:	9a 83       	std	Y+2, r25	; 0x02
    6a5e:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6a60:	a0 91 ec 06 	lds	r26, 0x06EC
    6a64:	b0 91 ed 06 	lds	r27, 0x06ED
    6a68:	e0 91 ec 06 	lds	r30, 0x06EC
    6a6c:	f0 91 ed 06 	lds	r31, 0x06ED
    6a70:	86 89       	ldd	r24, Z+22	; 0x16
    6a72:	28 2f       	mov	r18, r24
    6a74:	30 e0       	ldi	r19, 0x00	; 0
    6a76:	86 e0       	ldi	r24, 0x06	; 6
    6a78:	90 e0       	ldi	r25, 0x00	; 0
    6a7a:	82 1b       	sub	r24, r18
    6a7c:	93 0b       	sbc	r25, r19
    6a7e:	1d 96       	adiw	r26, 0x0d	; 13
    6a80:	9c 93       	st	X, r25
    6a82:	8e 93       	st	-X, r24
    6a84:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    6a86:	89 81       	ldd	r24, Y+1	; 0x01
    6a88:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6a8a:	0f 90       	pop	r0
    6a8c:	0f 90       	pop	r0
    6a8e:	cf 91       	pop	r28
    6a90:	df 91       	pop	r29
    6a92:	08 95       	ret

00006a94 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    6a94:	df 93       	push	r29
    6a96:	cf 93       	push	r28
    6a98:	cd b7       	in	r28, 0x3d	; 61
    6a9a:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    6a9c:	80 91 ec 06 	lds	r24, 0x06EC
    6aa0:	90 91 ed 06 	lds	r25, 0x06ED
    6aa4:	00 97       	sbiw	r24, 0x00	; 0
    6aa6:	39 f0       	breq	.+14     	; 0x6ab6 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    6aa8:	e0 91 ec 06 	lds	r30, 0x06EC
    6aac:	f0 91 ed 06 	lds	r31, 0x06ED
    6ab0:	80 a9       	ldd	r24, Z+48	; 0x30
    6ab2:	8f 5f       	subi	r24, 0xFF	; 255
    6ab4:	80 ab       	std	Z+48, r24	; 0x30
		}

		return pxCurrentTCB;
    6ab6:	80 91 ec 06 	lds	r24, 0x06EC
    6aba:	90 91 ed 06 	lds	r25, 0x06ED
	}
    6abe:	cf 91       	pop	r28
    6ac0:	df 91       	pop	r29
    6ac2:	08 95       	ret

00006ac4 <__mulsi3>:
    6ac4:	62 9f       	mul	r22, r18
    6ac6:	d0 01       	movw	r26, r0
    6ac8:	73 9f       	mul	r23, r19
    6aca:	f0 01       	movw	r30, r0
    6acc:	82 9f       	mul	r24, r18
    6ace:	e0 0d       	add	r30, r0
    6ad0:	f1 1d       	adc	r31, r1
    6ad2:	64 9f       	mul	r22, r20
    6ad4:	e0 0d       	add	r30, r0
    6ad6:	f1 1d       	adc	r31, r1
    6ad8:	92 9f       	mul	r25, r18
    6ada:	f0 0d       	add	r31, r0
    6adc:	83 9f       	mul	r24, r19
    6ade:	f0 0d       	add	r31, r0
    6ae0:	74 9f       	mul	r23, r20
    6ae2:	f0 0d       	add	r31, r0
    6ae4:	65 9f       	mul	r22, r21
    6ae6:	f0 0d       	add	r31, r0
    6ae8:	99 27       	eor	r25, r25
    6aea:	72 9f       	mul	r23, r18
    6aec:	b0 0d       	add	r27, r0
    6aee:	e1 1d       	adc	r30, r1
    6af0:	f9 1f       	adc	r31, r25
    6af2:	63 9f       	mul	r22, r19
    6af4:	b0 0d       	add	r27, r0
    6af6:	e1 1d       	adc	r30, r1
    6af8:	f9 1f       	adc	r31, r25
    6afa:	bd 01       	movw	r22, r26
    6afc:	cf 01       	movw	r24, r30
    6afe:	11 24       	eor	r1, r1
    6b00:	08 95       	ret

00006b02 <__udivmodqi4>:
    6b02:	99 1b       	sub	r25, r25
    6b04:	79 e0       	ldi	r23, 0x09	; 9
    6b06:	04 c0       	rjmp	.+8      	; 0x6b10 <__udivmodqi4_ep>

00006b08 <__udivmodqi4_loop>:
    6b08:	99 1f       	adc	r25, r25
    6b0a:	96 17       	cp	r25, r22
    6b0c:	08 f0       	brcs	.+2      	; 0x6b10 <__udivmodqi4_ep>
    6b0e:	96 1b       	sub	r25, r22

00006b10 <__udivmodqi4_ep>:
    6b10:	88 1f       	adc	r24, r24
    6b12:	7a 95       	dec	r23
    6b14:	c9 f7       	brne	.-14     	; 0x6b08 <__udivmodqi4_loop>
    6b16:	80 95       	com	r24
    6b18:	08 95       	ret

00006b1a <__divmodsi4>:
    6b1a:	97 fb       	bst	r25, 7
    6b1c:	09 2e       	mov	r0, r25
    6b1e:	05 26       	eor	r0, r21
    6b20:	0e d0       	rcall	.+28     	; 0x6b3e <__divmodsi4_neg1>
    6b22:	57 fd       	sbrc	r21, 7
    6b24:	04 d0       	rcall	.+8      	; 0x6b2e <__divmodsi4_neg2>
    6b26:	14 d0       	rcall	.+40     	; 0x6b50 <__udivmodsi4>
    6b28:	0a d0       	rcall	.+20     	; 0x6b3e <__divmodsi4_neg1>
    6b2a:	00 1c       	adc	r0, r0
    6b2c:	38 f4       	brcc	.+14     	; 0x6b3c <__divmodsi4_exit>

00006b2e <__divmodsi4_neg2>:
    6b2e:	50 95       	com	r21
    6b30:	40 95       	com	r20
    6b32:	30 95       	com	r19
    6b34:	21 95       	neg	r18
    6b36:	3f 4f       	sbci	r19, 0xFF	; 255
    6b38:	4f 4f       	sbci	r20, 0xFF	; 255
    6b3a:	5f 4f       	sbci	r21, 0xFF	; 255

00006b3c <__divmodsi4_exit>:
    6b3c:	08 95       	ret

00006b3e <__divmodsi4_neg1>:
    6b3e:	f6 f7       	brtc	.-4      	; 0x6b3c <__divmodsi4_exit>
    6b40:	90 95       	com	r25
    6b42:	80 95       	com	r24
    6b44:	70 95       	com	r23
    6b46:	61 95       	neg	r22
    6b48:	7f 4f       	sbci	r23, 0xFF	; 255
    6b4a:	8f 4f       	sbci	r24, 0xFF	; 255
    6b4c:	9f 4f       	sbci	r25, 0xFF	; 255
    6b4e:	08 95       	ret

00006b50 <__udivmodsi4>:
    6b50:	a1 e2       	ldi	r26, 0x21	; 33
    6b52:	1a 2e       	mov	r1, r26
    6b54:	aa 1b       	sub	r26, r26
    6b56:	bb 1b       	sub	r27, r27
    6b58:	fd 01       	movw	r30, r26
    6b5a:	0d c0       	rjmp	.+26     	; 0x6b76 <__udivmodsi4_ep>

00006b5c <__udivmodsi4_loop>:
    6b5c:	aa 1f       	adc	r26, r26
    6b5e:	bb 1f       	adc	r27, r27
    6b60:	ee 1f       	adc	r30, r30
    6b62:	ff 1f       	adc	r31, r31
    6b64:	a2 17       	cp	r26, r18
    6b66:	b3 07       	cpc	r27, r19
    6b68:	e4 07       	cpc	r30, r20
    6b6a:	f5 07       	cpc	r31, r21
    6b6c:	20 f0       	brcs	.+8      	; 0x6b76 <__udivmodsi4_ep>
    6b6e:	a2 1b       	sub	r26, r18
    6b70:	b3 0b       	sbc	r27, r19
    6b72:	e4 0b       	sbc	r30, r20
    6b74:	f5 0b       	sbc	r31, r21

00006b76 <__udivmodsi4_ep>:
    6b76:	66 1f       	adc	r22, r22
    6b78:	77 1f       	adc	r23, r23
    6b7a:	88 1f       	adc	r24, r24
    6b7c:	99 1f       	adc	r25, r25
    6b7e:	1a 94       	dec	r1
    6b80:	69 f7       	brne	.-38     	; 0x6b5c <__udivmodsi4_loop>
    6b82:	60 95       	com	r22
    6b84:	70 95       	com	r23
    6b86:	80 95       	com	r24
    6b88:	90 95       	com	r25
    6b8a:	9b 01       	movw	r18, r22
    6b8c:	ac 01       	movw	r20, r24
    6b8e:	bd 01       	movw	r22, r26
    6b90:	cf 01       	movw	r24, r30
    6b92:	08 95       	ret

00006b94 <__prologue_saves__>:
    6b94:	2f 92       	push	r2
    6b96:	3f 92       	push	r3
    6b98:	4f 92       	push	r4
    6b9a:	5f 92       	push	r5
    6b9c:	6f 92       	push	r6
    6b9e:	7f 92       	push	r7
    6ba0:	8f 92       	push	r8
    6ba2:	9f 92       	push	r9
    6ba4:	af 92       	push	r10
    6ba6:	bf 92       	push	r11
    6ba8:	cf 92       	push	r12
    6baa:	df 92       	push	r13
    6bac:	ef 92       	push	r14
    6bae:	ff 92       	push	r15
    6bb0:	0f 93       	push	r16
    6bb2:	1f 93       	push	r17
    6bb4:	cf 93       	push	r28
    6bb6:	df 93       	push	r29
    6bb8:	cd b7       	in	r28, 0x3d	; 61
    6bba:	de b7       	in	r29, 0x3e	; 62
    6bbc:	ca 1b       	sub	r28, r26
    6bbe:	db 0b       	sbc	r29, r27
    6bc0:	0f b6       	in	r0, 0x3f	; 63
    6bc2:	f8 94       	cli
    6bc4:	de bf       	out	0x3e, r29	; 62
    6bc6:	0f be       	out	0x3f, r0	; 63
    6bc8:	cd bf       	out	0x3d, r28	; 61
    6bca:	09 94       	ijmp

00006bcc <__epilogue_restores__>:
    6bcc:	2a 88       	ldd	r2, Y+18	; 0x12
    6bce:	39 88       	ldd	r3, Y+17	; 0x11
    6bd0:	48 88       	ldd	r4, Y+16	; 0x10
    6bd2:	5f 84       	ldd	r5, Y+15	; 0x0f
    6bd4:	6e 84       	ldd	r6, Y+14	; 0x0e
    6bd6:	7d 84       	ldd	r7, Y+13	; 0x0d
    6bd8:	8c 84       	ldd	r8, Y+12	; 0x0c
    6bda:	9b 84       	ldd	r9, Y+11	; 0x0b
    6bdc:	aa 84       	ldd	r10, Y+10	; 0x0a
    6bde:	b9 84       	ldd	r11, Y+9	; 0x09
    6be0:	c8 84       	ldd	r12, Y+8	; 0x08
    6be2:	df 80       	ldd	r13, Y+7	; 0x07
    6be4:	ee 80       	ldd	r14, Y+6	; 0x06
    6be6:	fd 80       	ldd	r15, Y+5	; 0x05
    6be8:	0c 81       	ldd	r16, Y+4	; 0x04
    6bea:	1b 81       	ldd	r17, Y+3	; 0x03
    6bec:	aa 81       	ldd	r26, Y+2	; 0x02
    6bee:	b9 81       	ldd	r27, Y+1	; 0x01
    6bf0:	ce 0f       	add	r28, r30
    6bf2:	d1 1d       	adc	r29, r1
    6bf4:	0f b6       	in	r0, 0x3f	; 63
    6bf6:	f8 94       	cli
    6bf8:	de bf       	out	0x3e, r29	; 62
    6bfa:	0f be       	out	0x3f, r0	; 63
    6bfc:	cd bf       	out	0x3d, r28	; 61
    6bfe:	ed 01       	movw	r28, r26
    6c00:	08 95       	ret

00006c02 <memcpy>:
    6c02:	fb 01       	movw	r30, r22
    6c04:	dc 01       	movw	r26, r24
    6c06:	02 c0       	rjmp	.+4      	; 0x6c0c <memcpy+0xa>
    6c08:	01 90       	ld	r0, Z+
    6c0a:	0d 92       	st	X+, r0
    6c0c:	41 50       	subi	r20, 0x01	; 1
    6c0e:	50 40       	sbci	r21, 0x00	; 0
    6c10:	d8 f7       	brcc	.-10     	; 0x6c08 <memcpy+0x6>
    6c12:	08 95       	ret

00006c14 <memset>:
    6c14:	dc 01       	movw	r26, r24
    6c16:	01 c0       	rjmp	.+2      	; 0x6c1a <memset+0x6>
    6c18:	6d 93       	st	X+, r22
    6c1a:	41 50       	subi	r20, 0x01	; 1
    6c1c:	50 40       	sbci	r21, 0x00	; 0
    6c1e:	e0 f7       	brcc	.-8      	; 0x6c18 <memset+0x4>
    6c20:	08 95       	ret

00006c22 <_exit>:
    6c22:	f8 94       	cli

00006c24 <__stop_program>:
    6c24:	ff cf       	rjmp	.-2      	; 0x6c24 <__stop_program>
